# ! [ doc = "Peripheral access API for STM32F100XX microcontrollers (generated using svd2rust v0.7.0)" ] # ! [ deny ( missing_docs ) ] # ! [ deny ( warnings ) ] # ! [ feature ( const_fn ) ] # ! [ no_std ]extern crate cortex_m ;
extern crate vcell ;
use core::ops::Deref;
use cortex_m::peripheral::Peripheral;
# [ doc = r" Interrupts" ]
pub mod interrupt {
    use cortex_m::ctxt::Context;
    use cortex_m::exception;
    use cortex_m::interrupt::Nr;
    # [ doc = "0 - Window Watchdog interrupt" ]
    pub struct WwdgIrq {
        _0: (),
    }
    unsafe impl Context for WwdgIrq {}
    unsafe impl Nr for WwdgIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            0
        }
    }
    # [ doc = "1 - PVD through EXTI line detection interrupt" ]
    pub struct PvdIrq {
        _0: (),
    }
    unsafe impl Context for PvdIrq {}
    unsafe impl Nr for PvdIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            1
        }
    }
    # [ doc = "2 - Tamper and TimeStamp through EXTI line interrupts" ]
    pub struct TamperStampIrq {
        _0: (),
    }
    unsafe impl Context for TamperStampIrq {}
    unsafe impl Nr for TamperStampIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            2
        }
    }
    # [ doc = "3 - RTC Wakeup through EXTI line interrupt" ]
    pub struct RtcWkupIrq {
        _0: (),
    }
    unsafe impl Context for RtcWkupIrq {}
    unsafe impl Nr for RtcWkupIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            3
        }
    }
    # [ doc = "4 - Flash global interrupt" ]
    pub struct FlashIrq {
        _0: (),
    }
    unsafe impl Context for FlashIrq {}
    unsafe impl Nr for FlashIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            4
        }
    }
    # [ doc = "5 - RCC global interrupt" ]
    pub struct RccIrq {
        _0: (),
    }
    unsafe impl Context for RccIrq {}
    unsafe impl Nr for RccIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            5
        }
    }
    # [ doc = "6 - EXTI Line0 interrupt" ]
    pub struct Exti0Irq {
        _0: (),
    }
    unsafe impl Context for Exti0Irq {}
    unsafe impl Nr for Exti0Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            6
        }
    }
    # [ doc = "7 - EXTI Line1 interrupt" ]
    pub struct Exti1Irq {
        _0: (),
    }
    unsafe impl Context for Exti1Irq {}
    unsafe impl Nr for Exti1Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            7
        }
    }
    # [ doc = "8 - EXTI Line2 interrupt" ]
    pub struct Exti2Irq {
        _0: (),
    }
    unsafe impl Context for Exti2Irq {}
    unsafe impl Nr for Exti2Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            8
        }
    }
    # [ doc = "9 - EXTI Line3 interrupt" ]
    pub struct Exti3Irq {
        _0: (),
    }
    unsafe impl Context for Exti3Irq {}
    unsafe impl Nr for Exti3Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            9
        }
    }
    # [ doc = "10 - EXTI Line4 interrupt" ]
    pub struct Exti4Irq {
        _0: (),
    }
    unsafe impl Context for Exti4Irq {}
    unsafe impl Nr for Exti4Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            10
        }
    }
    # [ doc = "11 - DMA1 Channel1 global interrupt" ]
    pub struct Dma1Channel1Irq {
        _0: (),
    }
    unsafe impl Context for Dma1Channel1Irq {}
    unsafe impl Nr for Dma1Channel1Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            11
        }
    }
    # [ doc = "12 - DMA1 Channel2 global interrupt" ]
    pub struct Dma1Channel2Irq {
        _0: (),
    }
    unsafe impl Context for Dma1Channel2Irq {}
    unsafe impl Nr for Dma1Channel2Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            12
        }
    }
    # [ doc = "13 - DMA1 Channel3 global interrupt" ]
    pub struct Dma1Channel3Irq {
        _0: (),
    }
    unsafe impl Context for Dma1Channel3Irq {}
    unsafe impl Nr for Dma1Channel3Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            13
        }
    }
    # [ doc = "14 - DMA1 Channel4 global interrupt" ]
    pub struct Dma1Channel4Irq {
        _0: (),
    }
    unsafe impl Context for Dma1Channel4Irq {}
    unsafe impl Nr for Dma1Channel4Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            14
        }
    }
    # [ doc = "15 - DMA1 Channel5 global interrupt" ]
    pub struct Dma1Channel5Irq {
        _0: (),
    }
    unsafe impl Context for Dma1Channel5Irq {}
    unsafe impl Nr for Dma1Channel5Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            15
        }
    }
    # [ doc = "16 - DMA1 Channel6 global interrupt" ]
    pub struct Dma1Channel6Irq {
        _0: (),
    }
    unsafe impl Context for Dma1Channel6Irq {}
    unsafe impl Nr for Dma1Channel6Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            16
        }
    }
    # [ doc = "17 - DMA1 Channel7 global interrupt" ]
    pub struct Dma1Channel7Irq {
        _0: (),
    }
    unsafe impl Context for Dma1Channel7Irq {}
    unsafe impl Nr for Dma1Channel7Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            17
        }
    }
    # [ doc = "18 - ADC1 global interrupt" ]
    pub struct AdcIrq {
        _0: (),
    }
    unsafe impl Context for AdcIrq {}
    unsafe impl Nr for AdcIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            18
        }
    }
    # [ doc = "23 - EXTI Line[9:5] interrupts" ]
    pub struct Exti95Irq {
        _0: (),
    }
    unsafe impl Context for Exti95Irq {}
    unsafe impl Nr for Exti95Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            23
        }
    }
    # [ doc = "24 - TIM1 Break interrupt and TIM15 global interrupt" ]
    pub struct Tim1BrkTim15Irq {
        _0: (),
    }
    unsafe impl Context for Tim1BrkTim15Irq {}
    unsafe impl Nr for Tim1BrkTim15Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            24
        }
    }
    # [ doc = "25 - TIM1 Update interrupt and TIM16 global interrupt" ]
    pub struct Tim1UpTim16Irq {
        _0: (),
    }
    unsafe impl Context for Tim1UpTim16Irq {}
    unsafe impl Nr for Tim1UpTim16Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            25
        }
    }
    # [ doc = "26 - TIM1 Trigger and Commutation interrupts and TIM17 global interrupt" ]
    pub struct Tim1TrgComTim17Irq {
        _0: (),
    }
    unsafe impl Context for Tim1TrgComTim17Irq {}
    unsafe impl Nr for Tim1TrgComTim17Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            26
        }
    }
    # [ doc = "27 - TIM1 Capture Compare interrupt" ]
    pub struct Tim1CcIrq {
        _0: (),
    }
    unsafe impl Context for Tim1CcIrq {}
    unsafe impl Nr for Tim1CcIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            27
        }
    }
    # [ doc = "28 - TIM2 global interrupt" ]
    pub struct Tim2Irq {
        _0: (),
    }
    unsafe impl Context for Tim2Irq {}
    unsafe impl Nr for Tim2Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            28
        }
    }
    # [ doc = "29 - TIM3 global interrupt" ]
    pub struct Tim3Irq {
        _0: (),
    }
    unsafe impl Context for Tim3Irq {}
    unsafe impl Nr for Tim3Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            29
        }
    }
    # [ doc = "30 - TIM4 global interrupt" ]
    pub struct Tim4Irq {
        _0: (),
    }
    unsafe impl Context for Tim4Irq {}
    unsafe impl Nr for Tim4Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            30
        }
    }
    # [ doc = "31 - I2C1 event interrupt" ]
    pub struct I2c1EvIrq {
        _0: (),
    }
    unsafe impl Context for I2c1EvIrq {}
    unsafe impl Nr for I2c1EvIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            31
        }
    }
    # [ doc = "32 - I2C1 error interrupt" ]
    pub struct I2c1ErIrq {
        _0: (),
    }
    unsafe impl Context for I2c1ErIrq {}
    unsafe impl Nr for I2c1ErIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            32
        }
    }
    # [ doc = "33 - I2C2 event interrupt" ]
    pub struct I2c2EvIrq {
        _0: (),
    }
    unsafe impl Context for I2c2EvIrq {}
    unsafe impl Nr for I2c2EvIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            33
        }
    }
    # [ doc = "34 - I2C2 error interrupt" ]
    pub struct I2c2ErIrq {
        _0: (),
    }
    unsafe impl Context for I2c2ErIrq {}
    unsafe impl Nr for I2c2ErIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            34
        }
    }
    # [ doc = "35 - SPI1 global interrupt" ]
    pub struct Spi1Irq {
        _0: (),
    }
    unsafe impl Context for Spi1Irq {}
    unsafe impl Nr for Spi1Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            35
        }
    }
    # [ doc = "36 - SPI2 global interrupt" ]
    pub struct Spi2Irq {
        _0: (),
    }
    unsafe impl Context for Spi2Irq {}
    unsafe impl Nr for Spi2Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            36
        }
    }
    # [ doc = "37 - USART1 global interrupt" ]
    pub struct Usart1Irq {
        _0: (),
    }
    unsafe impl Context for Usart1Irq {}
    unsafe impl Nr for Usart1Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            37
        }
    }
    # [ doc = "38 - USART2 global interrupt" ]
    pub struct Usart2Irq {
        _0: (),
    }
    unsafe impl Context for Usart2Irq {}
    unsafe impl Nr for Usart2Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            38
        }
    }
    # [ doc = "39 - USART3 global interrupt" ]
    pub struct Usart3Irq {
        _0: (),
    }
    unsafe impl Context for Usart3Irq {}
    unsafe impl Nr for Usart3Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            39
        }
    }
    # [ doc = "40 - EXTI Line[15:10] interrupts" ]
    pub struct Exti1510Irq {
        _0: (),
    }
    unsafe impl Context for Exti1510Irq {}
    unsafe impl Nr for Exti1510Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            40
        }
    }
    # [ doc = "41 - RTC Alarms through EXTI line interrupt" ]
    pub struct RtcalarmIrq {
        _0: (),
    }
    unsafe impl Context for RtcalarmIrq {}
    unsafe impl Nr for RtcalarmIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            41
        }
    }
    # [ doc = "42 - CEC global interrupt" ]
    pub struct CecIrq {
        _0: (),
    }
    unsafe impl Context for CecIrq {}
    unsafe impl Nr for CecIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            42
        }
    }
    # [ doc = "43 - TIM12 global interrupt" ]
    pub struct Tim12Irq {
        _0: (),
    }
    unsafe impl Context for Tim12Irq {}
    unsafe impl Nr for Tim12Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            43
        }
    }
    # [ doc = "44 - TIM13 global interrupt" ]
    pub struct Tim13Irq {
        _0: (),
    }
    unsafe impl Context for Tim13Irq {}
    unsafe impl Nr for Tim13Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            44
        }
    }
    # [ doc = "48 - FSMC global interrupt" ]
    pub struct FsmcIrq {
        _0: (),
    }
    unsafe impl Context for FsmcIrq {}
    unsafe impl Nr for FsmcIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            48
        }
    }
    # [ doc = "50 - TIM5 global interrupt" ]
    pub struct Tim5Irq {
        _0: (),
    }
    unsafe impl Context for Tim5Irq {}
    unsafe impl Nr for Tim5Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            50
        }
    }
    # [ doc = "51 - SPI3 global interrupt" ]
    pub struct Spi3Irq {
        _0: (),
    }
    unsafe impl Context for Spi3Irq {}
    unsafe impl Nr for Spi3Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            51
        }
    }
    # [ doc = "52 - UART4 global interrupt" ]
    pub struct Uart4Irq {
        _0: (),
    }
    unsafe impl Context for Uart4Irq {}
    unsafe impl Nr for Uart4Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            52
        }
    }
    # [ doc = "53 - UART5 global interrupt" ]
    pub struct Uart5Irq {
        _0: (),
    }
    unsafe impl Context for Uart5Irq {}
    unsafe impl Nr for Uart5Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            53
        }
    }
    # [ doc = "54 - TIM6 global and DAC underrun interrupts" ]
    pub struct Tim6DacIrq {
        _0: (),
    }
    unsafe impl Context for Tim6DacIrq {}
    unsafe impl Nr for Tim6DacIrq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            54
        }
    }
    # [ doc = "55 - TIM7 global interrupt" ]
    pub struct Tim7Irq {
        _0: (),
    }
    unsafe impl Context for Tim7Irq {}
    unsafe impl Nr for Tim7Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            55
        }
    }
    # [ doc = "56 - DMA2 Channel1 global interrupt" ]
    pub struct Dma2Channel1Irq {
        _0: (),
    }
    unsafe impl Context for Dma2Channel1Irq {}
    unsafe impl Nr for Dma2Channel1Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            56
        }
    }
    # [ doc = "57 - DMA2 Channel2 global interrupt" ]
    pub struct Dma2Channel2Irq {
        _0: (),
    }
    unsafe impl Context for Dma2Channel2Irq {}
    unsafe impl Nr for Dma2Channel2Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            57
        }
    }
    # [ doc = "58 - DMA2 Channel3 global interrupt" ]
    pub struct Dma2Channel3Irq {
        _0: (),
    }
    unsafe impl Context for Dma2Channel3Irq {}
    unsafe impl Nr for Dma2Channel3Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            58
        }
    }
    # [ doc = "59 - DMA2 Channel4 and DMA2 Channel5 global interrupt" ]
    pub struct Dma2Channel45Irq {
        _0: (),
    }
    unsafe impl Context for Dma2Channel45Irq {}
    unsafe impl Nr for Dma2Channel45Irq {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            59
        }
    }
    use cortex_m::Reserved;
    # [ doc = r" Interrupt handlers" ]
    # [ allow ( non_snake_case ) ]
    # [ repr ( C ) ]
    pub struct Handlers {
        # [ doc = "0 - Window Watchdog interrupt" ]
        pub WwdgIrq: extern "C" fn(WwdgIrq),
        # [ doc = "1 - PVD through EXTI line detection interrupt" ]
        pub PvdIrq: extern "C" fn(PvdIrq),
        # [ doc = "2 - Tamper and TimeStamp through EXTI line interrupts" ]
        pub TamperStampIrq: extern "C" fn(TamperStampIrq),
        # [ doc = "3 - RTC Wakeup through EXTI line interrupt" ]
        pub RtcWkupIrq: extern "C" fn(RtcWkupIrq),
        # [ doc = "4 - Flash global interrupt" ]
        pub FlashIrq: extern "C" fn(FlashIrq),
        # [ doc = "5 - RCC global interrupt" ]
        pub RccIrq: extern "C" fn(RccIrq),
        # [ doc = "6 - EXTI Line0 interrupt" ]
        pub Exti0Irq: extern "C" fn(Exti0Irq),
        # [ doc = "7 - EXTI Line1 interrupt" ]
        pub Exti1Irq: extern "C" fn(Exti1Irq),
        # [ doc = "8 - EXTI Line2 interrupt" ]
        pub Exti2Irq: extern "C" fn(Exti2Irq),
        # [ doc = "9 - EXTI Line3 interrupt" ]
        pub Exti3Irq: extern "C" fn(Exti3Irq),
        # [ doc = "10 - EXTI Line4 interrupt" ]
        pub Exti4Irq: extern "C" fn(Exti4Irq),
        # [ doc = "11 - DMA1 Channel1 global interrupt" ]
        pub Dma1Channel1Irq: extern "C" fn(Dma1Channel1Irq),
        # [ doc = "12 - DMA1 Channel2 global interrupt" ]
        pub Dma1Channel2Irq: extern "C" fn(Dma1Channel2Irq),
        # [ doc = "13 - DMA1 Channel3 global interrupt" ]
        pub Dma1Channel3Irq: extern "C" fn(Dma1Channel3Irq),
        # [ doc = "14 - DMA1 Channel4 global interrupt" ]
        pub Dma1Channel4Irq: extern "C" fn(Dma1Channel4Irq),
        # [ doc = "15 - DMA1 Channel5 global interrupt" ]
        pub Dma1Channel5Irq: extern "C" fn(Dma1Channel5Irq),
        # [ doc = "16 - DMA1 Channel6 global interrupt" ]
        pub Dma1Channel6Irq: extern "C" fn(Dma1Channel6Irq),
        # [ doc = "17 - DMA1 Channel7 global interrupt" ]
        pub Dma1Channel7Irq: extern "C" fn(Dma1Channel7Irq),
        # [ doc = "18 - ADC1 global interrupt" ]
        pub AdcIrq: extern "C" fn(AdcIrq),
        # [ doc = r" Reserved spot in the vector table" ]
        pub _reserved0: [Reserved; 4],
        # [ doc = "23 - EXTI Line[9:5] interrupts" ]
        pub Exti95Irq: extern "C" fn(Exti95Irq),
        # [ doc = "24 - TIM1 Break interrupt and TIM15 global interrupt" ]
        pub Tim1BrkTim15Irq: extern "C" fn(Tim1BrkTim15Irq),
        # [ doc = "25 - TIM1 Update interrupt and TIM16 global interrupt" ]
        pub Tim1UpTim16Irq: extern "C" fn(Tim1UpTim16Irq),
        # [ doc = "26 - TIM1 Trigger and Commutation interrupts and TIM17 global interrupt" ]
        pub Tim1TrgComTim17Irq: extern "C" fn(Tim1TrgComTim17Irq),
        # [ doc = "27 - TIM1 Capture Compare interrupt" ]
        pub Tim1CcIrq: extern "C" fn(Tim1CcIrq),
        # [ doc = "28 - TIM2 global interrupt" ]
        pub Tim2Irq: extern "C" fn(Tim2Irq),
        # [ doc = "29 - TIM3 global interrupt" ]
        pub Tim3Irq: extern "C" fn(Tim3Irq),
        # [ doc = "30 - TIM4 global interrupt" ]
        pub Tim4Irq: extern "C" fn(Tim4Irq),
        # [ doc = "31 - I2C1 event interrupt" ]
        pub I2c1EvIrq: extern "C" fn(I2c1EvIrq),
        # [ doc = "32 - I2C1 error interrupt" ]
        pub I2c1ErIrq: extern "C" fn(I2c1ErIrq),
        # [ doc = "33 - I2C2 event interrupt" ]
        pub I2c2EvIrq: extern "C" fn(I2c2EvIrq),
        # [ doc = "34 - I2C2 error interrupt" ]
        pub I2c2ErIrq: extern "C" fn(I2c2ErIrq),
        # [ doc = "35 - SPI1 global interrupt" ]
        pub Spi1Irq: extern "C" fn(Spi1Irq),
        # [ doc = "36 - SPI2 global interrupt" ]
        pub Spi2Irq: extern "C" fn(Spi2Irq),
        # [ doc = "37 - USART1 global interrupt" ]
        pub Usart1Irq: extern "C" fn(Usart1Irq),
        # [ doc = "38 - USART2 global interrupt" ]
        pub Usart2Irq: extern "C" fn(Usart2Irq),
        # [ doc = "39 - USART3 global interrupt" ]
        pub Usart3Irq: extern "C" fn(Usart3Irq),
        # [ doc = "40 - EXTI Line[15:10] interrupts" ]
        pub Exti1510Irq: extern "C" fn(Exti1510Irq),
        # [ doc = "41 - RTC Alarms through EXTI line interrupt" ]
        pub RtcalarmIrq: extern "C" fn(RtcalarmIrq),
        # [ doc = "42 - CEC global interrupt" ]
        pub CecIrq: extern "C" fn(CecIrq),
        # [ doc = "43 - TIM12 global interrupt" ]
        pub Tim12Irq: extern "C" fn(Tim12Irq),
        # [ doc = "44 - TIM13 global interrupt" ]
        pub Tim13Irq: extern "C" fn(Tim13Irq),
        # [ doc = r" Reserved spot in the vector table" ]
        pub _reserved1: [Reserved; 3],
        # [ doc = "48 - FSMC global interrupt" ]
        pub FsmcIrq: extern "C" fn(FsmcIrq),
        # [ doc = r" Reserved spot in the vector table" ]
        pub _reserved2: [Reserved; 1],
        # [ doc = "50 - TIM5 global interrupt" ]
        pub Tim5Irq: extern "C" fn(Tim5Irq),
        # [ doc = "51 - SPI3 global interrupt" ]
        pub Spi3Irq: extern "C" fn(Spi3Irq),
        # [ doc = "52 - UART4 global interrupt" ]
        pub Uart4Irq: extern "C" fn(Uart4Irq),
        # [ doc = "53 - UART5 global interrupt" ]
        pub Uart5Irq: extern "C" fn(Uart5Irq),
        # [ doc = "54 - TIM6 global and DAC underrun interrupts" ]
        pub Tim6DacIrq: extern "C" fn(Tim6DacIrq),
        # [ doc = "55 - TIM7 global interrupt" ]
        pub Tim7Irq: extern "C" fn(Tim7Irq),
        # [ doc = "56 - DMA2 Channel1 global interrupt" ]
        pub Dma2Channel1Irq: extern "C" fn(Dma2Channel1Irq),
        # [ doc = "57 - DMA2 Channel2 global interrupt" ]
        pub Dma2Channel2Irq: extern "C" fn(Dma2Channel2Irq),
        # [ doc = "58 - DMA2 Channel3 global interrupt" ]
        pub Dma2Channel3Irq: extern "C" fn(Dma2Channel3Irq),
        # [ doc = "59 - DMA2 Channel4 and DMA2 Channel5 global interrupt" ]
        pub Dma2Channel45Irq: extern "C" fn(Dma2Channel45Irq),
    }
    # [ doc = r" Default interrupt handlers" ]
    pub const DEFAULT_HANDLERS: Handlers = Handlers {
        WwdgIrq: exception::default_handler,
        PvdIrq: exception::default_handler,
        TamperStampIrq: exception::default_handler,
        RtcWkupIrq: exception::default_handler,
        FlashIrq: exception::default_handler,
        RccIrq: exception::default_handler,
        Exti0Irq: exception::default_handler,
        Exti1Irq: exception::default_handler,
        Exti2Irq: exception::default_handler,
        Exti3Irq: exception::default_handler,
        Exti4Irq: exception::default_handler,
        Dma1Channel1Irq: exception::default_handler,
        Dma1Channel2Irq: exception::default_handler,
        Dma1Channel3Irq: exception::default_handler,
        Dma1Channel4Irq: exception::default_handler,
        Dma1Channel5Irq: exception::default_handler,
        Dma1Channel6Irq: exception::default_handler,
        Dma1Channel7Irq: exception::default_handler,
        AdcIrq: exception::default_handler,
        _reserved0: [Reserved::Vector; 4],
        Exti95Irq: exception::default_handler,
        Tim1BrkTim15Irq: exception::default_handler,
        Tim1UpTim16Irq: exception::default_handler,
        Tim1TrgComTim17Irq: exception::default_handler,
        Tim1CcIrq: exception::default_handler,
        Tim2Irq: exception::default_handler,
        Tim3Irq: exception::default_handler,
        Tim4Irq: exception::default_handler,
        I2c1EvIrq: exception::default_handler,
        I2c1ErIrq: exception::default_handler,
        I2c2EvIrq: exception::default_handler,
        I2c2ErIrq: exception::default_handler,
        Spi1Irq: exception::default_handler,
        Spi2Irq: exception::default_handler,
        Usart1Irq: exception::default_handler,
        Usart2Irq: exception::default_handler,
        Usart3Irq: exception::default_handler,
        Exti1510Irq: exception::default_handler,
        RtcalarmIrq: exception::default_handler,
        CecIrq: exception::default_handler,
        Tim12Irq: exception::default_handler,
        Tim13Irq: exception::default_handler,
        _reserved1: [Reserved::Vector; 3],
        FsmcIrq: exception::default_handler,
        _reserved2: [Reserved::Vector; 1],
        Tim5Irq: exception::default_handler,
        Spi3Irq: exception::default_handler,
        Uart4Irq: exception::default_handler,
        Uart5Irq: exception::default_handler,
        Tim6DacIrq: exception::default_handler,
        Tim7Irq: exception::default_handler,
        Dma2Channel1Irq: exception::default_handler,
        Dma2Channel2Irq: exception::default_handler,
        Dma2Channel3Irq: exception::default_handler,
        Dma2Channel45Irq: exception::default_handler,
    };
    # [ doc = r" Enumeration of all the interrupts" ]
    pub enum Interrupt {
        # [ doc = "0 - Window Watchdog interrupt" ]
        WwdgIrq,
        # [ doc = "1 - PVD through EXTI line detection interrupt" ]
        PvdIrq,
        # [ doc = "2 - Tamper and TimeStamp through EXTI line interrupts" ]
        TamperStampIrq,
        # [ doc = "3 - RTC Wakeup through EXTI line interrupt" ]
        RtcWkupIrq,
        # [ doc = "4 - Flash global interrupt" ]
        FlashIrq,
        # [ doc = "5 - RCC global interrupt" ]
        RccIrq,
        # [ doc = "6 - EXTI Line0 interrupt" ]
        Exti0Irq,
        # [ doc = "7 - EXTI Line1 interrupt" ]
        Exti1Irq,
        # [ doc = "8 - EXTI Line2 interrupt" ]
        Exti2Irq,
        # [ doc = "9 - EXTI Line3 interrupt" ]
        Exti3Irq,
        # [ doc = "10 - EXTI Line4 interrupt" ]
        Exti4Irq,
        # [ doc = "11 - DMA1 Channel1 global interrupt" ]
        Dma1Channel1Irq,
        # [ doc = "12 - DMA1 Channel2 global interrupt" ]
        Dma1Channel2Irq,
        # [ doc = "13 - DMA1 Channel3 global interrupt" ]
        Dma1Channel3Irq,
        # [ doc = "14 - DMA1 Channel4 global interrupt" ]
        Dma1Channel4Irq,
        # [ doc = "15 - DMA1 Channel5 global interrupt" ]
        Dma1Channel5Irq,
        # [ doc = "16 - DMA1 Channel6 global interrupt" ]
        Dma1Channel6Irq,
        # [ doc = "17 - DMA1 Channel7 global interrupt" ]
        Dma1Channel7Irq,
        # [ doc = "18 - ADC1 global interrupt" ]
        AdcIrq,
        # [ doc = "23 - EXTI Line[9:5] interrupts" ]
        Exti95Irq,
        # [ doc = "24 - TIM1 Break interrupt and TIM15 global interrupt" ]
        Tim1BrkTim15Irq,
        # [ doc = "25 - TIM1 Update interrupt and TIM16 global interrupt" ]
        Tim1UpTim16Irq,
        # [ doc = "26 - TIM1 Trigger and Commutation interrupts and TIM17 global interrupt" ]
        Tim1TrgComTim17Irq,
        # [ doc = "27 - TIM1 Capture Compare interrupt" ]
        Tim1CcIrq,
        # [ doc = "28 - TIM2 global interrupt" ]
        Tim2Irq,
        # [ doc = "29 - TIM3 global interrupt" ]
        Tim3Irq,
        # [ doc = "30 - TIM4 global interrupt" ]
        Tim4Irq,
        # [ doc = "31 - I2C1 event interrupt" ]
        I2c1EvIrq,
        # [ doc = "32 - I2C1 error interrupt" ]
        I2c1ErIrq,
        # [ doc = "33 - I2C2 event interrupt" ]
        I2c2EvIrq,
        # [ doc = "34 - I2C2 error interrupt" ]
        I2c2ErIrq,
        # [ doc = "35 - SPI1 global interrupt" ]
        Spi1Irq,
        # [ doc = "36 - SPI2 global interrupt" ]
        Spi2Irq,
        # [ doc = "37 - USART1 global interrupt" ]
        Usart1Irq,
        # [ doc = "38 - USART2 global interrupt" ]
        Usart2Irq,
        # [ doc = "39 - USART3 global interrupt" ]
        Usart3Irq,
        # [ doc = "40 - EXTI Line[15:10] interrupts" ]
        Exti1510Irq,
        # [ doc = "41 - RTC Alarms through EXTI line interrupt" ]
        RtcalarmIrq,
        # [ doc = "42 - CEC global interrupt" ]
        CecIrq,
        # [ doc = "43 - TIM12 global interrupt" ]
        Tim12Irq,
        # [ doc = "44 - TIM13 global interrupt" ]
        Tim13Irq,
        # [ doc = "48 - FSMC global interrupt" ]
        FsmcIrq,
        # [ doc = "50 - TIM5 global interrupt" ]
        Tim5Irq,
        # [ doc = "51 - SPI3 global interrupt" ]
        Spi3Irq,
        # [ doc = "52 - UART4 global interrupt" ]
        Uart4Irq,
        # [ doc = "53 - UART5 global interrupt" ]
        Uart5Irq,
        # [ doc = "54 - TIM6 global and DAC underrun interrupts" ]
        Tim6DacIrq,
        # [ doc = "55 - TIM7 global interrupt" ]
        Tim7Irq,
        # [ doc = "56 - DMA2 Channel1 global interrupt" ]
        Dma2Channel1Irq,
        # [ doc = "57 - DMA2 Channel2 global interrupt" ]
        Dma2Channel2Irq,
        # [ doc = "58 - DMA2 Channel3 global interrupt" ]
        Dma2Channel3Irq,
        # [ doc = "59 - DMA2 Channel4 and DMA2 Channel5 global interrupt" ]
        Dma2Channel45Irq,
    }
    unsafe impl Nr for Interrupt {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            match *self {
                Interrupt::WwdgIrq => 0,
                Interrupt::PvdIrq => 1,
                Interrupt::TamperStampIrq => 2,
                Interrupt::RtcWkupIrq => 3,
                Interrupt::FlashIrq => 4,
                Interrupt::RccIrq => 5,
                Interrupt::Exti0Irq => 6,
                Interrupt::Exti1Irq => 7,
                Interrupt::Exti2Irq => 8,
                Interrupt::Exti3Irq => 9,
                Interrupt::Exti4Irq => 10,
                Interrupt::Dma1Channel1Irq => 11,
                Interrupt::Dma1Channel2Irq => 12,
                Interrupt::Dma1Channel3Irq => 13,
                Interrupt::Dma1Channel4Irq => 14,
                Interrupt::Dma1Channel5Irq => 15,
                Interrupt::Dma1Channel6Irq => 16,
                Interrupt::Dma1Channel7Irq => 17,
                Interrupt::AdcIrq => 18,
                Interrupt::Exti95Irq => 23,
                Interrupt::Tim1BrkTim15Irq => 24,
                Interrupt::Tim1UpTim16Irq => 25,
                Interrupt::Tim1TrgComTim17Irq => 26,
                Interrupt::Tim1CcIrq => 27,
                Interrupt::Tim2Irq => 28,
                Interrupt::Tim3Irq => 29,
                Interrupt::Tim4Irq => 30,
                Interrupt::I2c1EvIrq => 31,
                Interrupt::I2c1ErIrq => 32,
                Interrupt::I2c2EvIrq => 33,
                Interrupt::I2c2ErIrq => 34,
                Interrupt::Spi1Irq => 35,
                Interrupt::Spi2Irq => 36,
                Interrupt::Usart1Irq => 37,
                Interrupt::Usart2Irq => 38,
                Interrupt::Usart3Irq => 39,
                Interrupt::Exti1510Irq => 40,
                Interrupt::RtcalarmIrq => 41,
                Interrupt::CecIrq => 42,
                Interrupt::Tim12Irq => 43,
                Interrupt::Tim13Irq => 44,
                Interrupt::FsmcIrq => 48,
                Interrupt::Tim5Irq => 50,
                Interrupt::Spi3Irq => 51,
                Interrupt::Uart4Irq => 52,
                Interrupt::Uart5Irq => 53,
                Interrupt::Tim6DacIrq => 54,
                Interrupt::Tim7Irq => 55,
                Interrupt::Dma2Channel1Irq => 56,
                Interrupt::Dma2Channel2Irq => 57,
                Interrupt::Dma2Channel3Irq => 58,
                Interrupt::Dma2Channel45Irq => 59,
            }
        }
    }
}
pub use cortex_m::peripheral::Cpuid;
pub use cortex_m::peripheral::CPUID;
pub use cortex_m::peripheral::Dcb;
pub use cortex_m::peripheral::DCB;
pub use cortex_m::peripheral::Dwt;
pub use cortex_m::peripheral::DWT;
pub use cortex_m::peripheral::Fpb;
pub use cortex_m::peripheral::FPB;
pub use cortex_m::peripheral::Fpu;
pub use cortex_m::peripheral::FPU;
pub use cortex_m::peripheral::Itm;
pub use cortex_m::peripheral::ITM;
pub use cortex_m::peripheral::Mpu;
pub use cortex_m::peripheral::MPU;
pub use cortex_m::peripheral::Nvic;
pub use cortex_m::peripheral::NVIC;
pub use cortex_m::peripheral::Scb;
pub use cortex_m::peripheral::SCB;
pub use cortex_m::peripheral::Syst;
pub use cortex_m::peripheral::SYST;
pub use cortex_m::peripheral::Tpiu;
pub use cortex_m::peripheral::TPIU;
# [ doc = "Flexible static memory controller" ]
pub const FSMC: Peripheral<Fsmc> = unsafe { Peripheral::new(2684354560) };
# [ doc = "Flexible static memory controller" ]
pub mod fsmc {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - SRAM/NOR-Flash chip-select control register 1" ]
        pub bcr1: Bcr1,
        # [ doc = "0x04 - SRAM/NOR-Flash chip-select timing register 1" ]
        pub btr1: Btr1,
        # [ doc = "0x08 - SRAM/NOR-Flash chip-select control register 2" ]
        pub bcr2: Bcr2,
        # [ doc = "0x0c - SRAM/NOR-Flash chip-select timing register 2" ]
        pub btr2: Btr2,
        # [ doc = "0x10 - SRAM/NOR-Flash chip-select control register 3" ]
        pub bcr3: Bcr3,
        # [ doc = "0x14 - SRAM/NOR-Flash chip-select timing register 3" ]
        pub btr3: Btr3,
        # [ doc = "0x18 - SRAM/NOR-Flash chip-select control register 4" ]
        pub bcr4: Bcr4,
        # [ doc = "0x1c - SRAM/NOR-Flash chip-select timing register 4" ]
        pub btr4: Btr4,
        _reserved0: [u8; 228usize],
        # [ doc = "0x104 - SRAM/NOR-Flash write timing registers 1" ]
        pub bwtr1: Bwtr1,
        _reserved1: [u8; 4usize],
        # [ doc = "0x10c - SRAM/NOR-Flash write timing registers 2" ]
        pub bwtr2: Bwtr2,
        _reserved2: [u8; 4usize],
        # [ doc = "0x114 - SRAM/NOR-Flash write timing registers 3" ]
        pub bwtr3: Bwtr3,
        _reserved3: [u8; 4usize],
        # [ doc = "0x11c - SRAM/NOR-Flash write timing registers 4" ]
        pub bwtr4: Bwtr4,
    }
    # [ doc = "SRAM/NOR-Flash chip-select control register 1" ]
    pub struct Bcr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "SRAM/NOR-Flash chip-select control register 1" ]
    pub mod bcr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bcr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CburstrwR {
            bits: u8,
        }
        impl CburstrwR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AsyncwaitR {
            bits: u8,
        }
        impl AsyncwaitR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ExtmodR {
            bits: u8,
        }
        impl ExtmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitenR {
            bits: u8,
        }
        impl WaitenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WrenR {
            bits: u8,
        }
        impl WrenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitcfgR {
            bits: u8,
        }
        impl WaitcfgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitpolR {
            bits: u8,
        }
        impl WaitpolR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BurstenR {
            bits: u8,
        }
        impl BurstenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FaccenR {
            bits: u8,
        }
        impl FaccenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MwidR {
            bits: u8,
        }
        impl MwidR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MtypR {
            bits: u8,
        }
        impl MtypR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MuxenR {
            bits: u8,
        }
        impl MuxenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MbkenR {
            bits: u8,
        }
        impl MbkenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CburstrwW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CburstrwW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AsyncwaitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AsyncwaitW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ExtmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ExtmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WrenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WrenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitcfgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitcfgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitpolW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BurstenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BurstenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FaccenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FaccenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MwidW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MwidW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MtypW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MtypW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MuxenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MuxenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MbkenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MbkenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 19 - CBURSTRW" ]
            # [ inline ( always ) ]
            pub fn cburstrw(&self) -> CburstrwR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CburstrwR { bits }
            }
            # [ doc = "Bit 15 - ASYNCWAIT" ]
            # [ inline ( always ) ]
            pub fn asyncwait(&self) -> AsyncwaitR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AsyncwaitR { bits }
            }
            # [ doc = "Bit 14 - EXTMOD" ]
            # [ inline ( always ) ]
            pub fn extmod(&self) -> ExtmodR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ExtmodR { bits }
            }
            # [ doc = "Bit 13 - WAITEN" ]
            # [ inline ( always ) ]
            pub fn waiten(&self) -> WaitenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WaitenR { bits }
            }
            # [ doc = "Bit 12 - WREN" ]
            # [ inline ( always ) ]
            pub fn wren(&self) -> WrenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WrenR { bits }
            }
            # [ doc = "Bit 11 - WAITCFG" ]
            # [ inline ( always ) ]
            pub fn waitcfg(&self) -> WaitcfgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WaitcfgR { bits }
            }
            # [ doc = "Bit 9 - WAITPOL" ]
            # [ inline ( always ) ]
            pub fn waitpol(&self) -> WaitpolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WaitpolR { bits }
            }
            # [ doc = "Bit 8 - BURSTEN" ]
            # [ inline ( always ) ]
            pub fn bursten(&self) -> BurstenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BurstenR { bits }
            }
            # [ doc = "Bit 6 - FACCEN" ]
            # [ inline ( always ) ]
            pub fn faccen(&self) -> FaccenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FaccenR { bits }
            }
            # [ doc = "Bits 4:5 - MWID" ]
            # [ inline ( always ) ]
            pub fn mwid(&self) -> MwidR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MwidR { bits }
            }
            # [ doc = "Bits 2:3 - MTYP" ]
            # [ inline ( always ) ]
            pub fn mtyp(&self) -> MtypR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MtypR { bits }
            }
            # [ doc = "Bit 1 - MUXEN" ]
            # [ inline ( always ) ]
            pub fn muxen(&self) -> MuxenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MuxenR { bits }
            }
            # [ doc = "Bit 0 - MBKEN" ]
            # [ inline ( always ) ]
            pub fn mbken(&self) -> MbkenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MbkenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 12496 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 19 - CBURSTRW" ]
            # [ inline ( always ) ]
            pub fn cburstrw(&mut self) -> _CburstrwW {
                _CburstrwW { w: self }
            }
            # [ doc = "Bit 15 - ASYNCWAIT" ]
            # [ inline ( always ) ]
            pub fn asyncwait(&mut self) -> _AsyncwaitW {
                _AsyncwaitW { w: self }
            }
            # [ doc = "Bit 14 - EXTMOD" ]
            # [ inline ( always ) ]
            pub fn extmod(&mut self) -> _ExtmodW {
                _ExtmodW { w: self }
            }
            # [ doc = "Bit 13 - WAITEN" ]
            # [ inline ( always ) ]
            pub fn waiten(&mut self) -> _WaitenW {
                _WaitenW { w: self }
            }
            # [ doc = "Bit 12 - WREN" ]
            # [ inline ( always ) ]
            pub fn wren(&mut self) -> _WrenW {
                _WrenW { w: self }
            }
            # [ doc = "Bit 11 - WAITCFG" ]
            # [ inline ( always ) ]
            pub fn waitcfg(&mut self) -> _WaitcfgW {
                _WaitcfgW { w: self }
            }
            # [ doc = "Bit 9 - WAITPOL" ]
            # [ inline ( always ) ]
            pub fn waitpol(&mut self) -> _WaitpolW {
                _WaitpolW { w: self }
            }
            # [ doc = "Bit 8 - BURSTEN" ]
            # [ inline ( always ) ]
            pub fn bursten(&mut self) -> _BurstenW {
                _BurstenW { w: self }
            }
            # [ doc = "Bit 6 - FACCEN" ]
            # [ inline ( always ) ]
            pub fn faccen(&mut self) -> _FaccenW {
                _FaccenW { w: self }
            }
            # [ doc = "Bits 4:5 - MWID" ]
            # [ inline ( always ) ]
            pub fn mwid(&mut self) -> _MwidW {
                _MwidW { w: self }
            }
            # [ doc = "Bits 2:3 - MTYP" ]
            # [ inline ( always ) ]
            pub fn mtyp(&mut self) -> _MtypW {
                _MtypW { w: self }
            }
            # [ doc = "Bit 1 - MUXEN" ]
            # [ inline ( always ) ]
            pub fn muxen(&mut self) -> _MuxenW {
                _MuxenW { w: self }
            }
            # [ doc = "Bit 0 - MBKEN" ]
            # [ inline ( always ) ]
            pub fn mbken(&mut self) -> _MbkenW {
                _MbkenW { w: self }
            }
        }
    }
    # [ doc = "SRAM/NOR-Flash chip-select timing register 1" ]
    pub struct Btr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "SRAM/NOR-Flash chip-select timing register 1" ]
    pub mod btr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Btr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AccmodR {
            bits: u8,
        }
        impl AccmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatlatR {
            bits: u8,
        }
        impl DatlatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ClkdivR {
            bits: u8,
        }
        impl ClkdivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BusturnR {
            bits: u8,
        }
        impl BusturnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatastR {
            bits: u8,
        }
        impl DatastR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddhldR {
            bits: u8,
        }
        impl AddhldR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddsetR {
            bits: u8,
        }
        impl AddsetR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AccmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AccmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatlatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatlatW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ClkdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ClkdivW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BusturnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BusturnW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatastW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatastW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddhldW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddhldW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddsetW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddsetW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&self) -> AccmodR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AccmodR { bits }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&self) -> DatlatR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatlatR { bits }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&self) -> ClkdivR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ClkdivR { bits }
            }
            # [ doc = "Bits 16:19 - BUSTURN" ]
            # [ inline ( always ) ]
            pub fn busturn(&self) -> BusturnR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BusturnR { bits }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&self) -> DatastR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatastR { bits }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&self) -> AddhldR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddhldR { bits }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&self) -> AddsetR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddsetR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&mut self) -> _AccmodW {
                _AccmodW { w: self }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&mut self) -> _DatlatW {
                _DatlatW { w: self }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&mut self) -> _ClkdivW {
                _ClkdivW { w: self }
            }
            # [ doc = "Bits 16:19 - BUSTURN" ]
            # [ inline ( always ) ]
            pub fn busturn(&mut self) -> _BusturnW {
                _BusturnW { w: self }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&mut self) -> _DatastW {
                _DatastW { w: self }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&mut self) -> _AddhldW {
                _AddhldW { w: self }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&mut self) -> _AddsetW {
                _AddsetW { w: self }
            }
        }
    }
    # [ doc = "SRAM/NOR-Flash chip-select control register 2" ]
    pub struct Bcr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "SRAM/NOR-Flash chip-select control register 2" ]
    pub mod bcr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bcr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CburstrwR {
            bits: u8,
        }
        impl CburstrwR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AsyncwaitR {
            bits: u8,
        }
        impl AsyncwaitR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ExtmodR {
            bits: u8,
        }
        impl ExtmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitenR {
            bits: u8,
        }
        impl WaitenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WrenR {
            bits: u8,
        }
        impl WrenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitcfgR {
            bits: u8,
        }
        impl WaitcfgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WrapmodR {
            bits: u8,
        }
        impl WrapmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitpolR {
            bits: u8,
        }
        impl WaitpolR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BurstenR {
            bits: u8,
        }
        impl BurstenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FaccenR {
            bits: u8,
        }
        impl FaccenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MwidR {
            bits: u8,
        }
        impl MwidR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MtypR {
            bits: u8,
        }
        impl MtypR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MuxenR {
            bits: u8,
        }
        impl MuxenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MbkenR {
            bits: u8,
        }
        impl MbkenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CburstrwW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CburstrwW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AsyncwaitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AsyncwaitW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ExtmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ExtmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WrenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WrenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitcfgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitcfgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WrapmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WrapmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitpolW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BurstenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BurstenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FaccenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FaccenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MwidW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MwidW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MtypW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MtypW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MuxenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MuxenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MbkenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MbkenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 19 - CBURSTRW" ]
            # [ inline ( always ) ]
            pub fn cburstrw(&self) -> CburstrwR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CburstrwR { bits }
            }
            # [ doc = "Bit 15 - ASYNCWAIT" ]
            # [ inline ( always ) ]
            pub fn asyncwait(&self) -> AsyncwaitR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AsyncwaitR { bits }
            }
            # [ doc = "Bit 14 - EXTMOD" ]
            # [ inline ( always ) ]
            pub fn extmod(&self) -> ExtmodR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ExtmodR { bits }
            }
            # [ doc = "Bit 13 - WAITEN" ]
            # [ inline ( always ) ]
            pub fn waiten(&self) -> WaitenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WaitenR { bits }
            }
            # [ doc = "Bit 12 - WREN" ]
            # [ inline ( always ) ]
            pub fn wren(&self) -> WrenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WrenR { bits }
            }
            # [ doc = "Bit 11 - WAITCFG" ]
            # [ inline ( always ) ]
            pub fn waitcfg(&self) -> WaitcfgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WaitcfgR { bits }
            }
            # [ doc = "Bit 10 - WRAPMOD" ]
            # [ inline ( always ) ]
            pub fn wrapmod(&self) -> WrapmodR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WrapmodR { bits }
            }
            # [ doc = "Bit 9 - WAITPOL" ]
            # [ inline ( always ) ]
            pub fn waitpol(&self) -> WaitpolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WaitpolR { bits }
            }
            # [ doc = "Bit 8 - BURSTEN" ]
            # [ inline ( always ) ]
            pub fn bursten(&self) -> BurstenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BurstenR { bits }
            }
            # [ doc = "Bit 6 - FACCEN" ]
            # [ inline ( always ) ]
            pub fn faccen(&self) -> FaccenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FaccenR { bits }
            }
            # [ doc = "Bits 4:5 - MWID" ]
            # [ inline ( always ) ]
            pub fn mwid(&self) -> MwidR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MwidR { bits }
            }
            # [ doc = "Bits 2:3 - MTYP" ]
            # [ inline ( always ) ]
            pub fn mtyp(&self) -> MtypR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MtypR { bits }
            }
            # [ doc = "Bit 1 - MUXEN" ]
            # [ inline ( always ) ]
            pub fn muxen(&self) -> MuxenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MuxenR { bits }
            }
            # [ doc = "Bit 0 - MBKEN" ]
            # [ inline ( always ) ]
            pub fn mbken(&self) -> MbkenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MbkenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 12496 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 19 - CBURSTRW" ]
            # [ inline ( always ) ]
            pub fn cburstrw(&mut self) -> _CburstrwW {
                _CburstrwW { w: self }
            }
            # [ doc = "Bit 15 - ASYNCWAIT" ]
            # [ inline ( always ) ]
            pub fn asyncwait(&mut self) -> _AsyncwaitW {
                _AsyncwaitW { w: self }
            }
            # [ doc = "Bit 14 - EXTMOD" ]
            # [ inline ( always ) ]
            pub fn extmod(&mut self) -> _ExtmodW {
                _ExtmodW { w: self }
            }
            # [ doc = "Bit 13 - WAITEN" ]
            # [ inline ( always ) ]
            pub fn waiten(&mut self) -> _WaitenW {
                _WaitenW { w: self }
            }
            # [ doc = "Bit 12 - WREN" ]
            # [ inline ( always ) ]
            pub fn wren(&mut self) -> _WrenW {
                _WrenW { w: self }
            }
            # [ doc = "Bit 11 - WAITCFG" ]
            # [ inline ( always ) ]
            pub fn waitcfg(&mut self) -> _WaitcfgW {
                _WaitcfgW { w: self }
            }
            # [ doc = "Bit 10 - WRAPMOD" ]
            # [ inline ( always ) ]
            pub fn wrapmod(&mut self) -> _WrapmodW {
                _WrapmodW { w: self }
            }
            # [ doc = "Bit 9 - WAITPOL" ]
            # [ inline ( always ) ]
            pub fn waitpol(&mut self) -> _WaitpolW {
                _WaitpolW { w: self }
            }
            # [ doc = "Bit 8 - BURSTEN" ]
            # [ inline ( always ) ]
            pub fn bursten(&mut self) -> _BurstenW {
                _BurstenW { w: self }
            }
            # [ doc = "Bit 6 - FACCEN" ]
            # [ inline ( always ) ]
            pub fn faccen(&mut self) -> _FaccenW {
                _FaccenW { w: self }
            }
            # [ doc = "Bits 4:5 - MWID" ]
            # [ inline ( always ) ]
            pub fn mwid(&mut self) -> _MwidW {
                _MwidW { w: self }
            }
            # [ doc = "Bits 2:3 - MTYP" ]
            # [ inline ( always ) ]
            pub fn mtyp(&mut self) -> _MtypW {
                _MtypW { w: self }
            }
            # [ doc = "Bit 1 - MUXEN" ]
            # [ inline ( always ) ]
            pub fn muxen(&mut self) -> _MuxenW {
                _MuxenW { w: self }
            }
            # [ doc = "Bit 0 - MBKEN" ]
            # [ inline ( always ) ]
            pub fn mbken(&mut self) -> _MbkenW {
                _MbkenW { w: self }
            }
        }
    }
    # [ doc = "SRAM/NOR-Flash chip-select timing register 2" ]
    pub struct Btr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "SRAM/NOR-Flash chip-select timing register 2" ]
    pub mod btr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Btr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AccmodR {
            bits: u8,
        }
        impl AccmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatlatR {
            bits: u8,
        }
        impl DatlatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ClkdivR {
            bits: u8,
        }
        impl ClkdivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BusturnR {
            bits: u8,
        }
        impl BusturnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatastR {
            bits: u8,
        }
        impl DatastR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddhldR {
            bits: u8,
        }
        impl AddhldR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddsetR {
            bits: u8,
        }
        impl AddsetR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AccmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AccmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatlatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatlatW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ClkdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ClkdivW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BusturnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BusturnW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatastW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatastW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddhldW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddhldW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddsetW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddsetW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&self) -> AccmodR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AccmodR { bits }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&self) -> DatlatR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatlatR { bits }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&self) -> ClkdivR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ClkdivR { bits }
            }
            # [ doc = "Bits 16:19 - BUSTURN" ]
            # [ inline ( always ) ]
            pub fn busturn(&self) -> BusturnR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BusturnR { bits }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&self) -> DatastR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatastR { bits }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&self) -> AddhldR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddhldR { bits }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&self) -> AddsetR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddsetR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&mut self) -> _AccmodW {
                _AccmodW { w: self }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&mut self) -> _DatlatW {
                _DatlatW { w: self }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&mut self) -> _ClkdivW {
                _ClkdivW { w: self }
            }
            # [ doc = "Bits 16:19 - BUSTURN" ]
            # [ inline ( always ) ]
            pub fn busturn(&mut self) -> _BusturnW {
                _BusturnW { w: self }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&mut self) -> _DatastW {
                _DatastW { w: self }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&mut self) -> _AddhldW {
                _AddhldW { w: self }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&mut self) -> _AddsetW {
                _AddsetW { w: self }
            }
        }
    }
    # [ doc = "SRAM/NOR-Flash chip-select control register 3" ]
    pub struct Bcr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "SRAM/NOR-Flash chip-select control register 3" ]
    pub mod bcr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bcr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CburstrwR {
            bits: u8,
        }
        impl CburstrwR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AsyncwaitR {
            bits: u8,
        }
        impl AsyncwaitR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ExtmodR {
            bits: u8,
        }
        impl ExtmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitenR {
            bits: u8,
        }
        impl WaitenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WrenR {
            bits: u8,
        }
        impl WrenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitcfgR {
            bits: u8,
        }
        impl WaitcfgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WrapmodR {
            bits: u8,
        }
        impl WrapmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitpolR {
            bits: u8,
        }
        impl WaitpolR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BurstenR {
            bits: u8,
        }
        impl BurstenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FaccenR {
            bits: u8,
        }
        impl FaccenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MwidR {
            bits: u8,
        }
        impl MwidR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MtypR {
            bits: u8,
        }
        impl MtypR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MuxenR {
            bits: u8,
        }
        impl MuxenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MbkenR {
            bits: u8,
        }
        impl MbkenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CburstrwW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CburstrwW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AsyncwaitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AsyncwaitW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ExtmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ExtmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WrenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WrenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitcfgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitcfgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WrapmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WrapmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitpolW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BurstenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BurstenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FaccenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FaccenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MwidW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MwidW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MtypW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MtypW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MuxenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MuxenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MbkenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MbkenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 19 - CBURSTRW" ]
            # [ inline ( always ) ]
            pub fn cburstrw(&self) -> CburstrwR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CburstrwR { bits }
            }
            # [ doc = "Bit 15 - ASYNCWAIT" ]
            # [ inline ( always ) ]
            pub fn asyncwait(&self) -> AsyncwaitR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AsyncwaitR { bits }
            }
            # [ doc = "Bit 14 - EXTMOD" ]
            # [ inline ( always ) ]
            pub fn extmod(&self) -> ExtmodR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ExtmodR { bits }
            }
            # [ doc = "Bit 13 - WAITEN" ]
            # [ inline ( always ) ]
            pub fn waiten(&self) -> WaitenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WaitenR { bits }
            }
            # [ doc = "Bit 12 - WREN" ]
            # [ inline ( always ) ]
            pub fn wren(&self) -> WrenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WrenR { bits }
            }
            # [ doc = "Bit 11 - WAITCFG" ]
            # [ inline ( always ) ]
            pub fn waitcfg(&self) -> WaitcfgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WaitcfgR { bits }
            }
            # [ doc = "Bit 10 - WRAPMOD" ]
            # [ inline ( always ) ]
            pub fn wrapmod(&self) -> WrapmodR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WrapmodR { bits }
            }
            # [ doc = "Bit 9 - WAITPOL" ]
            # [ inline ( always ) ]
            pub fn waitpol(&self) -> WaitpolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WaitpolR { bits }
            }
            # [ doc = "Bit 8 - BURSTEN" ]
            # [ inline ( always ) ]
            pub fn bursten(&self) -> BurstenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BurstenR { bits }
            }
            # [ doc = "Bit 6 - FACCEN" ]
            # [ inline ( always ) ]
            pub fn faccen(&self) -> FaccenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FaccenR { bits }
            }
            # [ doc = "Bits 4:5 - MWID" ]
            # [ inline ( always ) ]
            pub fn mwid(&self) -> MwidR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MwidR { bits }
            }
            # [ doc = "Bits 2:3 - MTYP" ]
            # [ inline ( always ) ]
            pub fn mtyp(&self) -> MtypR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MtypR { bits }
            }
            # [ doc = "Bit 1 - MUXEN" ]
            # [ inline ( always ) ]
            pub fn muxen(&self) -> MuxenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MuxenR { bits }
            }
            # [ doc = "Bit 0 - MBKEN" ]
            # [ inline ( always ) ]
            pub fn mbken(&self) -> MbkenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MbkenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 12496 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 19 - CBURSTRW" ]
            # [ inline ( always ) ]
            pub fn cburstrw(&mut self) -> _CburstrwW {
                _CburstrwW { w: self }
            }
            # [ doc = "Bit 15 - ASYNCWAIT" ]
            # [ inline ( always ) ]
            pub fn asyncwait(&mut self) -> _AsyncwaitW {
                _AsyncwaitW { w: self }
            }
            # [ doc = "Bit 14 - EXTMOD" ]
            # [ inline ( always ) ]
            pub fn extmod(&mut self) -> _ExtmodW {
                _ExtmodW { w: self }
            }
            # [ doc = "Bit 13 - WAITEN" ]
            # [ inline ( always ) ]
            pub fn waiten(&mut self) -> _WaitenW {
                _WaitenW { w: self }
            }
            # [ doc = "Bit 12 - WREN" ]
            # [ inline ( always ) ]
            pub fn wren(&mut self) -> _WrenW {
                _WrenW { w: self }
            }
            # [ doc = "Bit 11 - WAITCFG" ]
            # [ inline ( always ) ]
            pub fn waitcfg(&mut self) -> _WaitcfgW {
                _WaitcfgW { w: self }
            }
            # [ doc = "Bit 10 - WRAPMOD" ]
            # [ inline ( always ) ]
            pub fn wrapmod(&mut self) -> _WrapmodW {
                _WrapmodW { w: self }
            }
            # [ doc = "Bit 9 - WAITPOL" ]
            # [ inline ( always ) ]
            pub fn waitpol(&mut self) -> _WaitpolW {
                _WaitpolW { w: self }
            }
            # [ doc = "Bit 8 - BURSTEN" ]
            # [ inline ( always ) ]
            pub fn bursten(&mut self) -> _BurstenW {
                _BurstenW { w: self }
            }
            # [ doc = "Bit 6 - FACCEN" ]
            # [ inline ( always ) ]
            pub fn faccen(&mut self) -> _FaccenW {
                _FaccenW { w: self }
            }
            # [ doc = "Bits 4:5 - MWID" ]
            # [ inline ( always ) ]
            pub fn mwid(&mut self) -> _MwidW {
                _MwidW { w: self }
            }
            # [ doc = "Bits 2:3 - MTYP" ]
            # [ inline ( always ) ]
            pub fn mtyp(&mut self) -> _MtypW {
                _MtypW { w: self }
            }
            # [ doc = "Bit 1 - MUXEN" ]
            # [ inline ( always ) ]
            pub fn muxen(&mut self) -> _MuxenW {
                _MuxenW { w: self }
            }
            # [ doc = "Bit 0 - MBKEN" ]
            # [ inline ( always ) ]
            pub fn mbken(&mut self) -> _MbkenW {
                _MbkenW { w: self }
            }
        }
    }
    # [ doc = "SRAM/NOR-Flash chip-select timing register 3" ]
    pub struct Btr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "SRAM/NOR-Flash chip-select timing register 3" ]
    pub mod btr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Btr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AccmodR {
            bits: u8,
        }
        impl AccmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatlatR {
            bits: u8,
        }
        impl DatlatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ClkdivR {
            bits: u8,
        }
        impl ClkdivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BusturnR {
            bits: u8,
        }
        impl BusturnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatastR {
            bits: u8,
        }
        impl DatastR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddhldR {
            bits: u8,
        }
        impl AddhldR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddsetR {
            bits: u8,
        }
        impl AddsetR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AccmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AccmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatlatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatlatW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ClkdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ClkdivW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BusturnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BusturnW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatastW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatastW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddhldW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddhldW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddsetW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddsetW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&self) -> AccmodR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AccmodR { bits }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&self) -> DatlatR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatlatR { bits }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&self) -> ClkdivR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ClkdivR { bits }
            }
            # [ doc = "Bits 16:19 - BUSTURN" ]
            # [ inline ( always ) ]
            pub fn busturn(&self) -> BusturnR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BusturnR { bits }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&self) -> DatastR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatastR { bits }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&self) -> AddhldR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddhldR { bits }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&self) -> AddsetR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddsetR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&mut self) -> _AccmodW {
                _AccmodW { w: self }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&mut self) -> _DatlatW {
                _DatlatW { w: self }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&mut self) -> _ClkdivW {
                _ClkdivW { w: self }
            }
            # [ doc = "Bits 16:19 - BUSTURN" ]
            # [ inline ( always ) ]
            pub fn busturn(&mut self) -> _BusturnW {
                _BusturnW { w: self }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&mut self) -> _DatastW {
                _DatastW { w: self }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&mut self) -> _AddhldW {
                _AddhldW { w: self }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&mut self) -> _AddsetW {
                _AddsetW { w: self }
            }
        }
    }
    # [ doc = "SRAM/NOR-Flash chip-select control register 4" ]
    pub struct Bcr4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "SRAM/NOR-Flash chip-select control register 4" ]
    pub mod bcr4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bcr4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CburstrwR {
            bits: u8,
        }
        impl CburstrwR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AsyncwaitR {
            bits: u8,
        }
        impl AsyncwaitR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ExtmodR {
            bits: u8,
        }
        impl ExtmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitenR {
            bits: u8,
        }
        impl WaitenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WrenR {
            bits: u8,
        }
        impl WrenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitcfgR {
            bits: u8,
        }
        impl WaitcfgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WrapmodR {
            bits: u8,
        }
        impl WrapmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitpolR {
            bits: u8,
        }
        impl WaitpolR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BurstenR {
            bits: u8,
        }
        impl BurstenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FaccenR {
            bits: u8,
        }
        impl FaccenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MwidR {
            bits: u8,
        }
        impl MwidR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MtypR {
            bits: u8,
        }
        impl MtypR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MuxenR {
            bits: u8,
        }
        impl MuxenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MbkenR {
            bits: u8,
        }
        impl MbkenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CburstrwW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CburstrwW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AsyncwaitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AsyncwaitW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ExtmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ExtmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WrenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WrenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitcfgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitcfgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WrapmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WrapmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitpolW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BurstenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BurstenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FaccenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FaccenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MwidW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MwidW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MtypW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MtypW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MuxenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MuxenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MbkenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MbkenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 19 - CBURSTRW" ]
            # [ inline ( always ) ]
            pub fn cburstrw(&self) -> CburstrwR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CburstrwR { bits }
            }
            # [ doc = "Bit 15 - ASYNCWAIT" ]
            # [ inline ( always ) ]
            pub fn asyncwait(&self) -> AsyncwaitR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AsyncwaitR { bits }
            }
            # [ doc = "Bit 14 - EXTMOD" ]
            # [ inline ( always ) ]
            pub fn extmod(&self) -> ExtmodR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ExtmodR { bits }
            }
            # [ doc = "Bit 13 - WAITEN" ]
            # [ inline ( always ) ]
            pub fn waiten(&self) -> WaitenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WaitenR { bits }
            }
            # [ doc = "Bit 12 - WREN" ]
            # [ inline ( always ) ]
            pub fn wren(&self) -> WrenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WrenR { bits }
            }
            # [ doc = "Bit 11 - WAITCFG" ]
            # [ inline ( always ) ]
            pub fn waitcfg(&self) -> WaitcfgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WaitcfgR { bits }
            }
            # [ doc = "Bit 10 - WRAPMOD" ]
            # [ inline ( always ) ]
            pub fn wrapmod(&self) -> WrapmodR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WrapmodR { bits }
            }
            # [ doc = "Bit 9 - WAITPOL" ]
            # [ inline ( always ) ]
            pub fn waitpol(&self) -> WaitpolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WaitpolR { bits }
            }
            # [ doc = "Bit 8 - BURSTEN" ]
            # [ inline ( always ) ]
            pub fn bursten(&self) -> BurstenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BurstenR { bits }
            }
            # [ doc = "Bit 6 - FACCEN" ]
            # [ inline ( always ) ]
            pub fn faccen(&self) -> FaccenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FaccenR { bits }
            }
            # [ doc = "Bits 4:5 - MWID" ]
            # [ inline ( always ) ]
            pub fn mwid(&self) -> MwidR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MwidR { bits }
            }
            # [ doc = "Bits 2:3 - MTYP" ]
            # [ inline ( always ) ]
            pub fn mtyp(&self) -> MtypR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MtypR { bits }
            }
            # [ doc = "Bit 1 - MUXEN" ]
            # [ inline ( always ) ]
            pub fn muxen(&self) -> MuxenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MuxenR { bits }
            }
            # [ doc = "Bit 0 - MBKEN" ]
            # [ inline ( always ) ]
            pub fn mbken(&self) -> MbkenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MbkenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 12496 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 19 - CBURSTRW" ]
            # [ inline ( always ) ]
            pub fn cburstrw(&mut self) -> _CburstrwW {
                _CburstrwW { w: self }
            }
            # [ doc = "Bit 15 - ASYNCWAIT" ]
            # [ inline ( always ) ]
            pub fn asyncwait(&mut self) -> _AsyncwaitW {
                _AsyncwaitW { w: self }
            }
            # [ doc = "Bit 14 - EXTMOD" ]
            # [ inline ( always ) ]
            pub fn extmod(&mut self) -> _ExtmodW {
                _ExtmodW { w: self }
            }
            # [ doc = "Bit 13 - WAITEN" ]
            # [ inline ( always ) ]
            pub fn waiten(&mut self) -> _WaitenW {
                _WaitenW { w: self }
            }
            # [ doc = "Bit 12 - WREN" ]
            # [ inline ( always ) ]
            pub fn wren(&mut self) -> _WrenW {
                _WrenW { w: self }
            }
            # [ doc = "Bit 11 - WAITCFG" ]
            # [ inline ( always ) ]
            pub fn waitcfg(&mut self) -> _WaitcfgW {
                _WaitcfgW { w: self }
            }
            # [ doc = "Bit 10 - WRAPMOD" ]
            # [ inline ( always ) ]
            pub fn wrapmod(&mut self) -> _WrapmodW {
                _WrapmodW { w: self }
            }
            # [ doc = "Bit 9 - WAITPOL" ]
            # [ inline ( always ) ]
            pub fn waitpol(&mut self) -> _WaitpolW {
                _WaitpolW { w: self }
            }
            # [ doc = "Bit 8 - BURSTEN" ]
            # [ inline ( always ) ]
            pub fn bursten(&mut self) -> _BurstenW {
                _BurstenW { w: self }
            }
            # [ doc = "Bit 6 - FACCEN" ]
            # [ inline ( always ) ]
            pub fn faccen(&mut self) -> _FaccenW {
                _FaccenW { w: self }
            }
            # [ doc = "Bits 4:5 - MWID" ]
            # [ inline ( always ) ]
            pub fn mwid(&mut self) -> _MwidW {
                _MwidW { w: self }
            }
            # [ doc = "Bits 2:3 - MTYP" ]
            # [ inline ( always ) ]
            pub fn mtyp(&mut self) -> _MtypW {
                _MtypW { w: self }
            }
            # [ doc = "Bit 1 - MUXEN" ]
            # [ inline ( always ) ]
            pub fn muxen(&mut self) -> _MuxenW {
                _MuxenW { w: self }
            }
            # [ doc = "Bit 0 - MBKEN" ]
            # [ inline ( always ) ]
            pub fn mbken(&mut self) -> _MbkenW {
                _MbkenW { w: self }
            }
        }
    }
    # [ doc = "SRAM/NOR-Flash chip-select timing register 4" ]
    pub struct Btr4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "SRAM/NOR-Flash chip-select timing register 4" ]
    pub mod btr4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Btr4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AccmodR {
            bits: u8,
        }
        impl AccmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatlatR {
            bits: u8,
        }
        impl DatlatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ClkdivR {
            bits: u8,
        }
        impl ClkdivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BusturnR {
            bits: u8,
        }
        impl BusturnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatastR {
            bits: u8,
        }
        impl DatastR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddhldR {
            bits: u8,
        }
        impl AddhldR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddsetR {
            bits: u8,
        }
        impl AddsetR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AccmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AccmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatlatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatlatW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ClkdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ClkdivW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BusturnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BusturnW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatastW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatastW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddhldW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddhldW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddsetW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddsetW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&self) -> AccmodR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AccmodR { bits }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&self) -> DatlatR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatlatR { bits }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&self) -> ClkdivR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ClkdivR { bits }
            }
            # [ doc = "Bits 16:19 - BUSTURN" ]
            # [ inline ( always ) ]
            pub fn busturn(&self) -> BusturnR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BusturnR { bits }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&self) -> DatastR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatastR { bits }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&self) -> AddhldR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddhldR { bits }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&self) -> AddsetR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddsetR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&mut self) -> _AccmodW {
                _AccmodW { w: self }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&mut self) -> _DatlatW {
                _DatlatW { w: self }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&mut self) -> _ClkdivW {
                _ClkdivW { w: self }
            }
            # [ doc = "Bits 16:19 - BUSTURN" ]
            # [ inline ( always ) ]
            pub fn busturn(&mut self) -> _BusturnW {
                _BusturnW { w: self }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&mut self) -> _DatastW {
                _DatastW { w: self }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&mut self) -> _AddhldW {
                _AddhldW { w: self }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&mut self) -> _AddsetW {
                _AddsetW { w: self }
            }
        }
    }
    # [ doc = "SRAM/NOR-Flash write timing registers 1" ]
    pub struct Bwtr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "SRAM/NOR-Flash write timing registers 1" ]
    pub mod bwtr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bwtr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AccmodR {
            bits: u8,
        }
        impl AccmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatlatR {
            bits: u8,
        }
        impl DatlatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ClkdivR {
            bits: u8,
        }
        impl ClkdivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatastR {
            bits: u8,
        }
        impl DatastR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddhldR {
            bits: u8,
        }
        impl AddhldR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddsetR {
            bits: u8,
        }
        impl AddsetR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AccmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AccmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatlatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatlatW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ClkdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ClkdivW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatastW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatastW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddhldW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddhldW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddsetW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddsetW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&self) -> AccmodR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AccmodR { bits }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&self) -> DatlatR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatlatR { bits }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&self) -> ClkdivR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ClkdivR { bits }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&self) -> DatastR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatastR { bits }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&self) -> AddhldR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddhldR { bits }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&self) -> AddsetR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddsetR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 268435455 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&mut self) -> _AccmodW {
                _AccmodW { w: self }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&mut self) -> _DatlatW {
                _DatlatW { w: self }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&mut self) -> _ClkdivW {
                _ClkdivW { w: self }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&mut self) -> _DatastW {
                _DatastW { w: self }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&mut self) -> _AddhldW {
                _AddhldW { w: self }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&mut self) -> _AddsetW {
                _AddsetW { w: self }
            }
        }
    }
    # [ doc = "SRAM/NOR-Flash write timing registers 2" ]
    pub struct Bwtr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "SRAM/NOR-Flash write timing registers 2" ]
    pub mod bwtr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bwtr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AccmodR {
            bits: u8,
        }
        impl AccmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatlatR {
            bits: u8,
        }
        impl DatlatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ClkdivR {
            bits: u8,
        }
        impl ClkdivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatastR {
            bits: u8,
        }
        impl DatastR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddhldR {
            bits: u8,
        }
        impl AddhldR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddsetR {
            bits: u8,
        }
        impl AddsetR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AccmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AccmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatlatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatlatW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ClkdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ClkdivW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatastW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatastW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddhldW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddhldW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddsetW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddsetW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&self) -> AccmodR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AccmodR { bits }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&self) -> DatlatR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatlatR { bits }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&self) -> ClkdivR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ClkdivR { bits }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&self) -> DatastR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatastR { bits }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&self) -> AddhldR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddhldR { bits }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&self) -> AddsetR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddsetR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 268435455 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&mut self) -> _AccmodW {
                _AccmodW { w: self }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&mut self) -> _DatlatW {
                _DatlatW { w: self }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&mut self) -> _ClkdivW {
                _ClkdivW { w: self }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&mut self) -> _DatastW {
                _DatastW { w: self }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&mut self) -> _AddhldW {
                _AddhldW { w: self }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&mut self) -> _AddsetW {
                _AddsetW { w: self }
            }
        }
    }
    # [ doc = "SRAM/NOR-Flash write timing registers 3" ]
    pub struct Bwtr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "SRAM/NOR-Flash write timing registers 3" ]
    pub mod bwtr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bwtr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AccmodR {
            bits: u8,
        }
        impl AccmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatlatR {
            bits: u8,
        }
        impl DatlatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ClkdivR {
            bits: u8,
        }
        impl ClkdivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatastR {
            bits: u8,
        }
        impl DatastR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddhldR {
            bits: u8,
        }
        impl AddhldR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddsetR {
            bits: u8,
        }
        impl AddsetR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AccmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AccmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatlatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatlatW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ClkdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ClkdivW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatastW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatastW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddhldW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddhldW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddsetW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddsetW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&self) -> AccmodR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AccmodR { bits }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&self) -> DatlatR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatlatR { bits }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&self) -> ClkdivR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ClkdivR { bits }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&self) -> DatastR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatastR { bits }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&self) -> AddhldR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddhldR { bits }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&self) -> AddsetR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddsetR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 268435455 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&mut self) -> _AccmodW {
                _AccmodW { w: self }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&mut self) -> _DatlatW {
                _DatlatW { w: self }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&mut self) -> _ClkdivW {
                _ClkdivW { w: self }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&mut self) -> _DatastW {
                _DatastW { w: self }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&mut self) -> _AddhldW {
                _AddhldW { w: self }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&mut self) -> _AddsetW {
                _AddsetW { w: self }
            }
        }
    }
    # [ doc = "SRAM/NOR-Flash write timing registers 4" ]
    pub struct Bwtr4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "SRAM/NOR-Flash write timing registers 4" ]
    pub mod bwtr4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bwtr4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AccmodR {
            bits: u8,
        }
        impl AccmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatlatR {
            bits: u8,
        }
        impl DatlatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ClkdivR {
            bits: u8,
        }
        impl ClkdivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DatastR {
            bits: u8,
        }
        impl DatastR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddhldR {
            bits: u8,
        }
        impl AddhldR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddsetR {
            bits: u8,
        }
        impl AddsetR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AccmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AccmodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatlatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatlatW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ClkdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ClkdivW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DatastW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatastW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddhldW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddhldW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddsetW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddsetW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&self) -> AccmodR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AccmodR { bits }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&self) -> DatlatR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatlatR { bits }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&self) -> ClkdivR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ClkdivR { bits }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&self) -> DatastR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatastR { bits }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&self) -> AddhldR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddhldR { bits }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&self) -> AddsetR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddsetR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 268435455 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 28:29 - ACCMOD" ]
            # [ inline ( always ) ]
            pub fn accmod(&mut self) -> _AccmodW {
                _AccmodW { w: self }
            }
            # [ doc = "Bits 24:27 - DATLAT" ]
            # [ inline ( always ) ]
            pub fn datlat(&mut self) -> _DatlatW {
                _DatlatW { w: self }
            }
            # [ doc = "Bits 20:23 - CLKDIV" ]
            # [ inline ( always ) ]
            pub fn clkdiv(&mut self) -> _ClkdivW {
                _ClkdivW { w: self }
            }
            # [ doc = "Bits 8:15 - DATAST" ]
            # [ inline ( always ) ]
            pub fn datast(&mut self) -> _DatastW {
                _DatastW { w: self }
            }
            # [ doc = "Bits 4:7 - ADDHLD" ]
            # [ inline ( always ) ]
            pub fn addhld(&mut self) -> _AddhldW {
                _AddhldW { w: self }
            }
            # [ doc = "Bits 0:3 - ADDSET" ]
            # [ inline ( always ) ]
            pub fn addset(&mut self) -> _AddsetW {
                _AddsetW { w: self }
            }
        }
    }
}
# [ doc = "Flexible static memory controller" ]
pub struct Fsmc {
    register_block: fsmc::RegisterBlock,
}
impl Deref for Fsmc {
    type Target = fsmc::RegisterBlock;
    fn deref(&self) -> &fsmc::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Power control" ]
pub const PWR: Peripheral<Pwr> = unsafe { Peripheral::new(1073770496) };
# [ doc = "Power control" ]
pub mod pwr {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Power control register (PWR_CR)" ]
        pub cr: Cr,
        # [ doc = "0x04 - Power control register (PWR_CR)" ]
        pub csr: Csr,
    }
    # [ doc = "Power control register (PWR_CR)" ]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Power control register (PWR_CR)" ]
    pub mod cr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LpdsR {
            bits: u8,
        }
        impl LpdsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PddsR {
            bits: u8,
        }
        impl PddsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CwufR {
            bits: u8,
        }
        impl CwufR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CsbfR {
            bits: u8,
        }
        impl CsbfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PvdeR {
            bits: u8,
        }
        impl PvdeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PlsR {
            bits: u8,
        }
        impl PlsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbpR {
            bits: u8,
        }
        impl DbpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LpdsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LpdsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PddsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PddsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CwufW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CwufW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CsbfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CsbfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PvdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PvdeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PlsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Low Power Deep Sleep" ]
            # [ inline ( always ) ]
            pub fn lpds(&self) -> LpdsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LpdsR { bits }
            }
            # [ doc = "Bit 1 - Power Down Deep Sleep" ]
            # [ inline ( always ) ]
            pub fn pdds(&self) -> PddsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PddsR { bits }
            }
            # [ doc = "Bit 2 - Clear Wake-up Flag" ]
            # [ inline ( always ) ]
            pub fn cwuf(&self) -> CwufR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CwufR { bits }
            }
            # [ doc = "Bit 3 - Clear STANDBY Flag" ]
            # [ inline ( always ) ]
            pub fn csbf(&self) -> CsbfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CsbfR { bits }
            }
            # [ doc = "Bit 4 - Power Voltage Detector Enable" ]
            # [ inline ( always ) ]
            pub fn pvde(&self) -> PvdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PvdeR { bits }
            }
            # [ doc = "Bits 5:7 - PVD Level Selection" ]
            # [ inline ( always ) ]
            pub fn pls(&self) -> PlsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlsR { bits }
            }
            # [ doc = "Bit 8 - Disable Backup Domain write protection" ]
            # [ inline ( always ) ]
            pub fn dbp(&self) -> DbpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbpR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Low Power Deep Sleep" ]
            # [ inline ( always ) ]
            pub fn lpds(&mut self) -> _LpdsW {
                _LpdsW { w: self }
            }
            # [ doc = "Bit 1 - Power Down Deep Sleep" ]
            # [ inline ( always ) ]
            pub fn pdds(&mut self) -> _PddsW {
                _PddsW { w: self }
            }
            # [ doc = "Bit 2 - Clear Wake-up Flag" ]
            # [ inline ( always ) ]
            pub fn cwuf(&mut self) -> _CwufW {
                _CwufW { w: self }
            }
            # [ doc = "Bit 3 - Clear STANDBY Flag" ]
            # [ inline ( always ) ]
            pub fn csbf(&mut self) -> _CsbfW {
                _CsbfW { w: self }
            }
            # [ doc = "Bit 4 - Power Voltage Detector Enable" ]
            # [ inline ( always ) ]
            pub fn pvde(&mut self) -> _PvdeW {
                _PvdeW { w: self }
            }
            # [ doc = "Bits 5:7 - PVD Level Selection" ]
            # [ inline ( always ) ]
            pub fn pls(&mut self) -> _PlsW {
                _PlsW { w: self }
            }
            # [ doc = "Bit 8 - Disable Backup Domain write protection" ]
            # [ inline ( always ) ]
            pub fn dbp(&mut self) -> _DbpW {
                _DbpW { w: self }
            }
        }
    }
    # [ doc = "Power control register (PWR_CR)" ]
    pub struct Csr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Power control register (PWR_CR)" ]
    pub mod csr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Csr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WufR {
            bits: u8,
        }
        impl WufR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SbfR {
            bits: u8,
        }
        impl SbfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PvdoR {
            bits: u8,
        }
        impl PvdoR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EwupR {
            bits: u8,
        }
        impl EwupR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EwupW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EwupW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Wake-Up Flag" ]
            # [ inline ( always ) ]
            pub fn wuf(&self) -> WufR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WufR { bits }
            }
            # [ doc = "Bit 1 - STANDBY Flag" ]
            # [ inline ( always ) ]
            pub fn sbf(&self) -> SbfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SbfR { bits }
            }
            # [ doc = "Bit 2 - PVD Output" ]
            # [ inline ( always ) ]
            pub fn pvdo(&self) -> PvdoR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PvdoR { bits }
            }
            # [ doc = "Bit 8 - Enable WKUP pin" ]
            # [ inline ( always ) ]
            pub fn ewup(&self) -> EwupR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EwupR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 8 - Enable WKUP pin" ]
            # [ inline ( always ) ]
            pub fn ewup(&mut self) -> _EwupW {
                _EwupW { w: self }
            }
        }
    }
}
# [ doc = "Power control" ]
pub struct Pwr {
    register_block: pwr::RegisterBlock,
}
impl Deref for Pwr {
    type Target = pwr::RegisterBlock;
    fn deref(&self) -> &pwr::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Reset and clock control" ]
pub const RCC: Peripheral<Rcc> = unsafe { Peripheral::new(1073876992) };
# [ doc = "Reset and clock control" ]
pub mod rcc {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Clock control register" ]
        pub cr: Cr,
        # [ doc = "0x04 - Clock configuration register (RCC_CFGR)" ]
        pub cfgr: Cfgr,
        # [ doc = "0x08 - Clock interrupt register (RCC_CIR)" ]
        pub cir: Cir,
        # [ doc = "0x0c - APB2 peripheral reset register (RCC_APB2RSTR)" ]
        pub apb2rstr: Apb2rstr,
        # [ doc = "0x10 - APB1 peripheral reset register (RCC_APB1RSTR)" ]
        pub apb1rstr: Apb1rstr,
        # [ doc = "0x14 - AHB Peripheral Clock enable register (RCC_AHBENR)" ]
        pub ahbenr: Ahbenr,
        # [ doc = "0x18 - APB2 peripheral clock enable register (RCC_APB2ENR)" ]
        pub apb2enr: Apb2enr,
        # [ doc = "0x1c - APB1 peripheral clock enable register (RCC_APB1ENR)" ]
        pub apb1enr: Apb1enr,
        # [ doc = "0x20 - Backup domain control register (RCC_BDCR)" ]
        pub bdcr: Bdcr,
        # [ doc = "0x24 - Control/status register (RCC_CSR)" ]
        pub csr: Csr,
        _reserved0: [u8; 4usize],
        # [ doc = "0x2c - Clock configuration register 2" ]
        pub cfgr2: Cfgr2,
    }
    # [ doc = "Clock control register" ]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Clock control register" ]
    pub mod cr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HsionR {
            bits: u8,
        }
        impl HsionR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HsirdyR {
            bits: u8,
        }
        impl HsirdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HsitrimR {
            bits: u8,
        }
        impl HsitrimR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HsicalR {
            bits: u8,
        }
        impl HsicalR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HseonR {
            bits: u8,
        }
        impl HseonR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HserdyR {
            bits: u8,
        }
        impl HserdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HsebypR {
            bits: u8,
        }
        impl HsebypR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CssonR {
            bits: u8,
        }
        impl CssonR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PllonR {
            bits: u8,
        }
        impl PllonR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PllrdyR {
            bits: u8,
        }
        impl PllrdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HsionW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HsionW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HsitrimW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HsitrimW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HseonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HseonW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HsebypW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HsebypW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CssonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CssonW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PllonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PllonW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Internal High Speed clock enable" ]
            # [ inline ( always ) ]
            pub fn hsion(&self) -> HsionR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HsionR { bits }
            }
            # [ doc = "Bit 1 - Internal High Speed clock ready flag" ]
            # [ inline ( always ) ]
            pub fn hsirdy(&self) -> HsirdyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HsirdyR { bits }
            }
            # [ doc = "Bits 3:7 - Internal High Speed clock trimming" ]
            # [ inline ( always ) ]
            pub fn hsitrim(&self) -> HsitrimR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HsitrimR { bits }
            }
            # [ doc = "Bits 8:15 - Internal High Speed clock Calibration" ]
            # [ inline ( always ) ]
            pub fn hsical(&self) -> HsicalR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HsicalR { bits }
            }
            # [ doc = "Bit 16 - External High Speed clock enable" ]
            # [ inline ( always ) ]
            pub fn hseon(&self) -> HseonR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HseonR { bits }
            }
            # [ doc = "Bit 17 - External High Speed clock ready flag" ]
            # [ inline ( always ) ]
            pub fn hserdy(&self) -> HserdyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HserdyR { bits }
            }
            # [ doc = "Bit 18 - External High Speed clock Bypass" ]
            # [ inline ( always ) ]
            pub fn hsebyp(&self) -> HsebypR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HsebypR { bits }
            }
            # [ doc = "Bit 19 - Clock Security System enable" ]
            # [ inline ( always ) ]
            pub fn csson(&self) -> CssonR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CssonR { bits }
            }
            # [ doc = "Bit 24 - PLL enable" ]
            # [ inline ( always ) ]
            pub fn pllon(&self) -> PllonR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PllonR { bits }
            }
            # [ doc = "Bit 25 - PLL clock ready flag" ]
            # [ inline ( always ) ]
            pub fn pllrdy(&self) -> PllrdyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PllrdyR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 131 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Internal High Speed clock enable" ]
            # [ inline ( always ) ]
            pub fn hsion(&mut self) -> _HsionW {
                _HsionW { w: self }
            }
            # [ doc = "Bits 3:7 - Internal High Speed clock trimming" ]
            # [ inline ( always ) ]
            pub fn hsitrim(&mut self) -> _HsitrimW {
                _HsitrimW { w: self }
            }
            # [ doc = "Bit 16 - External High Speed clock enable" ]
            # [ inline ( always ) ]
            pub fn hseon(&mut self) -> _HseonW {
                _HseonW { w: self }
            }
            # [ doc = "Bit 18 - External High Speed clock Bypass" ]
            # [ inline ( always ) ]
            pub fn hsebyp(&mut self) -> _HsebypW {
                _HsebypW { w: self }
            }
            # [ doc = "Bit 19 - Clock Security System enable" ]
            # [ inline ( always ) ]
            pub fn csson(&mut self) -> _CssonW {
                _CssonW { w: self }
            }
            # [ doc = "Bit 24 - PLL enable" ]
            # [ inline ( always ) ]
            pub fn pllon(&mut self) -> _PllonW {
                _PllonW { w: self }
            }
        }
    }
    # [ doc = "Clock configuration register (RCC_CFGR)" ]
    pub struct Cfgr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Clock configuration register (RCC_CFGR)" ]
    pub mod cfgr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cfgr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SwR {
            bits: u8,
        }
        impl SwR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SwsR {
            bits: u8,
        }
        impl SwsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HpreR {
            bits: u8,
        }
        impl HpreR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ppre1R {
            bits: u8,
        }
        impl Ppre1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ppre2R {
            bits: u8,
        }
        impl Ppre2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AdcpreR {
            bits: u8,
        }
        impl AdcpreR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PllsrcR {
            bits: u8,
        }
        impl PllsrcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PllxtpreR {
            bits: u8,
        }
        impl PllxtpreR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PllmulR {
            bits: u8,
        }
        impl PllmulR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct McoR {
            bits: u8,
        }
        impl McoR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SwW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SwW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HpreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HpreW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ppre1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ppre1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ppre2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ppre2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AdcpreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdcpreW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PllsrcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PllsrcW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PllxtpreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PllxtpreW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PllmulW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PllmulW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _McoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _McoW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - System clock Switch" ]
            # [ inline ( always ) ]
            pub fn sw(&self) -> SwR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SwR { bits }
            }
            # [ doc = "Bits 2:3 - System Clock Switch Status" ]
            # [ inline ( always ) ]
            pub fn sws(&self) -> SwsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SwsR { bits }
            }
            # [ doc = "Bits 4:7 - AHB prescaler" ]
            # [ inline ( always ) ]
            pub fn hpre(&self) -> HpreR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HpreR { bits }
            }
            # [ doc = "Bits 8:10 - APB Low speed prescaler (APB1)" ]
            # [ inline ( always ) ]
            pub fn ppre1(&self) -> Ppre1R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ppre1R { bits }
            }
            # [ doc = "Bits 11:13 - APB High speed prescaler (APB2)" ]
            # [ inline ( always ) ]
            pub fn ppre2(&self) -> Ppre2R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ppre2R { bits }
            }
            # [ doc = "Bits 14:15 - ADC prescaler" ]
            # [ inline ( always ) ]
            pub fn adcpre(&self) -> AdcpreR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AdcpreR { bits }
            }
            # [ doc = "Bit 16 - PLL entry clock source" ]
            # [ inline ( always ) ]
            pub fn pllsrc(&self) -> PllsrcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PllsrcR { bits }
            }
            # [ doc = "Bit 17 - HSE divider for PLL entry" ]
            # [ inline ( always ) ]
            pub fn pllxtpre(&self) -> PllxtpreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PllxtpreR { bits }
            }
            # [ doc = "Bits 18:21 - PLL Multiplication Factor" ]
            # [ inline ( always ) ]
            pub fn pllmul(&self) -> PllmulR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PllmulR { bits }
            }
            # [ doc = "Bits 24:26 - Microcontroller clock output" ]
            # [ inline ( always ) ]
            pub fn mco(&self) -> McoR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                McoR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - System clock Switch" ]
            # [ inline ( always ) ]
            pub fn sw(&mut self) -> _SwW {
                _SwW { w: self }
            }
            # [ doc = "Bits 4:7 - AHB prescaler" ]
            # [ inline ( always ) ]
            pub fn hpre(&mut self) -> _HpreW {
                _HpreW { w: self }
            }
            # [ doc = "Bits 8:10 - APB Low speed prescaler (APB1)" ]
            # [ inline ( always ) ]
            pub fn ppre1(&mut self) -> _Ppre1W {
                _Ppre1W { w: self }
            }
            # [ doc = "Bits 11:13 - APB High speed prescaler (APB2)" ]
            # [ inline ( always ) ]
            pub fn ppre2(&mut self) -> _Ppre2W {
                _Ppre2W { w: self }
            }
            # [ doc = "Bits 14:15 - ADC prescaler" ]
            # [ inline ( always ) ]
            pub fn adcpre(&mut self) -> _AdcpreW {
                _AdcpreW { w: self }
            }
            # [ doc = "Bit 16 - PLL entry clock source" ]
            # [ inline ( always ) ]
            pub fn pllsrc(&mut self) -> _PllsrcW {
                _PllsrcW { w: self }
            }
            # [ doc = "Bit 17 - HSE divider for PLL entry" ]
            # [ inline ( always ) ]
            pub fn pllxtpre(&mut self) -> _PllxtpreW {
                _PllxtpreW { w: self }
            }
            # [ doc = "Bits 18:21 - PLL Multiplication Factor" ]
            # [ inline ( always ) ]
            pub fn pllmul(&mut self) -> _PllmulW {
                _PllmulW { w: self }
            }
            # [ doc = "Bits 24:26 - Microcontroller clock output" ]
            # [ inline ( always ) ]
            pub fn mco(&mut self) -> _McoW {
                _McoW { w: self }
            }
        }
    }
    # [ doc = "Clock interrupt register (RCC_CIR)" ]
    pub struct Cir {
        register: VolatileCell<u32>,
    }
    # [ doc = "Clock interrupt register (RCC_CIR)" ]
    pub mod cir {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cir {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LsirdyfR {
            bits: u8,
        }
        impl LsirdyfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LserdyfR {
            bits: u8,
        }
        impl LserdyfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HsirdyfR {
            bits: u8,
        }
        impl HsirdyfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HserdyfR {
            bits: u8,
        }
        impl HserdyfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PllrdyfR {
            bits: u8,
        }
        impl PllrdyfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CssfR {
            bits: u8,
        }
        impl CssfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LsirdyieR {
            bits: u8,
        }
        impl LsirdyieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LserdyieR {
            bits: u8,
        }
        impl LserdyieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HsirdyieR {
            bits: u8,
        }
        impl HsirdyieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HserdyieR {
            bits: u8,
        }
        impl HserdyieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PllrdyieR {
            bits: u8,
        }
        impl PllrdyieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LsirdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LsirdyieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LserdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LserdyieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HsirdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HsirdyieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HserdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HserdyieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PllrdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PllrdyieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LsirdycW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LsirdycW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LserdycW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LserdycW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HsirdycW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HsirdycW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HserdycW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HserdycW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PllrdycW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PllrdycW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CsscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CsscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - LSI Ready Interrupt flag" ]
            # [ inline ( always ) ]
            pub fn lsirdyf(&self) -> LsirdyfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LsirdyfR { bits }
            }
            # [ doc = "Bit 1 - LSE Ready Interrupt flag" ]
            # [ inline ( always ) ]
            pub fn lserdyf(&self) -> LserdyfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LserdyfR { bits }
            }
            # [ doc = "Bit 2 - HSI Ready Interrupt flag" ]
            # [ inline ( always ) ]
            pub fn hsirdyf(&self) -> HsirdyfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HsirdyfR { bits }
            }
            # [ doc = "Bit 3 - HSE Ready Interrupt flag" ]
            # [ inline ( always ) ]
            pub fn hserdyf(&self) -> HserdyfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HserdyfR { bits }
            }
            # [ doc = "Bit 4 - PLL Ready Interrupt flag" ]
            # [ inline ( always ) ]
            pub fn pllrdyf(&self) -> PllrdyfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PllrdyfR { bits }
            }
            # [ doc = "Bit 7 - Clock Security System Interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cssf(&self) -> CssfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CssfR { bits }
            }
            # [ doc = "Bit 8 - LSI Ready Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn lsirdyie(&self) -> LsirdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LsirdyieR { bits }
            }
            # [ doc = "Bit 9 - LSE Ready Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn lserdyie(&self) -> LserdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LserdyieR { bits }
            }
            # [ doc = "Bit 10 - HSI Ready Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn hsirdyie(&self) -> HsirdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HsirdyieR { bits }
            }
            # [ doc = "Bit 11 - HSE Ready Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn hserdyie(&self) -> HserdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HserdyieR { bits }
            }
            # [ doc = "Bit 12 - PLL Ready Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn pllrdyie(&self) -> PllrdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PllrdyieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 8 - LSI Ready Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn lsirdyie(&mut self) -> _LsirdyieW {
                _LsirdyieW { w: self }
            }
            # [ doc = "Bit 9 - LSE Ready Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn lserdyie(&mut self) -> _LserdyieW {
                _LserdyieW { w: self }
            }
            # [ doc = "Bit 10 - HSI Ready Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn hsirdyie(&mut self) -> _HsirdyieW {
                _HsirdyieW { w: self }
            }
            # [ doc = "Bit 11 - HSE Ready Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn hserdyie(&mut self) -> _HserdyieW {
                _HserdyieW { w: self }
            }
            # [ doc = "Bit 12 - PLL Ready Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn pllrdyie(&mut self) -> _PllrdyieW {
                _PllrdyieW { w: self }
            }
            # [ doc = "Bit 16 - LSI Ready Interrupt Clear" ]
            # [ inline ( always ) ]
            pub fn lsirdyc(&mut self) -> _LsirdycW {
                _LsirdycW { w: self }
            }
            # [ doc = "Bit 17 - LSE Ready Interrupt Clear" ]
            # [ inline ( always ) ]
            pub fn lserdyc(&mut self) -> _LserdycW {
                _LserdycW { w: self }
            }
            # [ doc = "Bit 18 - HSI Ready Interrupt Clear" ]
            # [ inline ( always ) ]
            pub fn hsirdyc(&mut self) -> _HsirdycW {
                _HsirdycW { w: self }
            }
            # [ doc = "Bit 19 - HSE Ready Interrupt Clear" ]
            # [ inline ( always ) ]
            pub fn hserdyc(&mut self) -> _HserdycW {
                _HserdycW { w: self }
            }
            # [ doc = "Bit 20 - PLL Ready Interrupt Clear" ]
            # [ inline ( always ) ]
            pub fn pllrdyc(&mut self) -> _PllrdycW {
                _PllrdycW { w: self }
            }
            # [ doc = "Bit 23 - Clock security system interrupt clear" ]
            # [ inline ( always ) ]
            pub fn cssc(&mut self) -> _CsscW {
                _CsscW { w: self }
            }
        }
    }
    # [ doc = "APB2 peripheral reset register (RCC_APB2RSTR)" ]
    pub struct Apb2rstr {
        register: VolatileCell<u32>,
    }
    # [ doc = "APB2 peripheral reset register (RCC_APB2RSTR)" ]
    pub mod apb2rstr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Apb2rstr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AfiorstR {
            bits: u8,
        }
        impl AfiorstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IoparstR {
            bits: u8,
        }
        impl IoparstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IopbrstR {
            bits: u8,
        }
        impl IopbrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IopcrstR {
            bits: u8,
        }
        impl IopcrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IopdrstR {
            bits: u8,
        }
        impl IopdrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IoperstR {
            bits: u8,
        }
        impl IoperstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IopfrstR {
            bits: u8,
        }
        impl IopfrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IopgrstR {
            bits: u8,
        }
        impl IopgrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc1rstR {
            bits: u8,
        }
        impl Adc1rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim1rstR {
            bits: u8,
        }
        impl Tim1rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Spi1rstR {
            bits: u8,
        }
        impl Spi1rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Usart1rstR {
            bits: u8,
        }
        impl Usart1rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim15rstR {
            bits: u8,
        }
        impl Tim15rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim16rstR {
            bits: u8,
        }
        impl Tim16rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim17rstR {
            bits: u8,
        }
        impl Tim17rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AfiorstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AfiorstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IoparstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IoparstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IopbrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopbrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IopcrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopcrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IopdrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopdrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IoperstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IoperstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IopfrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopfrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IopgrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopgrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc1rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc1rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim1rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim1rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Spi1rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi1rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Usart1rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart1rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim15rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim15rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim16rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim16rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim17rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim17rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Alternate function I/O reset" ]
            # [ inline ( always ) ]
            pub fn afiorst(&self) -> AfiorstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AfiorstR { bits }
            }
            # [ doc = "Bit 2 - IO port A reset" ]
            # [ inline ( always ) ]
            pub fn ioparst(&self) -> IoparstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IoparstR { bits }
            }
            # [ doc = "Bit 3 - IO port B reset" ]
            # [ inline ( always ) ]
            pub fn iopbrst(&self) -> IopbrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IopbrstR { bits }
            }
            # [ doc = "Bit 4 - IO port C reset" ]
            # [ inline ( always ) ]
            pub fn iopcrst(&self) -> IopcrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IopcrstR { bits }
            }
            # [ doc = "Bit 5 - IO port D reset" ]
            # [ inline ( always ) ]
            pub fn iopdrst(&self) -> IopdrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IopdrstR { bits }
            }
            # [ doc = "Bit 6 - IO port E reset" ]
            # [ inline ( always ) ]
            pub fn ioperst(&self) -> IoperstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IoperstR { bits }
            }
            # [ doc = "Bit 7 - IO port F reset" ]
            # [ inline ( always ) ]
            pub fn iopfrst(&self) -> IopfrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IopfrstR { bits }
            }
            # [ doc = "Bit 8 - IO port G reset" ]
            # [ inline ( always ) ]
            pub fn iopgrst(&self) -> IopgrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IopgrstR { bits }
            }
            # [ doc = "Bit 9 - ADC 1 interface reset" ]
            # [ inline ( always ) ]
            pub fn adc1rst(&self) -> Adc1rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Adc1rstR { bits }
            }
            # [ doc = "Bit 11 - TIM1 timer reset" ]
            # [ inline ( always ) ]
            pub fn tim1rst(&self) -> Tim1rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim1rstR { bits }
            }
            # [ doc = "Bit 12 - SPI 1 reset" ]
            # [ inline ( always ) ]
            pub fn spi1rst(&self) -> Spi1rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Spi1rstR { bits }
            }
            # [ doc = "Bit 14 - USART1 reset" ]
            # [ inline ( always ) ]
            pub fn usart1rst(&self) -> Usart1rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Usart1rstR { bits }
            }
            # [ doc = "Bit 16 - TIM15 timer reset" ]
            # [ inline ( always ) ]
            pub fn tim15rst(&self) -> Tim15rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim15rstR { bits }
            }
            # [ doc = "Bit 17 - TIM16 timer reset" ]
            # [ inline ( always ) ]
            pub fn tim16rst(&self) -> Tim16rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim16rstR { bits }
            }
            # [ doc = "Bit 18 - TIM17 timer reset" ]
            # [ inline ( always ) ]
            pub fn tim17rst(&self) -> Tim17rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim17rstR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Alternate function I/O reset" ]
            # [ inline ( always ) ]
            pub fn afiorst(&mut self) -> _AfiorstW {
                _AfiorstW { w: self }
            }
            # [ doc = "Bit 2 - IO port A reset" ]
            # [ inline ( always ) ]
            pub fn ioparst(&mut self) -> _IoparstW {
                _IoparstW { w: self }
            }
            # [ doc = "Bit 3 - IO port B reset" ]
            # [ inline ( always ) ]
            pub fn iopbrst(&mut self) -> _IopbrstW {
                _IopbrstW { w: self }
            }
            # [ doc = "Bit 4 - IO port C reset" ]
            # [ inline ( always ) ]
            pub fn iopcrst(&mut self) -> _IopcrstW {
                _IopcrstW { w: self }
            }
            # [ doc = "Bit 5 - IO port D reset" ]
            # [ inline ( always ) ]
            pub fn iopdrst(&mut self) -> _IopdrstW {
                _IopdrstW { w: self }
            }
            # [ doc = "Bit 6 - IO port E reset" ]
            # [ inline ( always ) ]
            pub fn ioperst(&mut self) -> _IoperstW {
                _IoperstW { w: self }
            }
            # [ doc = "Bit 7 - IO port F reset" ]
            # [ inline ( always ) ]
            pub fn iopfrst(&mut self) -> _IopfrstW {
                _IopfrstW { w: self }
            }
            # [ doc = "Bit 8 - IO port G reset" ]
            # [ inline ( always ) ]
            pub fn iopgrst(&mut self) -> _IopgrstW {
                _IopgrstW { w: self }
            }
            # [ doc = "Bit 9 - ADC 1 interface reset" ]
            # [ inline ( always ) ]
            pub fn adc1rst(&mut self) -> _Adc1rstW {
                _Adc1rstW { w: self }
            }
            # [ doc = "Bit 11 - TIM1 timer reset" ]
            # [ inline ( always ) ]
            pub fn tim1rst(&mut self) -> _Tim1rstW {
                _Tim1rstW { w: self }
            }
            # [ doc = "Bit 12 - SPI 1 reset" ]
            # [ inline ( always ) ]
            pub fn spi1rst(&mut self) -> _Spi1rstW {
                _Spi1rstW { w: self }
            }
            # [ doc = "Bit 14 - USART1 reset" ]
            # [ inline ( always ) ]
            pub fn usart1rst(&mut self) -> _Usart1rstW {
                _Usart1rstW { w: self }
            }
            # [ doc = "Bit 16 - TIM15 timer reset" ]
            # [ inline ( always ) ]
            pub fn tim15rst(&mut self) -> _Tim15rstW {
                _Tim15rstW { w: self }
            }
            # [ doc = "Bit 17 - TIM16 timer reset" ]
            # [ inline ( always ) ]
            pub fn tim16rst(&mut self) -> _Tim16rstW {
                _Tim16rstW { w: self }
            }
            # [ doc = "Bit 18 - TIM17 timer reset" ]
            # [ inline ( always ) ]
            pub fn tim17rst(&mut self) -> _Tim17rstW {
                _Tim17rstW { w: self }
            }
        }
    }
    # [ doc = "APB1 peripheral reset register (RCC_APB1RSTR)" ]
    pub struct Apb1rstr {
        register: VolatileCell<u32>,
    }
    # [ doc = "APB1 peripheral reset register (RCC_APB1RSTR)" ]
    pub mod apb1rstr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Apb1rstr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim2rstR {
            bits: u8,
        }
        impl Tim2rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim3rstR {
            bits: u8,
        }
        impl Tim3rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim4rstR {
            bits: u8,
        }
        impl Tim4rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim5rstR {
            bits: u8,
        }
        impl Tim5rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim6rstR {
            bits: u8,
        }
        impl Tim6rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim7rstR {
            bits: u8,
        }
        impl Tim7rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim12rstR {
            bits: u8,
        }
        impl Tim12rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim13rstR {
            bits: u8,
        }
        impl Tim13rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim14rstR {
            bits: u8,
        }
        impl Tim14rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WwdgrstR {
            bits: u8,
        }
        impl WwdgrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Spi2rstR {
            bits: u8,
        }
        impl Spi2rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Spi3rstR {
            bits: u8,
        }
        impl Spi3rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Usart2rstR {
            bits: u8,
        }
        impl Usart2rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Usart3rstR {
            bits: u8,
        }
        impl Usart3rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Usart4rstR {
            bits: u8,
        }
        impl Usart4rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Usart5rstR {
            bits: u8,
        }
        impl Usart5rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct I2c1rstR {
            bits: u8,
        }
        impl I2c1rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct I2c2rstR {
            bits: u8,
        }
        impl I2c2rstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BkprstR {
            bits: u8,
        }
        impl BkprstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PwrrstR {
            bits: u8,
        }
        impl PwrrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DacrstR {
            bits: u8,
        }
        impl DacrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CecrstR {
            bits: u8,
        }
        impl CecrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim2rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim2rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim3rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim3rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim4rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim4rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim5rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim5rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim6rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim6rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim7rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim7rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim12rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim12rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim13rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim13rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim14rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim14rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WwdgrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WwdgrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Spi2rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi2rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Spi3rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi3rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Usart2rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart2rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Usart3rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart3rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Usart4rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart4rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Usart5rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart5rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _I2c1rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2c1rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _I2c2rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2c2rstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BkprstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkprstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PwrrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PwrrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DacrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DacrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CecrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CecrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Timer 2 reset" ]
            # [ inline ( always ) ]
            pub fn tim2rst(&self) -> Tim2rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim2rstR { bits }
            }
            # [ doc = "Bit 1 - Timer 3 reset" ]
            # [ inline ( always ) ]
            pub fn tim3rst(&self) -> Tim3rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim3rstR { bits }
            }
            # [ doc = "Bit 2 - Timer 4 reset" ]
            # [ inline ( always ) ]
            pub fn tim4rst(&self) -> Tim4rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim4rstR { bits }
            }
            # [ doc = "Bit 3 - Timer 5 reset" ]
            # [ inline ( always ) ]
            pub fn tim5rst(&self) -> Tim5rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim5rstR { bits }
            }
            # [ doc = "Bit 4 - Timer 6 reset" ]
            # [ inline ( always ) ]
            pub fn tim6rst(&self) -> Tim6rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim6rstR { bits }
            }
            # [ doc = "Bit 5 - Timer 7 reset" ]
            # [ inline ( always ) ]
            pub fn tim7rst(&self) -> Tim7rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim7rstR { bits }
            }
            # [ doc = "Bit 6 - Timer 12 reset" ]
            # [ inline ( always ) ]
            pub fn tim12rst(&self) -> Tim12rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim12rstR { bits }
            }
            # [ doc = "Bit 7 - Timer 13 reset" ]
            # [ inline ( always ) ]
            pub fn tim13rst(&self) -> Tim13rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim13rstR { bits }
            }
            # [ doc = "Bit 8 - Timer 14 reset" ]
            # [ inline ( always ) ]
            pub fn tim14rst(&self) -> Tim14rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim14rstR { bits }
            }
            # [ doc = "Bit 11 - Window watchdog reset" ]
            # [ inline ( always ) ]
            pub fn wwdgrst(&self) -> WwdgrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WwdgrstR { bits }
            }
            # [ doc = "Bit 14 - SPI2 reset" ]
            # [ inline ( always ) ]
            pub fn spi2rst(&self) -> Spi2rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Spi2rstR { bits }
            }
            # [ doc = "Bit 15 - SPI3 reset" ]
            # [ inline ( always ) ]
            pub fn spi3rst(&self) -> Spi3rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Spi3rstR { bits }
            }
            # [ doc = "Bit 17 - USART 2 reset" ]
            # [ inline ( always ) ]
            pub fn usart2rst(&self) -> Usart2rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Usart2rstR { bits }
            }
            # [ doc = "Bit 18 - USART 3 reset" ]
            # [ inline ( always ) ]
            pub fn usart3rst(&self) -> Usart3rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Usart3rstR { bits }
            }
            # [ doc = "Bit 19 - USART 4 reset" ]
            # [ inline ( always ) ]
            pub fn usart4rst(&self) -> Usart4rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Usart4rstR { bits }
            }
            # [ doc = "Bit 20 - USART 5 reset" ]
            # [ inline ( always ) ]
            pub fn usart5rst(&self) -> Usart5rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Usart5rstR { bits }
            }
            # [ doc = "Bit 21 - I2C1 reset" ]
            # [ inline ( always ) ]
            pub fn i2c1rst(&self) -> I2c1rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2c1rstR { bits }
            }
            # [ doc = "Bit 22 - I2C2 reset" ]
            # [ inline ( always ) ]
            pub fn i2c2rst(&self) -> I2c2rstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2c2rstR { bits }
            }
            # [ doc = "Bit 27 - Backup interface reset" ]
            # [ inline ( always ) ]
            pub fn bkprst(&self) -> BkprstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkprstR { bits }
            }
            # [ doc = "Bit 28 - Power interface reset" ]
            # [ inline ( always ) ]
            pub fn pwrrst(&self) -> PwrrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PwrrstR { bits }
            }
            # [ doc = "Bit 29 - DAC interface reset" ]
            # [ inline ( always ) ]
            pub fn dacrst(&self) -> DacrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DacrstR { bits }
            }
            # [ doc = "Bit 30 - CEC reset" ]
            # [ inline ( always ) ]
            pub fn cecrst(&self) -> CecrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CecrstR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Timer 2 reset" ]
            # [ inline ( always ) ]
            pub fn tim2rst(&mut self) -> _Tim2rstW {
                _Tim2rstW { w: self }
            }
            # [ doc = "Bit 1 - Timer 3 reset" ]
            # [ inline ( always ) ]
            pub fn tim3rst(&mut self) -> _Tim3rstW {
                _Tim3rstW { w: self }
            }
            # [ doc = "Bit 2 - Timer 4 reset" ]
            # [ inline ( always ) ]
            pub fn tim4rst(&mut self) -> _Tim4rstW {
                _Tim4rstW { w: self }
            }
            # [ doc = "Bit 3 - Timer 5 reset" ]
            # [ inline ( always ) ]
            pub fn tim5rst(&mut self) -> _Tim5rstW {
                _Tim5rstW { w: self }
            }
            # [ doc = "Bit 4 - Timer 6 reset" ]
            # [ inline ( always ) ]
            pub fn tim6rst(&mut self) -> _Tim6rstW {
                _Tim6rstW { w: self }
            }
            # [ doc = "Bit 5 - Timer 7 reset" ]
            # [ inline ( always ) ]
            pub fn tim7rst(&mut self) -> _Tim7rstW {
                _Tim7rstW { w: self }
            }
            # [ doc = "Bit 6 - Timer 12 reset" ]
            # [ inline ( always ) ]
            pub fn tim12rst(&mut self) -> _Tim12rstW {
                _Tim12rstW { w: self }
            }
            # [ doc = "Bit 7 - Timer 13 reset" ]
            # [ inline ( always ) ]
            pub fn tim13rst(&mut self) -> _Tim13rstW {
                _Tim13rstW { w: self }
            }
            # [ doc = "Bit 8 - Timer 14 reset" ]
            # [ inline ( always ) ]
            pub fn tim14rst(&mut self) -> _Tim14rstW {
                _Tim14rstW { w: self }
            }
            # [ doc = "Bit 11 - Window watchdog reset" ]
            # [ inline ( always ) ]
            pub fn wwdgrst(&mut self) -> _WwdgrstW {
                _WwdgrstW { w: self }
            }
            # [ doc = "Bit 14 - SPI2 reset" ]
            # [ inline ( always ) ]
            pub fn spi2rst(&mut self) -> _Spi2rstW {
                _Spi2rstW { w: self }
            }
            # [ doc = "Bit 15 - SPI3 reset" ]
            # [ inline ( always ) ]
            pub fn spi3rst(&mut self) -> _Spi3rstW {
                _Spi3rstW { w: self }
            }
            # [ doc = "Bit 17 - USART 2 reset" ]
            # [ inline ( always ) ]
            pub fn usart2rst(&mut self) -> _Usart2rstW {
                _Usart2rstW { w: self }
            }
            # [ doc = "Bit 18 - USART 3 reset" ]
            # [ inline ( always ) ]
            pub fn usart3rst(&mut self) -> _Usart3rstW {
                _Usart3rstW { w: self }
            }
            # [ doc = "Bit 19 - USART 4 reset" ]
            # [ inline ( always ) ]
            pub fn usart4rst(&mut self) -> _Usart4rstW {
                _Usart4rstW { w: self }
            }
            # [ doc = "Bit 20 - USART 5 reset" ]
            # [ inline ( always ) ]
            pub fn usart5rst(&mut self) -> _Usart5rstW {
                _Usart5rstW { w: self }
            }
            # [ doc = "Bit 21 - I2C1 reset" ]
            # [ inline ( always ) ]
            pub fn i2c1rst(&mut self) -> _I2c1rstW {
                _I2c1rstW { w: self }
            }
            # [ doc = "Bit 22 - I2C2 reset" ]
            # [ inline ( always ) ]
            pub fn i2c2rst(&mut self) -> _I2c2rstW {
                _I2c2rstW { w: self }
            }
            # [ doc = "Bit 27 - Backup interface reset" ]
            # [ inline ( always ) ]
            pub fn bkprst(&mut self) -> _BkprstW {
                _BkprstW { w: self }
            }
            # [ doc = "Bit 28 - Power interface reset" ]
            # [ inline ( always ) ]
            pub fn pwrrst(&mut self) -> _PwrrstW {
                _PwrrstW { w: self }
            }
            # [ doc = "Bit 29 - DAC interface reset" ]
            # [ inline ( always ) ]
            pub fn dacrst(&mut self) -> _DacrstW {
                _DacrstW { w: self }
            }
            # [ doc = "Bit 30 - CEC reset" ]
            # [ inline ( always ) ]
            pub fn cecrst(&mut self) -> _CecrstW {
                _CecrstW { w: self }
            }
        }
    }
    # [ doc = "AHB Peripheral Clock enable register (RCC_AHBENR)" ]
    pub struct Ahbenr {
        register: VolatileCell<u32>,
    }
    # [ doc = "AHB Peripheral Clock enable register (RCC_AHBENR)" ]
    pub mod ahbenr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ahbenr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dma1enR {
            bits: u8,
        }
        impl Dma1enR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dma2enR {
            bits: u8,
        }
        impl Dma2enR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SramenR {
            bits: u8,
        }
        impl SramenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FlitfenR {
            bits: u8,
        }
        impl FlitfenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CrcenR {
            bits: u8,
        }
        impl CrcenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FsmcenR {
            bits: u8,
        }
        impl FsmcenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dma1enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dma1enW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dma2enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dma2enW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SramenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SramenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FlitfenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FlitfenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CrcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrcenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FsmcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FsmcenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - DMA1 clock enable" ]
            # [ inline ( always ) ]
            pub fn dma1en(&self) -> Dma1enR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dma1enR { bits }
            }
            # [ doc = "Bit 1 - DMA2 clock enable" ]
            # [ inline ( always ) ]
            pub fn dma2en(&self) -> Dma2enR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dma2enR { bits }
            }
            # [ doc = "Bit 2 - SRAM interface clock enable" ]
            # [ inline ( always ) ]
            pub fn sramen(&self) -> SramenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SramenR { bits }
            }
            # [ doc = "Bit 4 - FLITF clock enable" ]
            # [ inline ( always ) ]
            pub fn flitfen(&self) -> FlitfenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FlitfenR { bits }
            }
            # [ doc = "Bit 6 - CRC clock enable" ]
            # [ inline ( always ) ]
            pub fn crcen(&self) -> CrcenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CrcenR { bits }
            }
            # [ doc = "Bit 8 - FSMC clock enable" ]
            # [ inline ( always ) ]
            pub fn fsmcen(&self) -> FsmcenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FsmcenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 20 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - DMA1 clock enable" ]
            # [ inline ( always ) ]
            pub fn dma1en(&mut self) -> _Dma1enW {
                _Dma1enW { w: self }
            }
            # [ doc = "Bit 1 - DMA2 clock enable" ]
            # [ inline ( always ) ]
            pub fn dma2en(&mut self) -> _Dma2enW {
                _Dma2enW { w: self }
            }
            # [ doc = "Bit 2 - SRAM interface clock enable" ]
            # [ inline ( always ) ]
            pub fn sramen(&mut self) -> _SramenW {
                _SramenW { w: self }
            }
            # [ doc = "Bit 4 - FLITF clock enable" ]
            # [ inline ( always ) ]
            pub fn flitfen(&mut self) -> _FlitfenW {
                _FlitfenW { w: self }
            }
            # [ doc = "Bit 6 - CRC clock enable" ]
            # [ inline ( always ) ]
            pub fn crcen(&mut self) -> _CrcenW {
                _CrcenW { w: self }
            }
            # [ doc = "Bit 8 - FSMC clock enable" ]
            # [ inline ( always ) ]
            pub fn fsmcen(&mut self) -> _FsmcenW {
                _FsmcenW { w: self }
            }
        }
    }
    # [ doc = "APB2 peripheral clock enable register (RCC_APB2ENR)" ]
    pub struct Apb2enr {
        register: VolatileCell<u32>,
    }
    # [ doc = "APB2 peripheral clock enable register (RCC_APB2ENR)" ]
    pub mod apb2enr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Apb2enr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `AFIOEN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AfioenR {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl AfioenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AfioenR::Disabled => 0,
                    AfioenR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AfioenR {
                match bits {
                    0 => AfioenR::Disabled,
                    1 => AfioenR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == AfioenR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == AfioenR::Enabled
            }
        }
        # [ doc = "Possible values of the field `IOPAEN`" ]
        pub type IopaenR = AfioenR;
        # [ doc = "Possible values of the field `IOPBEN`" ]
        pub type IopbenR = AfioenR;
        # [ doc = "Possible values of the field `IOPCEN`" ]
        pub type IopcenR = AfioenR;
        # [ doc = "Possible values of the field `IOPDEN`" ]
        pub type IopdenR = AfioenR;
        # [ doc = "Possible values of the field `IOPEEN`" ]
        pub type IopeenR = AfioenR;
        # [ doc = "Possible values of the field `IOPFEN`" ]
        pub type IopfenR = AfioenR;
        # [ doc = "Possible values of the field `IOPGEN`" ]
        pub type IopgenR = AfioenR;
        # [ doc = "Possible values of the field `ADC1EN`" ]
        pub type Adc1enR = AfioenR;
        # [ doc = "Possible values of the field `TIM1EN`" ]
        pub type Tim1enR = AfioenR;
        # [ doc = "Possible values of the field `SPI1EN`" ]
        pub type Spi1enR = AfioenR;
        # [ doc = "Possible values of the field `USART1EN`" ]
        pub type Usart1enR = AfioenR;
        # [ doc = "Possible values of the field `TIM15EN`" ]
        pub type Tim15enR = AfioenR;
        # [ doc = "Possible values of the field `TIM16EN`" ]
        pub type Tim16enR = AfioenR;
        # [ doc = "Possible values of the field `TIM17EN`" ]
        pub type Tim17enR = AfioenR;
        # [ doc = "Values that can be written to the field `AFIOEN`" ]
        pub enum AfioenW {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl AfioenW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AfioenW::Disabled => 0,
                    AfioenW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AfioenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AfioenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AfioenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IOPAEN`" ]
        pub type IopaenW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _IopaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopaenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: IopaenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IOPBEN`" ]
        pub type IopbenW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _IopbenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopbenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: IopbenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IOPCEN`" ]
        pub type IopcenW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _IopcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopcenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: IopcenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IOPDEN`" ]
        pub type IopdenW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _IopdenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopdenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: IopdenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IOPEEN`" ]
        pub type IopeenW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _IopeenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopeenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: IopeenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IOPFEN`" ]
        pub type IopfenW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _IopfenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopfenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: IopfenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `IOPGEN`" ]
        pub type IopgenW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _IopgenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopgenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: IopgenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADC1EN`" ]
        pub type Adc1enW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _Adc1enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc1enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Adc1enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIM1EN`" ]
        pub type Tim1enW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _Tim1enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim1enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim1enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SPI1EN`" ]
        pub type Spi1enW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _Spi1enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi1enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Spi1enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `USART1EN`" ]
        pub type Usart1enW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _Usart1enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart1enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Usart1enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIM15EN`" ]
        pub type Tim15enW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _Tim15enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim15enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim15enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIM16EN`" ]
        pub type Tim16enW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _Tim16enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim16enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim16enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIM17EN`" ]
        pub type Tim17enW = AfioenW;
        # [ doc = r" Proxy" ]
        pub struct _Tim17enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim17enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim17enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AfioenW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AfioenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Alternate function I/O clock enable" ]
            # [ inline ( always ) ]
            pub fn afioen(&self) -> AfioenR {
                AfioenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 0;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 2 - I/O port A clock enable" ]
            # [ inline ( always ) ]
            pub fn iopaen(&self) -> IopaenR {
                IopaenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 2;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 3 - I/O port B clock enable" ]
            # [ inline ( always ) ]
            pub fn iopben(&self) -> IopbenR {
                IopbenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 3;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 4 - I/O port C clock enable" ]
            # [ inline ( always ) ]
            pub fn iopcen(&self) -> IopcenR {
                IopcenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 4;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 5 - I/O port D clock enable" ]
            # [ inline ( always ) ]
            pub fn iopden(&self) -> IopdenR {
                IopdenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 5;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 6 - I/O port E clock enable" ]
            # [ inline ( always ) ]
            pub fn iopeen(&self) -> IopeenR {
                IopeenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 6;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 7 - I/O port F clock enable" ]
            # [ inline ( always ) ]
            pub fn iopfen(&self) -> IopfenR {
                IopfenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 8 - I/O port G clock enable" ]
            # [ inline ( always ) ]
            pub fn iopgen(&self) -> IopgenR {
                IopgenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 8;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 9 - ADC 1 interface clock enable" ]
            # [ inline ( always ) ]
            pub fn adc1en(&self) -> Adc1enR {
                Adc1enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 9;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 11 - TIM1 Timer clock enable" ]
            # [ inline ( always ) ]
            pub fn tim1en(&self) -> Tim1enR {
                Tim1enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 11;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 12 - SPI 1 clock enable" ]
            # [ inline ( always ) ]
            pub fn spi1en(&self) -> Spi1enR {
                Spi1enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 12;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 14 - USART1 clock enable" ]
            # [ inline ( always ) ]
            pub fn usart1en(&self) -> Usart1enR {
                Usart1enR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 14;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            # [ doc = "Bit 16 - TIM15 Timer clock enable" ]
            # [ inline ( always ) ]
            pub fn tim15en(&self) -> Tim15enR {
                Tim15enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 16;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            # [ doc = "Bit 17 - TIM16 Timer clock enable" ]
            # [ inline ( always ) ]
            pub fn tim16en(&self) -> Tim16enR {
                Tim16enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 17;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            # [ doc = "Bit 18 - TIM17 Timer clock enable" ]
            # [ inline ( always ) ]
            pub fn tim17en(&self) -> Tim17enR {
                Tim17enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 18;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Alternate function I/O clock enable" ]
            # [ inline ( always ) ]
            pub fn afioen(&mut self) -> _AfioenW {
                _AfioenW { w: self }
            }
            # [ doc = "Bit 2 - I/O port A clock enable" ]
            # [ inline ( always ) ]
            pub fn iopaen(&mut self) -> _IopaenW {
                _IopaenW { w: self }
            }
            # [ doc = "Bit 3 - I/O port B clock enable" ]
            # [ inline ( always ) ]
            pub fn iopben(&mut self) -> _IopbenW {
                _IopbenW { w: self }
            }
            # [ doc = "Bit 4 - I/O port C clock enable" ]
            # [ inline ( always ) ]
            pub fn iopcen(&mut self) -> _IopcenW {
                _IopcenW { w: self }
            }
            # [ doc = "Bit 5 - I/O port D clock enable" ]
            # [ inline ( always ) ]
            pub fn iopden(&mut self) -> _IopdenW {
                _IopdenW { w: self }
            }
            # [ doc = "Bit 6 - I/O port E clock enable" ]
            # [ inline ( always ) ]
            pub fn iopeen(&mut self) -> _IopeenW {
                _IopeenW { w: self }
            }
            # [ doc = "Bit 7 - I/O port F clock enable" ]
            # [ inline ( always ) ]
            pub fn iopfen(&mut self) -> _IopfenW {
                _IopfenW { w: self }
            }
            # [ doc = "Bit 8 - I/O port G clock enable" ]
            # [ inline ( always ) ]
            pub fn iopgen(&mut self) -> _IopgenW {
                _IopgenW { w: self }
            }
            # [ doc = "Bit 9 - ADC 1 interface clock enable" ]
            # [ inline ( always ) ]
            pub fn adc1en(&mut self) -> _Adc1enW {
                _Adc1enW { w: self }
            }
            # [ doc = "Bit 11 - TIM1 Timer clock enable" ]
            # [ inline ( always ) ]
            pub fn tim1en(&mut self) -> _Tim1enW {
                _Tim1enW { w: self }
            }
            # [ doc = "Bit 12 - SPI 1 clock enable" ]
            # [ inline ( always ) ]
            pub fn spi1en(&mut self) -> _Spi1enW {
                _Spi1enW { w: self }
            }
            # [ doc = "Bit 14 - USART1 clock enable" ]
            # [ inline ( always ) ]
            pub fn usart1en(&mut self) -> _Usart1enW {
                _Usart1enW { w: self }
            }
            # [ doc = "Bit 16 - TIM15 Timer clock enable" ]
            # [ inline ( always ) ]
            pub fn tim15en(&mut self) -> _Tim15enW {
                _Tim15enW { w: self }
            }
            # [ doc = "Bit 17 - TIM16 Timer clock enable" ]
            # [ inline ( always ) ]
            pub fn tim16en(&mut self) -> _Tim16enW {
                _Tim16enW { w: self }
            }
            # [ doc = "Bit 18 - TIM17 Timer clock enable" ]
            # [ inline ( always ) ]
            pub fn tim17en(&mut self) -> _Tim17enW {
                _Tim17enW { w: self }
            }
        }
    }
    # [ doc = "APB1 peripheral clock enable register (RCC_APB1ENR)" ]
    pub struct Apb1enr {
        register: VolatileCell<u32>,
    }
    # [ doc = "APB1 peripheral clock enable register (RCC_APB1ENR)" ]
    pub mod apb1enr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Apb1enr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TIM2EN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Tim2enR {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Tim2enR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim2enR::Disabled => 0,
                    Tim2enR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Tim2enR {
                match bits {
                    0 => Tim2enR::Disabled,
                    1 => Tim2enR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Tim2enR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Tim2enR::Enabled
            }
        }
        # [ doc = "Possible values of the field `TIM3EN`" ]
        pub type Tim3enR = Tim2enR;
        # [ doc = "Possible values of the field `TIM4EN`" ]
        pub type Tim4enR = Tim2enR;
        # [ doc = "Possible values of the field `TIM5EN`" ]
        pub type Tim5enR = Tim2enR;
        # [ doc = "Possible values of the field `TIM6EN`" ]
        pub type Tim6enR = Tim2enR;
        # [ doc = "Possible values of the field `TIM7EN`" ]
        pub type Tim7enR = Tim2enR;
        # [ doc = "Possible values of the field `TIM12EN`" ]
        pub type Tim12enR = Tim2enR;
        # [ doc = "Possible values of the field `TIM13EN`" ]
        pub type Tim13enR = Tim2enR;
        # [ doc = "Possible values of the field `TIM14EN`" ]
        pub type Tim14enR = Tim2enR;
        # [ doc = "Possible values of the field `WWDGEN`" ]
        pub type WwdgenR = Tim2enR;
        # [ doc = "Possible values of the field `SPI2EN`" ]
        pub type Spi2enR = Tim2enR;
        # [ doc = "Possible values of the field `SPI3EN`" ]
        pub type Spi3enR = Tim2enR;
        # [ doc = "Possible values of the field `USART2EN`" ]
        pub type Usart2enR = Tim2enR;
        # [ doc = "Possible values of the field `USART3EN`" ]
        pub type Usart3enR = Tim2enR;
        # [ doc = "Possible values of the field `UART4EN`" ]
        pub type Uart4enR = Tim2enR;
        # [ doc = "Possible values of the field `UART5EN`" ]
        pub type Uart5enR = Tim2enR;
        # [ doc = "Possible values of the field `I2C1EN`" ]
        pub type I2c1enR = Tim2enR;
        # [ doc = "Possible values of the field `I2C2EN`" ]
        pub type I2c2enR = Tim2enR;
        # [ doc = "Possible values of the field `BKPEN`" ]
        pub type BkpenR = Tim2enR;
        # [ doc = "Possible values of the field `PWREN`" ]
        pub type PwrenR = Tim2enR;
        # [ doc = "Possible values of the field `DACEN`" ]
        pub type DacenR = Tim2enR;
        # [ doc = "Possible values of the field `CECEN`" ]
        pub type CecenR = Tim2enR;
        # [ doc = "Values that can be written to the field `TIM2EN`" ]
        pub enum Tim2enW {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Tim2enW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim2enW::Disabled => 0,
                    Tim2enW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim2enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim2enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim2enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIM3EN`" ]
        pub type Tim3enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Tim3enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim3enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim3enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIM4EN`" ]
        pub type Tim4enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Tim4enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim4enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim4enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIM5EN`" ]
        pub type Tim5enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Tim5enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim5enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim5enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIM6EN`" ]
        pub type Tim6enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Tim6enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim6enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim6enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIM7EN`" ]
        pub type Tim7enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Tim7enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim7enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim7enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIM12EN`" ]
        pub type Tim12enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Tim12enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim12enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim12enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIM13EN`" ]
        pub type Tim13enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Tim13enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim13enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim13enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TIM14EN`" ]
        pub type Tim14enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Tim14enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim14enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tim14enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `WWDGEN`" ]
        pub type WwdgenW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _WwdgenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WwdgenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: WwdgenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SPI2EN`" ]
        pub type Spi2enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Spi2enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi2enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Spi2enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SPI3EN`" ]
        pub type Spi3enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Spi3enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi3enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Spi3enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `USART2EN`" ]
        pub type Usart2enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Usart2enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart2enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Usart2enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `USART3EN`" ]
        pub type Usart3enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Usart3enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart3enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Usart3enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UART4EN`" ]
        pub type Uart4enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Uart4enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Uart4enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Uart4enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UART5EN`" ]
        pub type Uart5enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _Uart5enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Uart5enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Uart5enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `I2C1EN`" ]
        pub type I2c1enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _I2c1enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2c1enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: I2c1enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `I2C2EN`" ]
        pub type I2c2enW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _I2c2enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2c2enW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: I2c2enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BKPEN`" ]
        pub type BkpenW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _BkpenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: BkpenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `PWREN`" ]
        pub type PwrenW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _PwrenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PwrenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PwrenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DACEN`" ]
        pub type DacenW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _DacenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DacenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DacenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CECEN`" ]
        pub type CecenW = Tim2enW;
        # [ doc = r" Proxy" ]
        pub struct _CecenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CecenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CecenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Timer 2 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim2en(&self) -> Tim2enR {
                Tim2enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 0;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 1 - Timer 3 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim3en(&self) -> Tim3enR {
                Tim3enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 1;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 2 - Timer 4 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim4en(&self) -> Tim4enR {
                Tim4enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 2;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 3 - Timer 5 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim5en(&self) -> Tim5enR {
                Tim5enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 3;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 4 - Timer 6 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim6en(&self) -> Tim6enR {
                Tim6enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 4;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 5 - Timer 7 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim7en(&self) -> Tim7enR {
                Tim7enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 5;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 6 - Timer 12 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim12en(&self) -> Tim12enR {
                Tim12enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 6;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            # [ doc = "Bit 7 - Timer 13 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim13en(&self) -> Tim13enR {
                Tim13enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 7;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            # [ doc = "Bit 8 - Timer 14 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim14en(&self) -> Tim14enR {
                Tim14enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 8;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            # [ doc = "Bit 11 - Window watchdog clock enable" ]
            # [ inline ( always ) ]
            pub fn wwdgen(&self) -> WwdgenR {
                WwdgenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 11;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 14 - SPI 2 clock enable" ]
            # [ inline ( always ) ]
            pub fn spi2en(&self) -> Spi2enR {
                Spi2enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 14;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 15 - SPI 3 clock enable" ]
            # [ inline ( always ) ]
            pub fn spi3en(&self) -> Spi3enR {
                Spi3enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 15;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 17 - USART 2 clock enable" ]
            # [ inline ( always ) ]
            pub fn usart2en(&self) -> Usart2enR {
                Usart2enR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 17;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            # [ doc = "Bit 18 - USART 3 clock enable" ]
            # [ inline ( always ) ]
            pub fn usart3en(&self) -> Usart3enR {
                Usart3enR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 18;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            # [ doc = "Bit 19 - UART 4 clock enable" ]
            # [ inline ( always ) ]
            pub fn uart4en(&self) -> Uart4enR {
                Uart4enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 19;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            # [ doc = "Bit 20 - UART 5 clock enable" ]
            # [ inline ( always ) ]
            pub fn uart5en(&self) -> Uart5enR {
                Uart5enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 20;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            # [ doc = "Bit 21 - I2C 1 clock enable" ]
            # [ inline ( always ) ]
            pub fn i2c1en(&self) -> I2c1enR {
                I2c1enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 21;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 22 - I2C 2 clock enable" ]
            # [ inline ( always ) ]
            pub fn i2c2en(&self) -> I2c2enR {
                I2c2enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 22;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bit 27 - Backup interface clock enable" ]
            # [ inline ( always ) ]
            pub fn bkpen(&self) -> BkpenR {
                BkpenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 27;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bit 28 - Power interface clock enable" ]
            # [ inline ( always ) ]
            pub fn pwren(&self) -> PwrenR {
                PwrenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 28;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bit 29 - DAC interface clock enable" ]
            # [ inline ( always ) ]
            pub fn dacen(&self) -> DacenR {
                DacenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 29;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bit 30 - CEC clock enable" ]
            # [ inline ( always ) ]
            pub fn cecen(&self) -> CecenR {
                CecenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 30;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Timer 2 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim2en(&mut self) -> _Tim2enW {
                _Tim2enW { w: self }
            }
            # [ doc = "Bit 1 - Timer 3 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim3en(&mut self) -> _Tim3enW {
                _Tim3enW { w: self }
            }
            # [ doc = "Bit 2 - Timer 4 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim4en(&mut self) -> _Tim4enW {
                _Tim4enW { w: self }
            }
            # [ doc = "Bit 3 - Timer 5 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim5en(&mut self) -> _Tim5enW {
                _Tim5enW { w: self }
            }
            # [ doc = "Bit 4 - Timer 6 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim6en(&mut self) -> _Tim6enW {
                _Tim6enW { w: self }
            }
            # [ doc = "Bit 5 - Timer 7 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim7en(&mut self) -> _Tim7enW {
                _Tim7enW { w: self }
            }
            # [ doc = "Bit 6 - Timer 12 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim12en(&mut self) -> _Tim12enW {
                _Tim12enW { w: self }
            }
            # [ doc = "Bit 7 - Timer 13 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim13en(&mut self) -> _Tim13enW {
                _Tim13enW { w: self }
            }
            # [ doc = "Bit 8 - Timer 14 clock enable" ]
            # [ inline ( always ) ]
            pub fn tim14en(&mut self) -> _Tim14enW {
                _Tim14enW { w: self }
            }
            # [ doc = "Bit 11 - Window watchdog clock enable" ]
            # [ inline ( always ) ]
            pub fn wwdgen(&mut self) -> _WwdgenW {
                _WwdgenW { w: self }
            }
            # [ doc = "Bit 14 - SPI 2 clock enable" ]
            # [ inline ( always ) ]
            pub fn spi2en(&mut self) -> _Spi2enW {
                _Spi2enW { w: self }
            }
            # [ doc = "Bit 15 - SPI 3 clock enable" ]
            # [ inline ( always ) ]
            pub fn spi3en(&mut self) -> _Spi3enW {
                _Spi3enW { w: self }
            }
            # [ doc = "Bit 17 - USART 2 clock enable" ]
            # [ inline ( always ) ]
            pub fn usart2en(&mut self) -> _Usart2enW {
                _Usart2enW { w: self }
            }
            # [ doc = "Bit 18 - USART 3 clock enable" ]
            # [ inline ( always ) ]
            pub fn usart3en(&mut self) -> _Usart3enW {
                _Usart3enW { w: self }
            }
            # [ doc = "Bit 19 - UART 4 clock enable" ]
            # [ inline ( always ) ]
            pub fn uart4en(&mut self) -> _Uart4enW {
                _Uart4enW { w: self }
            }
            # [ doc = "Bit 20 - UART 5 clock enable" ]
            # [ inline ( always ) ]
            pub fn uart5en(&mut self) -> _Uart5enW {
                _Uart5enW { w: self }
            }
            # [ doc = "Bit 21 - I2C 1 clock enable" ]
            # [ inline ( always ) ]
            pub fn i2c1en(&mut self) -> _I2c1enW {
                _I2c1enW { w: self }
            }
            # [ doc = "Bit 22 - I2C 2 clock enable" ]
            # [ inline ( always ) ]
            pub fn i2c2en(&mut self) -> _I2c2enW {
                _I2c2enW { w: self }
            }
            # [ doc = "Bit 27 - Backup interface clock enable" ]
            # [ inline ( always ) ]
            pub fn bkpen(&mut self) -> _BkpenW {
                _BkpenW { w: self }
            }
            # [ doc = "Bit 28 - Power interface clock enable" ]
            # [ inline ( always ) ]
            pub fn pwren(&mut self) -> _PwrenW {
                _PwrenW { w: self }
            }
            # [ doc = "Bit 29 - DAC interface clock enable" ]
            # [ inline ( always ) ]
            pub fn dacen(&mut self) -> _DacenW {
                _DacenW { w: self }
            }
            # [ doc = "Bit 30 - CEC clock enable" ]
            # [ inline ( always ) ]
            pub fn cecen(&mut self) -> _CecenW {
                _CecenW { w: self }
            }
        }
    }
    # [ doc = "Backup domain control register (RCC_BDCR)" ]
    pub struct Bdcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup domain control register (RCC_BDCR)" ]
    pub mod bdcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bdcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LseonR {
            bits: u8,
        }
        impl LseonR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LserdyR {
            bits: u8,
        }
        impl LserdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LsebypR {
            bits: u8,
        }
        impl LsebypR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcselR {
            bits: u8,
        }
        impl RtcselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcenR {
            bits: u8,
        }
        impl RtcenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BdrstR {
            bits: u8,
        }
        impl BdrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LseonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LseonW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LsebypW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LsebypW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcselW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BdrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BdrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - External Low Speed oscillator enable" ]
            # [ inline ( always ) ]
            pub fn lseon(&self) -> LseonR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LseonR { bits }
            }
            # [ doc = "Bit 1 - External Low Speed oscillator ready" ]
            # [ inline ( always ) ]
            pub fn lserdy(&self) -> LserdyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LserdyR { bits }
            }
            # [ doc = "Bit 2 - External Low Speed oscillator bypass" ]
            # [ inline ( always ) ]
            pub fn lsebyp(&self) -> LsebypR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LsebypR { bits }
            }
            # [ doc = "Bits 8:9 - RTC clock source selection" ]
            # [ inline ( always ) ]
            pub fn rtcsel(&self) -> RtcselR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RtcselR { bits }
            }
            # [ doc = "Bit 15 - RTC clock enable" ]
            # [ inline ( always ) ]
            pub fn rtcen(&self) -> RtcenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RtcenR { bits }
            }
            # [ doc = "Bit 16 - Backup domain software reset" ]
            # [ inline ( always ) ]
            pub fn bdrst(&self) -> BdrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BdrstR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - External Low Speed oscillator enable" ]
            # [ inline ( always ) ]
            pub fn lseon(&mut self) -> _LseonW {
                _LseonW { w: self }
            }
            # [ doc = "Bit 2 - External Low Speed oscillator bypass" ]
            # [ inline ( always ) ]
            pub fn lsebyp(&mut self) -> _LsebypW {
                _LsebypW { w: self }
            }
            # [ doc = "Bits 8:9 - RTC clock source selection" ]
            # [ inline ( always ) ]
            pub fn rtcsel(&mut self) -> _RtcselW {
                _RtcselW { w: self }
            }
            # [ doc = "Bit 15 - RTC clock enable" ]
            # [ inline ( always ) ]
            pub fn rtcen(&mut self) -> _RtcenW {
                _RtcenW { w: self }
            }
            # [ doc = "Bit 16 - Backup domain software reset" ]
            # [ inline ( always ) ]
            pub fn bdrst(&mut self) -> _BdrstW {
                _BdrstW { w: self }
            }
        }
    }
    # [ doc = "Control/status register (RCC_CSR)" ]
    pub struct Csr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control/status register (RCC_CSR)" ]
    pub mod csr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Csr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LsionR {
            bits: u8,
        }
        impl LsionR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LsirdyR {
            bits: u8,
        }
        impl LsirdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RmvfR {
            bits: u8,
        }
        impl RmvfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PinrstfR {
            bits: u8,
        }
        impl PinrstfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PorrstfR {
            bits: u8,
        }
        impl PorrstfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SftrstfR {
            bits: u8,
        }
        impl SftrstfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IwdgrstfR {
            bits: u8,
        }
        impl IwdgrstfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WwdgrstfR {
            bits: u8,
        }
        impl WwdgrstfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LpwrrstfR {
            bits: u8,
        }
        impl LpwrrstfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LsionW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LsionW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RmvfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RmvfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PinrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PinrstfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PorrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PorrstfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SftrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SftrstfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IwdgrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IwdgrstfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WwdgrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WwdgrstfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LpwrrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LpwrrstfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Internal low speed oscillator enable" ]
            # [ inline ( always ) ]
            pub fn lsion(&self) -> LsionR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LsionR { bits }
            }
            # [ doc = "Bit 1 - Internal low speed oscillator ready" ]
            # [ inline ( always ) ]
            pub fn lsirdy(&self) -> LsirdyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LsirdyR { bits }
            }
            # [ doc = "Bit 24 - Remove reset flag" ]
            # [ inline ( always ) ]
            pub fn rmvf(&self) -> RmvfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RmvfR { bits }
            }
            # [ doc = "Bit 26 - PIN reset flag" ]
            # [ inline ( always ) ]
            pub fn pinrstf(&self) -> PinrstfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PinrstfR { bits }
            }
            # [ doc = "Bit 27 - POR/PDR reset flag" ]
            # [ inline ( always ) ]
            pub fn porrstf(&self) -> PorrstfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PorrstfR { bits }
            }
            # [ doc = "Bit 28 - Software reset flag" ]
            # [ inline ( always ) ]
            pub fn sftrstf(&self) -> SftrstfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SftrstfR { bits }
            }
            # [ doc = "Bit 29 - Independent watchdog reset flag" ]
            # [ inline ( always ) ]
            pub fn iwdgrstf(&self) -> IwdgrstfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IwdgrstfR { bits }
            }
            # [ doc = "Bit 30 - Window watchdog reset flag" ]
            # [ inline ( always ) ]
            pub fn wwdgrstf(&self) -> WwdgrstfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WwdgrstfR { bits }
            }
            # [ doc = "Bit 31 - Low-power reset flag" ]
            # [ inline ( always ) ]
            pub fn lpwrrstf(&self) -> LpwrrstfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LpwrrstfR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 201326592 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Internal low speed oscillator enable" ]
            # [ inline ( always ) ]
            pub fn lsion(&mut self) -> _LsionW {
                _LsionW { w: self }
            }
            # [ doc = "Bit 24 - Remove reset flag" ]
            # [ inline ( always ) ]
            pub fn rmvf(&mut self) -> _RmvfW {
                _RmvfW { w: self }
            }
            # [ doc = "Bit 26 - PIN reset flag" ]
            # [ inline ( always ) ]
            pub fn pinrstf(&mut self) -> _PinrstfW {
                _PinrstfW { w: self }
            }
            # [ doc = "Bit 27 - POR/PDR reset flag" ]
            # [ inline ( always ) ]
            pub fn porrstf(&mut self) -> _PorrstfW {
                _PorrstfW { w: self }
            }
            # [ doc = "Bit 28 - Software reset flag" ]
            # [ inline ( always ) ]
            pub fn sftrstf(&mut self) -> _SftrstfW {
                _SftrstfW { w: self }
            }
            # [ doc = "Bit 29 - Independent watchdog reset flag" ]
            # [ inline ( always ) ]
            pub fn iwdgrstf(&mut self) -> _IwdgrstfW {
                _IwdgrstfW { w: self }
            }
            # [ doc = "Bit 30 - Window watchdog reset flag" ]
            # [ inline ( always ) ]
            pub fn wwdgrstf(&mut self) -> _WwdgrstfW {
                _WwdgrstfW { w: self }
            }
            # [ doc = "Bit 31 - Low-power reset flag" ]
            # [ inline ( always ) ]
            pub fn lpwrrstf(&mut self) -> _LpwrrstfW {
                _LpwrrstfW { w: self }
            }
        }
    }
    # [ doc = "Clock configuration register 2" ]
    pub struct Cfgr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Clock configuration register 2" ]
    pub mod cfgr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cfgr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Prediv1R {
            bits: u8,
        }
        impl Prediv1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Prediv1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Prediv1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - PREDIV1 division factor" ]
            # [ inline ( always ) ]
            pub fn prediv1(&self) -> Prediv1R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Prediv1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - PREDIV1 division factor" ]
            # [ inline ( always ) ]
            pub fn prediv1(&mut self) -> _Prediv1W {
                _Prediv1W { w: self }
            }
        }
    }
}
# [ doc = "Reset and clock control" ]
pub struct Rcc {
    register_block: rcc::RegisterBlock,
}
impl Deref for Rcc {
    type Target = rcc::RegisterBlock;
    fn deref(&self) -> &rcc::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "General purpose I/O" ]
pub const GPIOA: Peripheral<Gpioa> = unsafe { Peripheral::new(1073809408) };
# [ doc = "General purpose I/O" ]
pub mod gpioa {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Port configuration register low (GPIOn_CRL)" ]
        pub crl: Crl,
        # [ doc = "0x04 - Port configuration register high (GPIOn_CRL)" ]
        pub crh: Crh,
        # [ doc = "0x08 - Port input data register (GPIOn_IDR)" ]
        pub idr: Idr,
        # [ doc = "0x0c - Port output data register (GPIOn_ODR)" ]
        pub odr: Odr,
        # [ doc = "0x10 - Port bit set/reset register (GPIOn_BSRR)" ]
        pub bsrr: Bsrr,
        # [ doc = "0x14 - Port bit reset register (GPIOn_BRR)" ]
        pub brr: Brr,
        # [ doc = "0x18 - Port configuration lock register" ]
        pub lckr: Lckr,
    }
    # [ doc = "Port configuration register low (GPIOn_CRL)" ]
    pub struct Crl {
        register: VolatileCell<u32>,
    }
    # [ doc = "Port configuration register low (GPIOn_CRL)" ]
    pub mod crl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Crl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `MODE0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Mode0R {
            # [ doc = "Input mode (reset state)" ]
            Input,
            # [ doc = "Output mode, max speed 10MHz" ]
            Output10mhz,
            # [ doc = "Output mode, max speed 2MHz" ]
            Output2mhz,
            # [ doc = "Output mode, max speed 50MHz" ]
            Output50mhz,
        }
        impl Mode0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Mode0R::Input => 0,
                    Mode0R::Output10mhz => 1,
                    Mode0R::Output2mhz => 2,
                    Mode0R::Output50mhz => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Mode0R {
                match bits {
                    0 => Mode0R::Input,
                    1 => Mode0R::Output10mhz,
                    2 => Mode0R::Output2mhz,
                    3 => Mode0R::Output50mhz,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Mode0R::Input
            }
            # [ doc = "Checks if the value of the field is `Output10mhz`" ]
            # [ inline ( always ) ]
            pub fn is_output_10mhz(&self) -> bool {
                *self == Mode0R::Output10mhz
            }
            # [ doc = "Checks if the value of the field is `Output2mhz`" ]
            # [ inline ( always ) ]
            pub fn is_output_2mhz(&self) -> bool {
                *self == Mode0R::Output2mhz
            }
            # [ doc = "Checks if the value of the field is `Output50mhz`" ]
            # [ inline ( always ) ]
            pub fn is_output_50mhz(&self) -> bool {
                *self == Mode0R::Output50mhz
            }
        }
        # [ doc = "Possible values of the field `CNF0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Cnf0R {
            # [ doc = "Push-Pull" ]
            PushPull,
            # [ doc = "Open-Drain (reset state)" ]
            OpenDrain,
            # [ doc = "Alternate Function Push-Pull" ]
            AltPushPull,
            # [ doc = "Alternate Function Open-Drain" ]
            AltOpenDrain,
        }
        impl Cnf0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Cnf0R::PushPull => 0,
                    Cnf0R::OpenDrain => 1,
                    Cnf0R::AltPushPull => 2,
                    Cnf0R::AltOpenDrain => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Cnf0R {
                match bits {
                    0 => Cnf0R::PushPull,
                    1 => Cnf0R::OpenDrain,
                    2 => Cnf0R::AltPushPull,
                    3 => Cnf0R::AltOpenDrain,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `PushPull`" ]
            # [ inline ( always ) ]
            pub fn is_push_pull(&self) -> bool {
                *self == Cnf0R::PushPull
            }
            # [ doc = "Checks if the value of the field is `OpenDrain`" ]
            # [ inline ( always ) ]
            pub fn is_open_drain(&self) -> bool {
                *self == Cnf0R::OpenDrain
            }
            # [ doc = "Checks if the value of the field is `AltPushPull`" ]
            # [ inline ( always ) ]
            pub fn is_alt_push_pull(&self) -> bool {
                *self == Cnf0R::AltPushPull
            }
            # [ doc = "Checks if the value of the field is `AltOpenDrain`" ]
            # [ inline ( always ) ]
            pub fn is_alt_open_drain(&self) -> bool {
                *self == Cnf0R::AltOpenDrain
            }
        }
        # [ doc = "Possible values of the field `MODE1`" ]
        pub type Mode1R = Mode0R;
        # [ doc = "Possible values of the field `CNF1`" ]
        pub type Cnf1R = Cnf0R;
        # [ doc = "Possible values of the field `MODE2`" ]
        pub type Mode2R = Mode0R;
        # [ doc = "Possible values of the field `CNF2`" ]
        pub type Cnf2R = Cnf0R;
        # [ doc = "Possible values of the field `MODE3`" ]
        pub type Mode3R = Mode0R;
        # [ doc = "Possible values of the field `CNF3`" ]
        pub type Cnf3R = Cnf0R;
        # [ doc = "Possible values of the field `MODE4`" ]
        pub type Mode4R = Mode0R;
        # [ doc = "Possible values of the field `CNF4`" ]
        pub type Cnf4R = Cnf0R;
        # [ doc = "Possible values of the field `MODE5`" ]
        pub type Mode5R = Mode0R;
        # [ doc = "Possible values of the field `CNF5`" ]
        pub type Cnf5R = Cnf0R;
        # [ doc = "Possible values of the field `MODE6`" ]
        pub type Mode6R = Mode0R;
        # [ doc = "Possible values of the field `CNF6`" ]
        pub type Cnf6R = Cnf0R;
        # [ doc = "Possible values of the field `MODE7`" ]
        pub type Mode7R = Mode0R;
        # [ doc = "Possible values of the field `CNF7`" ]
        pub type Cnf7R = Cnf0R;
        # [ doc = "Values that can be written to the field `MODE0`" ]
        pub enum Mode0W {
            # [ doc = "Input mode (reset state)" ]
            Input,
            # [ doc = "Output mode, max speed 10MHz" ]
            Output10mhz,
            # [ doc = "Output mode, max speed 2MHz" ]
            Output2mhz,
            # [ doc = "Output mode, max speed 50MHz" ]
            Output50mhz,
        }
        impl Mode0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Mode0W::Input => 0,
                    Mode0W::Output10mhz => 1,
                    Mode0W::Output2mhz => 2,
                    Mode0W::Output50mhz => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mode0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode0W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF0`" ]
        pub enum Cnf0W {
            # [ doc = "Push-Pull" ]
            PushPull,
            # [ doc = "Open-Drain (reset state)" ]
            OpenDrain,
            # [ doc = "Alternate Function Push-Pull" ]
            AltPushPull,
            # [ doc = "Alternate Function Open-Drain" ]
            AltOpenDrain,
        }
        impl Cnf0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Cnf0W::PushPull => 0,
                    Cnf0W::OpenDrain => 1,
                    Cnf0W::AltPushPull => 2,
                    Cnf0W::AltOpenDrain => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cnf0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE1`" ]
        pub type Mode1W = Mode0W;
        # [ doc = r" Proxy" ]
        pub struct _Mode1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode0W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF1`" ]
        pub type Cnf1W = Cnf0W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE2`" ]
        pub type Mode2W = Mode0W;
        # [ doc = r" Proxy" ]
        pub struct _Mode2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode0W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF2`" ]
        pub type Cnf2W = Cnf0W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE3`" ]
        pub type Mode3W = Mode0W;
        # [ doc = r" Proxy" ]
        pub struct _Mode3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode0W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF3`" ]
        pub type Cnf3W = Cnf0W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE4`" ]
        pub type Mode4W = Mode0W;
        # [ doc = r" Proxy" ]
        pub struct _Mode4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode0W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF4`" ]
        pub type Cnf4W = Cnf0W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE5`" ]
        pub type Mode5W = Mode0W;
        # [ doc = r" Proxy" ]
        pub struct _Mode5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode0W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF5`" ]
        pub type Cnf5W = Cnf0W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE6`" ]
        pub type Mode6W = Mode0W;
        # [ doc = r" Proxy" ]
        pub struct _Mode6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode0W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF6`" ]
        pub type Cnf6W = Cnf0W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE7`" ]
        pub type Mode7W = Mode0W;
        # [ doc = r" Proxy" ]
        pub struct _Mode7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode0W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode0W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF7`" ]
        pub type Cnf7W = Cnf0W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf0W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf0W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Port n.0 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode0(&self) -> Mode0R {
                Mode0R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 0;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 2:3 - Port n.0 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf0(&self) -> Cnf0R {
                Cnf0R::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 2;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bits 4:5 - Port n.1 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode1(&self) -> Mode1R {
                Mode1R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 4;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 6:7 - Port n.1 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf1(&self) -> Cnf1R {
                Cnf1R::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 6;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bits 8:9 - Port n.2 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode2(&self) -> Mode2R {
                Mode2R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 8;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 10:11 - Port n.2 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf2(&self) -> Cnf2R {
                Cnf2R::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 10;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bits 12:13 - Port n.3 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode3(&self) -> Mode3R {
                Mode3R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 12;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 14:15 - Port n.3 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf3(&self) -> Cnf3R {
                Cnf3R::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 14;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bits 16:17 - Port n.4 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode4(&self) -> Mode4R {
                Mode4R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 16;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 18:19 - Port n.4 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf4(&self) -> Cnf4R {
                Cnf4R::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 18;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bits 20:21 - Port n.5 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode5(&self) -> Mode5R {
                Mode5R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 20;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 22:23 - Port n.5 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf5(&self) -> Cnf5R {
                Cnf5R::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 22;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bits 24:25 - Port n.6 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode6(&self) -> Mode6R {
                Mode6R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 24;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 26:27 - Port n.6 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf6(&self) -> Cnf6R {
                Cnf6R::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 26;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bits 28:29 - Port n.7 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode7(&self) -> Mode7R {
                Mode7R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 28;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 30:31 - Port n.7 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf7(&self) -> Cnf7R {
                Cnf7R::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 30;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 1145324612 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - Port n.0 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode0(&mut self) -> _Mode0W {
                _Mode0W { w: self }
            }
            # [ doc = "Bits 2:3 - Port n.0 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf0(&mut self) -> _Cnf0W {
                _Cnf0W { w: self }
            }
            # [ doc = "Bits 4:5 - Port n.1 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode1(&mut self) -> _Mode1W {
                _Mode1W { w: self }
            }
            # [ doc = "Bits 6:7 - Port n.1 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf1(&mut self) -> _Cnf1W {
                _Cnf1W { w: self }
            }
            # [ doc = "Bits 8:9 - Port n.2 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode2(&mut self) -> _Mode2W {
                _Mode2W { w: self }
            }
            # [ doc = "Bits 10:11 - Port n.2 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf2(&mut self) -> _Cnf2W {
                _Cnf2W { w: self }
            }
            # [ doc = "Bits 12:13 - Port n.3 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode3(&mut self) -> _Mode3W {
                _Mode3W { w: self }
            }
            # [ doc = "Bits 14:15 - Port n.3 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf3(&mut self) -> _Cnf3W {
                _Cnf3W { w: self }
            }
            # [ doc = "Bits 16:17 - Port n.4 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode4(&mut self) -> _Mode4W {
                _Mode4W { w: self }
            }
            # [ doc = "Bits 18:19 - Port n.4 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf4(&mut self) -> _Cnf4W {
                _Cnf4W { w: self }
            }
            # [ doc = "Bits 20:21 - Port n.5 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode5(&mut self) -> _Mode5W {
                _Mode5W { w: self }
            }
            # [ doc = "Bits 22:23 - Port n.5 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf5(&mut self) -> _Cnf5W {
                _Cnf5W { w: self }
            }
            # [ doc = "Bits 24:25 - Port n.6 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode6(&mut self) -> _Mode6W {
                _Mode6W { w: self }
            }
            # [ doc = "Bits 26:27 - Port n.6 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf6(&mut self) -> _Cnf6W {
                _Cnf6W { w: self }
            }
            # [ doc = "Bits 28:29 - Port n.7 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode7(&mut self) -> _Mode7W {
                _Mode7W { w: self }
            }
            # [ doc = "Bits 30:31 - Port n.7 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf7(&mut self) -> _Cnf7W {
                _Cnf7W { w: self }
            }
        }
    }
    # [ doc = "Port configuration register high (GPIOn_CRL)" ]
    pub struct Crh {
        register: VolatileCell<u32>,
    }
    # [ doc = "Port configuration register high (GPIOn_CRL)" ]
    pub mod crh {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Crh {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `MODE8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Mode8R {
            # [ doc = "Input mode (reset state)" ]
            Input,
            # [ doc = "Output mode, max speed 10MHz" ]
            Output10mhz,
            # [ doc = "Output mode, max speed 2MHz" ]
            Output2mhz,
            # [ doc = "Output mode, max speed 50MHz" ]
            Output50mhz,
        }
        impl Mode8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Mode8R::Input => 0,
                    Mode8R::Output10mhz => 1,
                    Mode8R::Output2mhz => 2,
                    Mode8R::Output50mhz => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Mode8R {
                match bits {
                    0 => Mode8R::Input,
                    1 => Mode8R::Output10mhz,
                    2 => Mode8R::Output2mhz,
                    3 => Mode8R::Output50mhz,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Input`" ]
            # [ inline ( always ) ]
            pub fn is_input(&self) -> bool {
                *self == Mode8R::Input
            }
            # [ doc = "Checks if the value of the field is `Output10mhz`" ]
            # [ inline ( always ) ]
            pub fn is_output_10mhz(&self) -> bool {
                *self == Mode8R::Output10mhz
            }
            # [ doc = "Checks if the value of the field is `Output2mhz`" ]
            # [ inline ( always ) ]
            pub fn is_output_2mhz(&self) -> bool {
                *self == Mode8R::Output2mhz
            }
            # [ doc = "Checks if the value of the field is `Output50mhz`" ]
            # [ inline ( always ) ]
            pub fn is_output_50mhz(&self) -> bool {
                *self == Mode8R::Output50mhz
            }
        }
        # [ doc = "Possible values of the field `CNF8`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Cnf8R {
            # [ doc = "Push-Pull" ]
            PushPull,
            # [ doc = "Open-Drain (reset state)" ]
            OpenDrain,
            # [ doc = "Alternate Function Push-Pull" ]
            AltPushPull,
            # [ doc = "Alternate Function Open-Drain" ]
            AltOpenDrain,
        }
        impl Cnf8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Cnf8R::PushPull => 0,
                    Cnf8R::OpenDrain => 1,
                    Cnf8R::AltPushPull => 2,
                    Cnf8R::AltOpenDrain => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Cnf8R {
                match bits {
                    0 => Cnf8R::PushPull,
                    1 => Cnf8R::OpenDrain,
                    2 => Cnf8R::AltPushPull,
                    3 => Cnf8R::AltOpenDrain,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `PushPull`" ]
            # [ inline ( always ) ]
            pub fn is_push_pull(&self) -> bool {
                *self == Cnf8R::PushPull
            }
            # [ doc = "Checks if the value of the field is `OpenDrain`" ]
            # [ inline ( always ) ]
            pub fn is_open_drain(&self) -> bool {
                *self == Cnf8R::OpenDrain
            }
            # [ doc = "Checks if the value of the field is `AltPushPull`" ]
            # [ inline ( always ) ]
            pub fn is_alt_push_pull(&self) -> bool {
                *self == Cnf8R::AltPushPull
            }
            # [ doc = "Checks if the value of the field is `AltOpenDrain`" ]
            # [ inline ( always ) ]
            pub fn is_alt_open_drain(&self) -> bool {
                *self == Cnf8R::AltOpenDrain
            }
        }
        # [ doc = "Possible values of the field `MODE9`" ]
        pub type Mode9R = Mode8R;
        # [ doc = "Possible values of the field `CNF9`" ]
        pub type Cnf9R = Cnf8R;
        # [ doc = "Possible values of the field `MODE10`" ]
        pub type Mode10R = Mode8R;
        # [ doc = "Possible values of the field `CNF10`" ]
        pub type Cnf10R = Cnf8R;
        # [ doc = "Possible values of the field `MODE11`" ]
        pub type Mode11R = Mode8R;
        # [ doc = "Possible values of the field `CNF11`" ]
        pub type Cnf11R = Cnf8R;
        # [ doc = "Possible values of the field `MODE12`" ]
        pub type Mode12R = Mode8R;
        # [ doc = "Possible values of the field `CNF12`" ]
        pub type Cnf12R = Cnf8R;
        # [ doc = "Possible values of the field `MODE13`" ]
        pub type Mode13R = Mode8R;
        # [ doc = "Possible values of the field `CNF13`" ]
        pub type Cnf13R = Cnf8R;
        # [ doc = "Possible values of the field `MODE14`" ]
        pub type Mode14R = Mode8R;
        # [ doc = "Possible values of the field `CNF14`" ]
        pub type Cnf14R = Cnf8R;
        # [ doc = "Possible values of the field `MODE15`" ]
        pub type Mode15R = Mode8R;
        # [ doc = "Possible values of the field `CNF15`" ]
        pub type Cnf15R = Cnf8R;
        # [ doc = "Values that can be written to the field `MODE8`" ]
        pub enum Mode8W {
            # [ doc = "Input mode (reset state)" ]
            Input,
            # [ doc = "Output mode, max speed 10MHz" ]
            Output10mhz,
            # [ doc = "Output mode, max speed 2MHz" ]
            Output2mhz,
            # [ doc = "Output mode, max speed 50MHz" ]
            Output50mhz,
        }
        impl Mode8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Mode8W::Input => 0,
                    Mode8W::Output10mhz => 1,
                    Mode8W::Output2mhz => 2,
                    Mode8W::Output50mhz => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mode8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode8W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF8`" ]
        pub enum Cnf8W {
            # [ doc = "Push-Pull" ]
            PushPull,
            # [ doc = "Open-Drain (reset state)" ]
            OpenDrain,
            # [ doc = "Alternate Function Push-Pull" ]
            AltPushPull,
            # [ doc = "Alternate Function Open-Drain" ]
            AltOpenDrain,
        }
        impl Cnf8W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Cnf8W::PushPull => 0,
                    Cnf8W::OpenDrain => 1,
                    Cnf8W::AltPushPull => 2,
                    Cnf8W::AltOpenDrain => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cnf8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE9`" ]
        pub type Mode9W = Mode8W;
        # [ doc = r" Proxy" ]
        pub struct _Mode9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode8W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF9`" ]
        pub type Cnf9W = Cnf8W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE10`" ]
        pub type Mode10W = Mode8W;
        # [ doc = r" Proxy" ]
        pub struct _Mode10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode8W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF10`" ]
        pub type Cnf10W = Cnf8W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE11`" ]
        pub type Mode11W = Mode8W;
        # [ doc = r" Proxy" ]
        pub struct _Mode11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode8W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF11`" ]
        pub type Cnf11W = Cnf8W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE12`" ]
        pub type Mode12W = Mode8W;
        # [ doc = r" Proxy" ]
        pub struct _Mode12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode8W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF12`" ]
        pub type Cnf12W = Cnf8W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE13`" ]
        pub type Mode13W = Mode8W;
        # [ doc = r" Proxy" ]
        pub struct _Mode13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode8W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF13`" ]
        pub type Cnf13W = Cnf8W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE14`" ]
        pub type Mode14W = Mode8W;
        # [ doc = r" Proxy" ]
        pub struct _Mode14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode8W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF14`" ]
        pub type Cnf14W = Cnf8W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MODE15`" ]
        pub type Mode15W = Mode8W;
        # [ doc = r" Proxy" ]
        pub struct _Mode15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mode15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mode15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Input mode (reset state)" ]
            # [ inline ( always ) ]
            pub fn input(self) -> &'a mut W {
                self.variant(Mode8W::Input)
            }
            # [ doc = "Output mode, max speed 10MHz" ]
            # [ inline ( always ) ]
            pub fn output_10mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output10mhz)
            }
            # [ doc = "Output mode, max speed 2MHz" ]
            # [ inline ( always ) ]
            pub fn output_2mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output2mhz)
            }
            # [ doc = "Output mode, max speed 50MHz" ]
            # [ inline ( always ) ]
            pub fn output_50mhz(self) -> &'a mut W {
                self.variant(Mode8W::Output50mhz)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CNF15`" ]
        pub type Cnf15W = Cnf8W;
        # [ doc = r" Proxy" ]
        pub struct _Cnf15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cnf15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cnf15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Push-Pull" ]
            # [ inline ( always ) ]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::PushPull)
            }
            # [ doc = "Open-Drain (reset state)" ]
            # [ inline ( always ) ]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::OpenDrain)
            }
            # [ doc = "Alternate Function Push-Pull" ]
            # [ inline ( always ) ]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(Cnf8W::AltPushPull)
            }
            # [ doc = "Alternate Function Open-Drain" ]
            # [ inline ( always ) ]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(Cnf8W::AltOpenDrain)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Port n.8 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode8(&self) -> Mode8R {
                Mode8R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 0;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 2:3 - Port n.8 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf8(&self) -> Cnf8R {
                Cnf8R::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 2;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bits 4:5 - Port n.9 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode9(&self) -> Mode9R {
                Mode9R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 4;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 6:7 - Port n.9 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf9(&self) -> Cnf9R {
                Cnf9R::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 6;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bits 8:9 - Port n.10 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode10(&self) -> Mode10R {
                Mode10R::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 8;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bits 10:11 - Port n.10 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf10(&self) -> Cnf10R {
                Cnf10R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 10;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 12:13 - Port n.11 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode11(&self) -> Mode11R {
                Mode11R::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 12;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bits 14:15 - Port n.11 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf11(&self) -> Cnf11R {
                Cnf11R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 14;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 16:17 - Port n.12 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode12(&self) -> Mode12R {
                Mode12R::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 16;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bits 18:19 - Port n.12 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf12(&self) -> Cnf12R {
                Cnf12R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 18;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 20:21 - Port n.13 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode13(&self) -> Mode13R {
                Mode13R::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 20;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bits 22:23 - Port n.13 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf13(&self) -> Cnf13R {
                Cnf13R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 22;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 24:25 - Port n.14 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode14(&self) -> Mode14R {
                Mode14R::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 24;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bits 26:27 - Port n.14 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf14(&self) -> Cnf14R {
                Cnf14R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 26;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            # [ doc = "Bits 28:29 - Port n.15 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode15(&self) -> Mode15R {
                Mode15R::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 28;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            # [ doc = "Bits 30:31 - Port n.15 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf15(&self) -> Cnf15R {
                Cnf15R::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 30;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 1145324612 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - Port n.8 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode8(&mut self) -> _Mode8W {
                _Mode8W { w: self }
            }
            # [ doc = "Bits 2:3 - Port n.8 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf8(&mut self) -> _Cnf8W {
                _Cnf8W { w: self }
            }
            # [ doc = "Bits 4:5 - Port n.9 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode9(&mut self) -> _Mode9W {
                _Mode9W { w: self }
            }
            # [ doc = "Bits 6:7 - Port n.9 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf9(&mut self) -> _Cnf9W {
                _Cnf9W { w: self }
            }
            # [ doc = "Bits 8:9 - Port n.10 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode10(&mut self) -> _Mode10W {
                _Mode10W { w: self }
            }
            # [ doc = "Bits 10:11 - Port n.10 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf10(&mut self) -> _Cnf10W {
                _Cnf10W { w: self }
            }
            # [ doc = "Bits 12:13 - Port n.11 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode11(&mut self) -> _Mode11W {
                _Mode11W { w: self }
            }
            # [ doc = "Bits 14:15 - Port n.11 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf11(&mut self) -> _Cnf11W {
                _Cnf11W { w: self }
            }
            # [ doc = "Bits 16:17 - Port n.12 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode12(&mut self) -> _Mode12W {
                _Mode12W { w: self }
            }
            # [ doc = "Bits 18:19 - Port n.12 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf12(&mut self) -> _Cnf12W {
                _Cnf12W { w: self }
            }
            # [ doc = "Bits 20:21 - Port n.13 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode13(&mut self) -> _Mode13W {
                _Mode13W { w: self }
            }
            # [ doc = "Bits 22:23 - Port n.13 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf13(&mut self) -> _Cnf13W {
                _Cnf13W { w: self }
            }
            # [ doc = "Bits 24:25 - Port n.14 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode14(&mut self) -> _Mode14W {
                _Mode14W { w: self }
            }
            # [ doc = "Bits 26:27 - Port n.14 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf14(&mut self) -> _Cnf14W {
                _Cnf14W { w: self }
            }
            # [ doc = "Bits 28:29 - Port n.15 mode bits" ]
            # [ inline ( always ) ]
            pub fn mode15(&mut self) -> _Mode15W {
                _Mode15W { w: self }
            }
            # [ doc = "Bits 30:31 - Port n.15 configuration bits" ]
            # [ inline ( always ) ]
            pub fn cnf15(&mut self) -> _Cnf15W {
                _Cnf15W { w: self }
            }
        }
    }
    # [ doc = "Port input data register (GPIOn_IDR)" ]
    pub struct Idr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Port input data register (GPIOn_IDR)" ]
    pub mod idr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Idr {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr0R {
            bits: u8,
        }
        impl Idr0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr1R {
            bits: u8,
        }
        impl Idr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr2R {
            bits: u8,
        }
        impl Idr2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr3R {
            bits: u8,
        }
        impl Idr3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr4R {
            bits: u8,
        }
        impl Idr4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr5R {
            bits: u8,
        }
        impl Idr5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr6R {
            bits: u8,
        }
        impl Idr6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr7R {
            bits: u8,
        }
        impl Idr7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr8R {
            bits: u8,
        }
        impl Idr8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr9R {
            bits: u8,
        }
        impl Idr9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr10R {
            bits: u8,
        }
        impl Idr10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr11R {
            bits: u8,
        }
        impl Idr11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr12R {
            bits: u8,
        }
        impl Idr12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr13R {
            bits: u8,
        }
        impl Idr13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr14R {
            bits: u8,
        }
        impl Idr14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Idr15R {
            bits: u8,
        }
        impl Idr15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr0(&self) -> Idr0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr0R { bits }
            }
            # [ doc = "Bit 1 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr1(&self) -> Idr1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr1R { bits }
            }
            # [ doc = "Bit 2 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr2(&self) -> Idr2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr2R { bits }
            }
            # [ doc = "Bit 3 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr3(&self) -> Idr3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr3R { bits }
            }
            # [ doc = "Bit 4 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr4(&self) -> Idr4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr4R { bits }
            }
            # [ doc = "Bit 5 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr5(&self) -> Idr5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr5R { bits }
            }
            # [ doc = "Bit 6 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr6(&self) -> Idr6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr6R { bits }
            }
            # [ doc = "Bit 7 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr7(&self) -> Idr7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr7R { bits }
            }
            # [ doc = "Bit 8 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr8(&self) -> Idr8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr8R { bits }
            }
            # [ doc = "Bit 9 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr9(&self) -> Idr9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr9R { bits }
            }
            # [ doc = "Bit 10 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr10(&self) -> Idr10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr10R { bits }
            }
            # [ doc = "Bit 11 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr11(&self) -> Idr11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr11R { bits }
            }
            # [ doc = "Bit 12 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr12(&self) -> Idr12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr12R { bits }
            }
            # [ doc = "Bit 13 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr13(&self) -> Idr13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr13R { bits }
            }
            # [ doc = "Bit 14 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr14(&self) -> Idr14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr14R { bits }
            }
            # [ doc = "Bit 15 - Port input data" ]
            # [ inline ( always ) ]
            pub fn idr15(&self) -> Idr15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr15R { bits }
            }
        }
    }
    # [ doc = "Port output data register (GPIOn_ODR)" ]
    pub struct Odr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Port output data register (GPIOn_ODR)" ]
    pub mod odr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Odr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr0R {
            bits: u8,
        }
        impl Odr0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr1R {
            bits: u8,
        }
        impl Odr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr2R {
            bits: u8,
        }
        impl Odr2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr3R {
            bits: u8,
        }
        impl Odr3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr4R {
            bits: u8,
        }
        impl Odr4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr5R {
            bits: u8,
        }
        impl Odr5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr6R {
            bits: u8,
        }
        impl Odr6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr7R {
            bits: u8,
        }
        impl Odr7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr8R {
            bits: u8,
        }
        impl Odr8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr9R {
            bits: u8,
        }
        impl Odr9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr10R {
            bits: u8,
        }
        impl Odr10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr11R {
            bits: u8,
        }
        impl Odr11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr12R {
            bits: u8,
        }
        impl Odr12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr13R {
            bits: u8,
        }
        impl Odr13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr14R {
            bits: u8,
        }
        impl Odr14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Odr15R {
            bits: u8,
        }
        impl Odr15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Odr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr0(&self) -> Odr0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr0R { bits }
            }
            # [ doc = "Bit 1 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr1(&self) -> Odr1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr1R { bits }
            }
            # [ doc = "Bit 2 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr2(&self) -> Odr2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr2R { bits }
            }
            # [ doc = "Bit 3 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr3(&self) -> Odr3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr3R { bits }
            }
            # [ doc = "Bit 4 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr4(&self) -> Odr4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr4R { bits }
            }
            # [ doc = "Bit 5 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr5(&self) -> Odr5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr5R { bits }
            }
            # [ doc = "Bit 6 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr6(&self) -> Odr6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr6R { bits }
            }
            # [ doc = "Bit 7 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr7(&self) -> Odr7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr7R { bits }
            }
            # [ doc = "Bit 8 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr8(&self) -> Odr8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr8R { bits }
            }
            # [ doc = "Bit 9 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr9(&self) -> Odr9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr9R { bits }
            }
            # [ doc = "Bit 10 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr10(&self) -> Odr10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr10R { bits }
            }
            # [ doc = "Bit 11 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr11(&self) -> Odr11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr11R { bits }
            }
            # [ doc = "Bit 12 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr12(&self) -> Odr12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr12R { bits }
            }
            # [ doc = "Bit 13 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr13(&self) -> Odr13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr13R { bits }
            }
            # [ doc = "Bit 14 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr14(&self) -> Odr14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr14R { bits }
            }
            # [ doc = "Bit 15 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr15(&self) -> Odr15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr0(&mut self) -> _Odr0W {
                _Odr0W { w: self }
            }
            # [ doc = "Bit 1 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr1(&mut self) -> _Odr1W {
                _Odr1W { w: self }
            }
            # [ doc = "Bit 2 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr2(&mut self) -> _Odr2W {
                _Odr2W { w: self }
            }
            # [ doc = "Bit 3 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr3(&mut self) -> _Odr3W {
                _Odr3W { w: self }
            }
            # [ doc = "Bit 4 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr4(&mut self) -> _Odr4W {
                _Odr4W { w: self }
            }
            # [ doc = "Bit 5 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr5(&mut self) -> _Odr5W {
                _Odr5W { w: self }
            }
            # [ doc = "Bit 6 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr6(&mut self) -> _Odr6W {
                _Odr6W { w: self }
            }
            # [ doc = "Bit 7 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr7(&mut self) -> _Odr7W {
                _Odr7W { w: self }
            }
            # [ doc = "Bit 8 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr8(&mut self) -> _Odr8W {
                _Odr8W { w: self }
            }
            # [ doc = "Bit 9 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr9(&mut self) -> _Odr9W {
                _Odr9W { w: self }
            }
            # [ doc = "Bit 10 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr10(&mut self) -> _Odr10W {
                _Odr10W { w: self }
            }
            # [ doc = "Bit 11 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr11(&mut self) -> _Odr11W {
                _Odr11W { w: self }
            }
            # [ doc = "Bit 12 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr12(&mut self) -> _Odr12W {
                _Odr12W { w: self }
            }
            # [ doc = "Bit 13 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr13(&mut self) -> _Odr13W {
                _Odr13W { w: self }
            }
            # [ doc = "Bit 14 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr14(&mut self) -> _Odr14W {
                _Odr14W { w: self }
            }
            # [ doc = "Bit 15 - Port output data" ]
            # [ inline ( always ) ]
            pub fn odr15(&mut self) -> _Odr15W {
                _Odr15W { w: self }
            }
        }
    }
    # [ doc = "Port bit set/reset register (GPIOn_BSRR)" ]
    pub struct Bsrr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Port bit set/reset register (GPIOn_BSRR)" ]
    pub mod bsrr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bsrr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Values that can be written to the field `BS0`" ]
        pub enum Bs0W {
            # [ doc = "Sets the corresponding ODRx bit" ]
            Set,
        }
        impl Bs0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Bs0W::Set => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Bs0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS1`" ]
        pub type Bs1W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS2`" ]
        pub type Bs2W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS3`" ]
        pub type Bs3W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS4`" ]
        pub type Bs4W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS5`" ]
        pub type Bs5W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS6`" ]
        pub type Bs6W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs6W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS7`" ]
        pub type Bs7W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs7W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS8`" ]
        pub type Bs8W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs8W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS9`" ]
        pub type Bs9W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs9W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS10`" ]
        pub type Bs10W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs10W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS11`" ]
        pub type Bs11W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs11W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS12`" ]
        pub type Bs12W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs12W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS13`" ]
        pub type Bs13W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs13W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS14`" ]
        pub type Bs14W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs14W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BS15`" ]
        pub type Bs15W = Bs0W;
        # [ doc = r" Proxy" ]
        pub struct _Bs15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Bs15W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Sets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn set(self) -> &'a mut W {
                self.variant(Bs0W::Set)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR0`" ]
        pub enum Br0W {
            # [ doc = "Resets the corresponding ODRx bit" ]
            Reset,
        }
        impl Br0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Br0W::Reset => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR1`" ]
        pub type Br1W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR2`" ]
        pub type Br2W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR3`" ]
        pub type Br3W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR4`" ]
        pub type Br4W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR5`" ]
        pub type Br5W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR6`" ]
        pub type Br6W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br6W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR7`" ]
        pub type Br7W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br7W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR8`" ]
        pub type Br8W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br8W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR9`" ]
        pub type Br9W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br9W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR10`" ]
        pub type Br10W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br10W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR11`" ]
        pub type Br11W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br11W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR12`" ]
        pub type Br12W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br12W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR13`" ]
        pub type Br13W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br13W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR14`" ]
        pub type Br14W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br14W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `BR15`" ]
        pub type Br15W = Br0W;
        # [ doc = r" Proxy" ]
        pub struct _Br15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Br15W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Resets the corresponding ODRx bit" ]
            # [ inline ( always ) ]
            pub fn reset(self) -> &'a mut W {
                self.variant(Br0W::Reset)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Set bit 0" ]
            # [ inline ( always ) ]
            pub fn bs0(&mut self) -> _Bs0W {
                _Bs0W { w: self }
            }
            # [ doc = "Bit 1 - Set bit 1" ]
            # [ inline ( always ) ]
            pub fn bs1(&mut self) -> _Bs1W {
                _Bs1W { w: self }
            }
            # [ doc = "Bit 2 - Set bit 2" ]
            # [ inline ( always ) ]
            pub fn bs2(&mut self) -> _Bs2W {
                _Bs2W { w: self }
            }
            # [ doc = "Bit 3 - Set bit 3" ]
            # [ inline ( always ) ]
            pub fn bs3(&mut self) -> _Bs3W {
                _Bs3W { w: self }
            }
            # [ doc = "Bit 4 - Set bit 4" ]
            # [ inline ( always ) ]
            pub fn bs4(&mut self) -> _Bs4W {
                _Bs4W { w: self }
            }
            # [ doc = "Bit 5 - Set bit 5" ]
            # [ inline ( always ) ]
            pub fn bs5(&mut self) -> _Bs5W {
                _Bs5W { w: self }
            }
            # [ doc = "Bit 6 - Set bit 6" ]
            # [ inline ( always ) ]
            pub fn bs6(&mut self) -> _Bs6W {
                _Bs6W { w: self }
            }
            # [ doc = "Bit 7 - Set bit 7" ]
            # [ inline ( always ) ]
            pub fn bs7(&mut self) -> _Bs7W {
                _Bs7W { w: self }
            }
            # [ doc = "Bit 8 - Set bit 8" ]
            # [ inline ( always ) ]
            pub fn bs8(&mut self) -> _Bs8W {
                _Bs8W { w: self }
            }
            # [ doc = "Bit 9 - Set bit 9" ]
            # [ inline ( always ) ]
            pub fn bs9(&mut self) -> _Bs9W {
                _Bs9W { w: self }
            }
            # [ doc = "Bit 10 - Set bit 10" ]
            # [ inline ( always ) ]
            pub fn bs10(&mut self) -> _Bs10W {
                _Bs10W { w: self }
            }
            # [ doc = "Bit 11 - Set bit 11" ]
            # [ inline ( always ) ]
            pub fn bs11(&mut self) -> _Bs11W {
                _Bs11W { w: self }
            }
            # [ doc = "Bit 12 - Set bit 12" ]
            # [ inline ( always ) ]
            pub fn bs12(&mut self) -> _Bs12W {
                _Bs12W { w: self }
            }
            # [ doc = "Bit 13 - Set bit 13" ]
            # [ inline ( always ) ]
            pub fn bs13(&mut self) -> _Bs13W {
                _Bs13W { w: self }
            }
            # [ doc = "Bit 14 - Set bit 14" ]
            # [ inline ( always ) ]
            pub fn bs14(&mut self) -> _Bs14W {
                _Bs14W { w: self }
            }
            # [ doc = "Bit 15 - Set bit 15" ]
            # [ inline ( always ) ]
            pub fn bs15(&mut self) -> _Bs15W {
                _Bs15W { w: self }
            }
            # [ doc = "Bit 16 - Reset bit 0" ]
            # [ inline ( always ) ]
            pub fn br0(&mut self) -> _Br0W {
                _Br0W { w: self }
            }
            # [ doc = "Bit 17 - Reset bit 1" ]
            # [ inline ( always ) ]
            pub fn br1(&mut self) -> _Br1W {
                _Br1W { w: self }
            }
            # [ doc = "Bit 18 - Reset bit 2" ]
            # [ inline ( always ) ]
            pub fn br2(&mut self) -> _Br2W {
                _Br2W { w: self }
            }
            # [ doc = "Bit 19 - Reset bit 3" ]
            # [ inline ( always ) ]
            pub fn br3(&mut self) -> _Br3W {
                _Br3W { w: self }
            }
            # [ doc = "Bit 20 - Reset bit 4" ]
            # [ inline ( always ) ]
            pub fn br4(&mut self) -> _Br4W {
                _Br4W { w: self }
            }
            # [ doc = "Bit 21 - Reset bit 5" ]
            # [ inline ( always ) ]
            pub fn br5(&mut self) -> _Br5W {
                _Br5W { w: self }
            }
            # [ doc = "Bit 22 - Reset bit 6" ]
            # [ inline ( always ) ]
            pub fn br6(&mut self) -> _Br6W {
                _Br6W { w: self }
            }
            # [ doc = "Bit 23 - Reset bit 7" ]
            # [ inline ( always ) ]
            pub fn br7(&mut self) -> _Br7W {
                _Br7W { w: self }
            }
            # [ doc = "Bit 24 - Reset bit 8" ]
            # [ inline ( always ) ]
            pub fn br8(&mut self) -> _Br8W {
                _Br8W { w: self }
            }
            # [ doc = "Bit 25 - Reset bit 9" ]
            # [ inline ( always ) ]
            pub fn br9(&mut self) -> _Br9W {
                _Br9W { w: self }
            }
            # [ doc = "Bit 26 - Reset bit 10" ]
            # [ inline ( always ) ]
            pub fn br10(&mut self) -> _Br10W {
                _Br10W { w: self }
            }
            # [ doc = "Bit 27 - Reset bit 11" ]
            # [ inline ( always ) ]
            pub fn br11(&mut self) -> _Br11W {
                _Br11W { w: self }
            }
            # [ doc = "Bit 28 - Reset bit 12" ]
            # [ inline ( always ) ]
            pub fn br12(&mut self) -> _Br12W {
                _Br12W { w: self }
            }
            # [ doc = "Bit 29 - Reset bit 13" ]
            # [ inline ( always ) ]
            pub fn br13(&mut self) -> _Br13W {
                _Br13W { w: self }
            }
            # [ doc = "Bit 30 - Reset bit 14" ]
            # [ inline ( always ) ]
            pub fn br14(&mut self) -> _Br14W {
                _Br14W { w: self }
            }
            # [ doc = "Bit 31 - Reset bit 15" ]
            # [ inline ( always ) ]
            pub fn br15(&mut self) -> _Br15W {
                _Br15W { w: self }
            }
        }
    }
    # [ doc = "Port bit reset register (GPIOn_BRR)" ]
    pub struct Brr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Port bit reset register (GPIOn_BRR)" ]
    pub mod brr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Brr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Br15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Reset bit 0" ]
            # [ inline ( always ) ]
            pub fn br0(&mut self) -> _Br0W {
                _Br0W { w: self }
            }
            # [ doc = "Bit 1 - Reset bit 1" ]
            # [ inline ( always ) ]
            pub fn br1(&mut self) -> _Br1W {
                _Br1W { w: self }
            }
            # [ doc = "Bit 2 - Reset bit 1" ]
            # [ inline ( always ) ]
            pub fn br2(&mut self) -> _Br2W {
                _Br2W { w: self }
            }
            # [ doc = "Bit 3 - Reset bit 3" ]
            # [ inline ( always ) ]
            pub fn br3(&mut self) -> _Br3W {
                _Br3W { w: self }
            }
            # [ doc = "Bit 4 - Reset bit 4" ]
            # [ inline ( always ) ]
            pub fn br4(&mut self) -> _Br4W {
                _Br4W { w: self }
            }
            # [ doc = "Bit 5 - Reset bit 5" ]
            # [ inline ( always ) ]
            pub fn br5(&mut self) -> _Br5W {
                _Br5W { w: self }
            }
            # [ doc = "Bit 6 - Reset bit 6" ]
            # [ inline ( always ) ]
            pub fn br6(&mut self) -> _Br6W {
                _Br6W { w: self }
            }
            # [ doc = "Bit 7 - Reset bit 7" ]
            # [ inline ( always ) ]
            pub fn br7(&mut self) -> _Br7W {
                _Br7W { w: self }
            }
            # [ doc = "Bit 8 - Reset bit 8" ]
            # [ inline ( always ) ]
            pub fn br8(&mut self) -> _Br8W {
                _Br8W { w: self }
            }
            # [ doc = "Bit 9 - Reset bit 9" ]
            # [ inline ( always ) ]
            pub fn br9(&mut self) -> _Br9W {
                _Br9W { w: self }
            }
            # [ doc = "Bit 10 - Reset bit 10" ]
            # [ inline ( always ) ]
            pub fn br10(&mut self) -> _Br10W {
                _Br10W { w: self }
            }
            # [ doc = "Bit 11 - Reset bit 11" ]
            # [ inline ( always ) ]
            pub fn br11(&mut self) -> _Br11W {
                _Br11W { w: self }
            }
            # [ doc = "Bit 12 - Reset bit 12" ]
            # [ inline ( always ) ]
            pub fn br12(&mut self) -> _Br12W {
                _Br12W { w: self }
            }
            # [ doc = "Bit 13 - Reset bit 13" ]
            # [ inline ( always ) ]
            pub fn br13(&mut self) -> _Br13W {
                _Br13W { w: self }
            }
            # [ doc = "Bit 14 - Reset bit 14" ]
            # [ inline ( always ) ]
            pub fn br14(&mut self) -> _Br14W {
                _Br14W { w: self }
            }
            # [ doc = "Bit 15 - Reset bit 15" ]
            # [ inline ( always ) ]
            pub fn br15(&mut self) -> _Br15W {
                _Br15W { w: self }
            }
        }
    }
    # [ doc = "Port configuration lock register" ]
    pub struct Lckr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Port configuration lock register" ]
    pub mod lckr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Lckr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck0R {
            bits: u8,
        }
        impl Lck0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck1R {
            bits: u8,
        }
        impl Lck1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck2R {
            bits: u8,
        }
        impl Lck2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck3R {
            bits: u8,
        }
        impl Lck3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck4R {
            bits: u8,
        }
        impl Lck4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck5R {
            bits: u8,
        }
        impl Lck5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck6R {
            bits: u8,
        }
        impl Lck6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck7R {
            bits: u8,
        }
        impl Lck7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck8R {
            bits: u8,
        }
        impl Lck8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck9R {
            bits: u8,
        }
        impl Lck9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck10R {
            bits: u8,
        }
        impl Lck10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck11R {
            bits: u8,
        }
        impl Lck11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck12R {
            bits: u8,
        }
        impl Lck12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck13R {
            bits: u8,
        }
        impl Lck13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck14R {
            bits: u8,
        }
        impl Lck14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Lck15R {
            bits: u8,
        }
        impl Lck15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LckkR {
            bits: u8,
        }
        impl LckkR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Lck15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LckkW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LckkW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Port A Lock bit 0" ]
            # [ inline ( always ) ]
            pub fn lck0(&self) -> Lck0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck0R { bits }
            }
            # [ doc = "Bit 1 - Port A Lock bit 1" ]
            # [ inline ( always ) ]
            pub fn lck1(&self) -> Lck1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck1R { bits }
            }
            # [ doc = "Bit 2 - Port A Lock bit 2" ]
            # [ inline ( always ) ]
            pub fn lck2(&self) -> Lck2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck2R { bits }
            }
            # [ doc = "Bit 3 - Port A Lock bit 3" ]
            # [ inline ( always ) ]
            pub fn lck3(&self) -> Lck3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck3R { bits }
            }
            # [ doc = "Bit 4 - Port A Lock bit 4" ]
            # [ inline ( always ) ]
            pub fn lck4(&self) -> Lck4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck4R { bits }
            }
            # [ doc = "Bit 5 - Port A Lock bit 5" ]
            # [ inline ( always ) ]
            pub fn lck5(&self) -> Lck5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck5R { bits }
            }
            # [ doc = "Bit 6 - Port A Lock bit 6" ]
            # [ inline ( always ) ]
            pub fn lck6(&self) -> Lck6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck6R { bits }
            }
            # [ doc = "Bit 7 - Port A Lock bit 7" ]
            # [ inline ( always ) ]
            pub fn lck7(&self) -> Lck7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck7R { bits }
            }
            # [ doc = "Bit 8 - Port A Lock bit 8" ]
            # [ inline ( always ) ]
            pub fn lck8(&self) -> Lck8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck8R { bits }
            }
            # [ doc = "Bit 9 - Port A Lock bit 9" ]
            # [ inline ( always ) ]
            pub fn lck9(&self) -> Lck9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck9R { bits }
            }
            # [ doc = "Bit 10 - Port A Lock bit 10" ]
            # [ inline ( always ) ]
            pub fn lck10(&self) -> Lck10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck10R { bits }
            }
            # [ doc = "Bit 11 - Port A Lock bit 11" ]
            # [ inline ( always ) ]
            pub fn lck11(&self) -> Lck11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck11R { bits }
            }
            # [ doc = "Bit 12 - Port A Lock bit 12" ]
            # [ inline ( always ) ]
            pub fn lck12(&self) -> Lck12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck12R { bits }
            }
            # [ doc = "Bit 13 - Port A Lock bit 13" ]
            # [ inline ( always ) ]
            pub fn lck13(&self) -> Lck13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck13R { bits }
            }
            # [ doc = "Bit 14 - Port A Lock bit 14" ]
            # [ inline ( always ) ]
            pub fn lck14(&self) -> Lck14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck14R { bits }
            }
            # [ doc = "Bit 15 - Port A Lock bit 15" ]
            # [ inline ( always ) ]
            pub fn lck15(&self) -> Lck15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck15R { bits }
            }
            # [ doc = "Bit 16 - Lock key" ]
            # [ inline ( always ) ]
            pub fn lckk(&self) -> LckkR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LckkR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Port A Lock bit 0" ]
            # [ inline ( always ) ]
            pub fn lck0(&mut self) -> _Lck0W {
                _Lck0W { w: self }
            }
            # [ doc = "Bit 1 - Port A Lock bit 1" ]
            # [ inline ( always ) ]
            pub fn lck1(&mut self) -> _Lck1W {
                _Lck1W { w: self }
            }
            # [ doc = "Bit 2 - Port A Lock bit 2" ]
            # [ inline ( always ) ]
            pub fn lck2(&mut self) -> _Lck2W {
                _Lck2W { w: self }
            }
            # [ doc = "Bit 3 - Port A Lock bit 3" ]
            # [ inline ( always ) ]
            pub fn lck3(&mut self) -> _Lck3W {
                _Lck3W { w: self }
            }
            # [ doc = "Bit 4 - Port A Lock bit 4" ]
            # [ inline ( always ) ]
            pub fn lck4(&mut self) -> _Lck4W {
                _Lck4W { w: self }
            }
            # [ doc = "Bit 5 - Port A Lock bit 5" ]
            # [ inline ( always ) ]
            pub fn lck5(&mut self) -> _Lck5W {
                _Lck5W { w: self }
            }
            # [ doc = "Bit 6 - Port A Lock bit 6" ]
            # [ inline ( always ) ]
            pub fn lck6(&mut self) -> _Lck6W {
                _Lck6W { w: self }
            }
            # [ doc = "Bit 7 - Port A Lock bit 7" ]
            # [ inline ( always ) ]
            pub fn lck7(&mut self) -> _Lck7W {
                _Lck7W { w: self }
            }
            # [ doc = "Bit 8 - Port A Lock bit 8" ]
            # [ inline ( always ) ]
            pub fn lck8(&mut self) -> _Lck8W {
                _Lck8W { w: self }
            }
            # [ doc = "Bit 9 - Port A Lock bit 9" ]
            # [ inline ( always ) ]
            pub fn lck9(&mut self) -> _Lck9W {
                _Lck9W { w: self }
            }
            # [ doc = "Bit 10 - Port A Lock bit 10" ]
            # [ inline ( always ) ]
            pub fn lck10(&mut self) -> _Lck10W {
                _Lck10W { w: self }
            }
            # [ doc = "Bit 11 - Port A Lock bit 11" ]
            # [ inline ( always ) ]
            pub fn lck11(&mut self) -> _Lck11W {
                _Lck11W { w: self }
            }
            # [ doc = "Bit 12 - Port A Lock bit 12" ]
            # [ inline ( always ) ]
            pub fn lck12(&mut self) -> _Lck12W {
                _Lck12W { w: self }
            }
            # [ doc = "Bit 13 - Port A Lock bit 13" ]
            # [ inline ( always ) ]
            pub fn lck13(&mut self) -> _Lck13W {
                _Lck13W { w: self }
            }
            # [ doc = "Bit 14 - Port A Lock bit 14" ]
            # [ inline ( always ) ]
            pub fn lck14(&mut self) -> _Lck14W {
                _Lck14W { w: self }
            }
            # [ doc = "Bit 15 - Port A Lock bit 15" ]
            # [ inline ( always ) ]
            pub fn lck15(&mut self) -> _Lck15W {
                _Lck15W { w: self }
            }
            # [ doc = "Bit 16 - Lock key" ]
            # [ inline ( always ) ]
            pub fn lckk(&mut self) -> _LckkW {
                _LckkW { w: self }
            }
        }
    }
}
# [ doc = "General purpose I/O" ]
pub struct Gpioa {
    register_block: gpioa::RegisterBlock,
}
impl Deref for Gpioa {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "GPIOB" ]
pub const GPIOB: Peripheral<Gpiob> = unsafe { Peripheral::new(1073810432) };
# [ doc = r" Register block" ]
pub struct Gpiob {
    register_block: gpioa::RegisterBlock,
}
impl Deref for Gpiob {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "GPIOC" ]
pub const GPIOC: Peripheral<Gpioc> = unsafe { Peripheral::new(1073811456) };
# [ doc = r" Register block" ]
pub struct Gpioc {
    register_block: gpioa::RegisterBlock,
}
impl Deref for Gpioc {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "GPIOD" ]
pub const GPIOD: Peripheral<Gpiod> = unsafe { Peripheral::new(1073812480) };
# [ doc = r" Register block" ]
pub struct Gpiod {
    register_block: gpioa::RegisterBlock,
}
impl Deref for Gpiod {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "GPIOE" ]
pub const GPIOE: Peripheral<Gpioe> = unsafe { Peripheral::new(1073813504) };
# [ doc = r" Register block" ]
pub struct Gpioe {
    register_block: gpioa::RegisterBlock,
}
impl Deref for Gpioe {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "GPIOF" ]
pub const GPIOF: Peripheral<Gpiof> = unsafe { Peripheral::new(1073814528) };
# [ doc = r" Register block" ]
pub struct Gpiof {
    register_block: gpioa::RegisterBlock,
}
impl Deref for Gpiof {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "GPIOG" ]
pub const GPIOG: Peripheral<Gpiog> = unsafe { Peripheral::new(1073815552) };
# [ doc = r" Register block" ]
pub struct Gpiog {
    register_block: gpioa::RegisterBlock,
}
impl Deref for Gpiog {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Alternate function I/O" ]
pub const AFIO: Peripheral<Afio> = unsafe { Peripheral::new(1073807360) };
# [ doc = "Alternate function I/O" ]
pub mod afio {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Event Control Register (AFIO_EVCR)" ]
        pub evcr: Evcr,
        # [ doc = "0x04 - AF remap and debug I/O configuration register (AFIO_MAPR)" ]
        pub mapr: Mapr,
        # [ doc = "0x08 - External interrupt configuration register 1 (AFIO_EXTICR1)" ]
        pub exticr1: Exticr1,
        # [ doc = "0x0c - External interrupt configuration register 2 (AFIO_EXTICR2)" ]
        pub exticr2: Exticr2,
        # [ doc = "0x10 - External interrupt configuration register 3 (AFIO_EXTICR3)" ]
        pub exticr3: Exticr3,
        # [ doc = "0x14 - External interrupt configuration register 4 (AFIO_EXTICR4)" ]
        pub exticr4: Exticr4,
        _reserved0: [u8; 4usize],
        # [ doc = "0x1c - AF remap and debug I/O configuration register" ]
        pub mapr2: Mapr2,
    }
    # [ doc = "Event Control Register (AFIO_EVCR)" ]
    pub struct Evcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Event Control Register (AFIO_EVCR)" ]
    pub mod evcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Evcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PinR {
            bits: u8,
        }
        impl PinR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PortR {
            bits: u8,
        }
        impl PortR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EvoeR {
            bits: u8,
        }
        impl EvoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PinW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PinW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PortW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PortW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EvoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EvoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - Pin selection" ]
            # [ inline ( always ) ]
            pub fn pin(&self) -> PinR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PinR { bits }
            }
            # [ doc = "Bits 4:6 - Port selection" ]
            # [ inline ( always ) ]
            pub fn port(&self) -> PortR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PortR { bits }
            }
            # [ doc = "Bit 7 - Event Output Enable" ]
            # [ inline ( always ) ]
            pub fn evoe(&self) -> EvoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EvoeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - Pin selection" ]
            # [ inline ( always ) ]
            pub fn pin(&mut self) -> _PinW {
                _PinW { w: self }
            }
            # [ doc = "Bits 4:6 - Port selection" ]
            # [ inline ( always ) ]
            pub fn port(&mut self) -> _PortW {
                _PortW { w: self }
            }
            # [ doc = "Bit 7 - Event Output Enable" ]
            # [ inline ( always ) ]
            pub fn evoe(&mut self) -> _EvoeW {
                _EvoeW { w: self }
            }
        }
    }
    # [ doc = "AF remap and debug I/O configuration register (AFIO_MAPR)" ]
    pub struct Mapr {
        register: VolatileCell<u32>,
    }
    # [ doc = "AF remap and debug I/O configuration register (AFIO_MAPR)" ]
    pub mod mapr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Mapr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Spi1RemapR {
            bits: u8,
        }
        impl Spi1RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct I2c1RemapR {
            bits: u8,
        }
        impl I2c1RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Usart1RemapR {
            bits: u8,
        }
        impl Usart1RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Usart2RemapR {
            bits: u8,
        }
        impl Usart2RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Usart3RemapR {
            bits: u8,
        }
        impl Usart3RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim1RemapR {
            bits: u8,
        }
        impl Tim1RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim2RemapR {
            bits: u8,
        }
        impl Tim2RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim3RemapR {
            bits: u8,
        }
        impl Tim3RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim4RemapR {
            bits: u8,
        }
        impl Tim4RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pd01RemapR {
            bits: u8,
        }
        impl Pd01RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim5ch4IremapR {
            bits: u8,
        }
        impl Tim5ch4IremapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Spi1RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi1RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _I2c1RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2c1RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Usart1RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart1RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Usart2RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart2RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Usart3RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart3RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim1RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim1RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim2RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim2RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim3RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim3RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim4RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim4RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pd01RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pd01RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim5ch4IremapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim5ch4IremapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SwjCfgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SwjCfgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - SPI1 remapping" ]
            # [ inline ( always ) ]
            pub fn spi1_remap(&self) -> Spi1RemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Spi1RemapR { bits }
            }
            # [ doc = "Bit 1 - I2C1 remapping" ]
            # [ inline ( always ) ]
            pub fn i2c1_remap(&self) -> I2c1RemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2c1RemapR { bits }
            }
            # [ doc = "Bit 2 - USART1 remapping" ]
            # [ inline ( always ) ]
            pub fn usart1_remap(&self) -> Usart1RemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Usart1RemapR { bits }
            }
            # [ doc = "Bit 3 - USART2 remapping" ]
            # [ inline ( always ) ]
            pub fn usart2_remap(&self) -> Usart2RemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Usart2RemapR { bits }
            }
            # [ doc = "Bits 4:5 - USART3 remapping" ]
            # [ inline ( always ) ]
            pub fn usart3_remap(&self) -> Usart3RemapR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Usart3RemapR { bits }
            }
            # [ doc = "Bits 6:7 - TIM1 remapping" ]
            # [ inline ( always ) ]
            pub fn tim1_remap(&self) -> Tim1RemapR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim1RemapR { bits }
            }
            # [ doc = "Bits 8:9 - TIM2 remapping" ]
            # [ inline ( always ) ]
            pub fn tim2_remap(&self) -> Tim2RemapR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim2RemapR { bits }
            }
            # [ doc = "Bits 10:11 - TIM3 remapping" ]
            # [ inline ( always ) ]
            pub fn tim3_remap(&self) -> Tim3RemapR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim3RemapR { bits }
            }
            # [ doc = "Bit 12 - TIM4 remapping" ]
            # [ inline ( always ) ]
            pub fn tim4_remap(&self) -> Tim4RemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim4RemapR { bits }
            }
            # [ doc = "Bit 15 - Port D0/Port D1 mapping on OSCIN/OSCOUT" ]
            # [ inline ( always ) ]
            pub fn pd01_remap(&self) -> Pd01RemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pd01RemapR { bits }
            }
            # [ doc = "Bit 16 - Set and cleared by software" ]
            # [ inline ( always ) ]
            pub fn tim5ch4_iremap(&self) -> Tim5ch4IremapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim5ch4IremapR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - SPI1 remapping" ]
            # [ inline ( always ) ]
            pub fn spi1_remap(&mut self) -> _Spi1RemapW {
                _Spi1RemapW { w: self }
            }
            # [ doc = "Bit 1 - I2C1 remapping" ]
            # [ inline ( always ) ]
            pub fn i2c1_remap(&mut self) -> _I2c1RemapW {
                _I2c1RemapW { w: self }
            }
            # [ doc = "Bit 2 - USART1 remapping" ]
            # [ inline ( always ) ]
            pub fn usart1_remap(&mut self) -> _Usart1RemapW {
                _Usart1RemapW { w: self }
            }
            # [ doc = "Bit 3 - USART2 remapping" ]
            # [ inline ( always ) ]
            pub fn usart2_remap(&mut self) -> _Usart2RemapW {
                _Usart2RemapW { w: self }
            }
            # [ doc = "Bits 4:5 - USART3 remapping" ]
            # [ inline ( always ) ]
            pub fn usart3_remap(&mut self) -> _Usart3RemapW {
                _Usart3RemapW { w: self }
            }
            # [ doc = "Bits 6:7 - TIM1 remapping" ]
            # [ inline ( always ) ]
            pub fn tim1_remap(&mut self) -> _Tim1RemapW {
                _Tim1RemapW { w: self }
            }
            # [ doc = "Bits 8:9 - TIM2 remapping" ]
            # [ inline ( always ) ]
            pub fn tim2_remap(&mut self) -> _Tim2RemapW {
                _Tim2RemapW { w: self }
            }
            # [ doc = "Bits 10:11 - TIM3 remapping" ]
            # [ inline ( always ) ]
            pub fn tim3_remap(&mut self) -> _Tim3RemapW {
                _Tim3RemapW { w: self }
            }
            # [ doc = "Bit 12 - TIM4 remapping" ]
            # [ inline ( always ) ]
            pub fn tim4_remap(&mut self) -> _Tim4RemapW {
                _Tim4RemapW { w: self }
            }
            # [ doc = "Bit 15 - Port D0/Port D1 mapping on OSCIN/OSCOUT" ]
            # [ inline ( always ) ]
            pub fn pd01_remap(&mut self) -> _Pd01RemapW {
                _Pd01RemapW { w: self }
            }
            # [ doc = "Bit 16 - Set and cleared by software" ]
            # [ inline ( always ) ]
            pub fn tim5ch4_iremap(&mut self) -> _Tim5ch4IremapW {
                _Tim5ch4IremapW { w: self }
            }
            # [ doc = "Bits 24:26 - Serial wire JTAG configuration" ]
            # [ inline ( always ) ]
            pub fn swj_cfg(&mut self) -> _SwjCfgW {
                _SwjCfgW { w: self }
            }
        }
    }
    # [ doc = "External interrupt configuration register 1 (AFIO_EXTICR1)" ]
    pub struct Exticr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "External interrupt configuration register 1 (AFIO_EXTICR1)" ]
    pub mod exticr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Exticr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti0R {
            bits: u8,
        }
        impl Exti0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti1R {
            bits: u8,
        }
        impl Exti1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti2R {
            bits: u8,
        }
        impl Exti2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti3R {
            bits: u8,
        }
        impl Exti3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - EXTI0 configuration" ]
            # [ inline ( always ) ]
            pub fn exti0(&self) -> Exti0R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti0R { bits }
            }
            # [ doc = "Bits 4:7 - EXTI1 configuration" ]
            # [ inline ( always ) ]
            pub fn exti1(&self) -> Exti1R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti1R { bits }
            }
            # [ doc = "Bits 8:11 - EXTI2 configuration" ]
            # [ inline ( always ) ]
            pub fn exti2(&self) -> Exti2R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti2R { bits }
            }
            # [ doc = "Bits 12:15 - EXTI3 configuration" ]
            # [ inline ( always ) ]
            pub fn exti3(&self) -> Exti3R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - EXTI0 configuration" ]
            # [ inline ( always ) ]
            pub fn exti0(&mut self) -> _Exti0W {
                _Exti0W { w: self }
            }
            # [ doc = "Bits 4:7 - EXTI1 configuration" ]
            # [ inline ( always ) ]
            pub fn exti1(&mut self) -> _Exti1W {
                _Exti1W { w: self }
            }
            # [ doc = "Bits 8:11 - EXTI2 configuration" ]
            # [ inline ( always ) ]
            pub fn exti2(&mut self) -> _Exti2W {
                _Exti2W { w: self }
            }
            # [ doc = "Bits 12:15 - EXTI3 configuration" ]
            # [ inline ( always ) ]
            pub fn exti3(&mut self) -> _Exti3W {
                _Exti3W { w: self }
            }
        }
    }
    # [ doc = "External interrupt configuration register 2 (AFIO_EXTICR2)" ]
    pub struct Exticr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "External interrupt configuration register 2 (AFIO_EXTICR2)" ]
    pub mod exticr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Exticr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti4R {
            bits: u8,
        }
        impl Exti4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti5R {
            bits: u8,
        }
        impl Exti5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti6R {
            bits: u8,
        }
        impl Exti6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti7R {
            bits: u8,
        }
        impl Exti7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - EXTI4 configuration" ]
            # [ inline ( always ) ]
            pub fn exti4(&self) -> Exti4R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti4R { bits }
            }
            # [ doc = "Bits 4:7 - EXTI5 configuration" ]
            # [ inline ( always ) ]
            pub fn exti5(&self) -> Exti5R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti5R { bits }
            }
            # [ doc = "Bits 8:11 - EXTI6 configuration" ]
            # [ inline ( always ) ]
            pub fn exti6(&self) -> Exti6R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti6R { bits }
            }
            # [ doc = "Bits 12:15 - EXTI7 configuration" ]
            # [ inline ( always ) ]
            pub fn exti7(&self) -> Exti7R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - EXTI4 configuration" ]
            # [ inline ( always ) ]
            pub fn exti4(&mut self) -> _Exti4W {
                _Exti4W { w: self }
            }
            # [ doc = "Bits 4:7 - EXTI5 configuration" ]
            # [ inline ( always ) ]
            pub fn exti5(&mut self) -> _Exti5W {
                _Exti5W { w: self }
            }
            # [ doc = "Bits 8:11 - EXTI6 configuration" ]
            # [ inline ( always ) ]
            pub fn exti6(&mut self) -> _Exti6W {
                _Exti6W { w: self }
            }
            # [ doc = "Bits 12:15 - EXTI7 configuration" ]
            # [ inline ( always ) ]
            pub fn exti7(&mut self) -> _Exti7W {
                _Exti7W { w: self }
            }
        }
    }
    # [ doc = "External interrupt configuration register 3 (AFIO_EXTICR3)" ]
    pub struct Exticr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "External interrupt configuration register 3 (AFIO_EXTICR3)" ]
    pub mod exticr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Exticr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti8R {
            bits: u8,
        }
        impl Exti8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti9R {
            bits: u8,
        }
        impl Exti9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti10R {
            bits: u8,
        }
        impl Exti10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti11R {
            bits: u8,
        }
        impl Exti11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - EXTI8 configuration" ]
            # [ inline ( always ) ]
            pub fn exti8(&self) -> Exti8R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti8R { bits }
            }
            # [ doc = "Bits 4:7 - EXTI9 configuration" ]
            # [ inline ( always ) ]
            pub fn exti9(&self) -> Exti9R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti9R { bits }
            }
            # [ doc = "Bits 8:11 - EXTI10 configuration" ]
            # [ inline ( always ) ]
            pub fn exti10(&self) -> Exti10R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti10R { bits }
            }
            # [ doc = "Bits 12:15 - EXTI11 configuration" ]
            # [ inline ( always ) ]
            pub fn exti11(&self) -> Exti11R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti11R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - EXTI8 configuration" ]
            # [ inline ( always ) ]
            pub fn exti8(&mut self) -> _Exti8W {
                _Exti8W { w: self }
            }
            # [ doc = "Bits 4:7 - EXTI9 configuration" ]
            # [ inline ( always ) ]
            pub fn exti9(&mut self) -> _Exti9W {
                _Exti9W { w: self }
            }
            # [ doc = "Bits 8:11 - EXTI10 configuration" ]
            # [ inline ( always ) ]
            pub fn exti10(&mut self) -> _Exti10W {
                _Exti10W { w: self }
            }
            # [ doc = "Bits 12:15 - EXTI11 configuration" ]
            # [ inline ( always ) ]
            pub fn exti11(&mut self) -> _Exti11W {
                _Exti11W { w: self }
            }
        }
    }
    # [ doc = "External interrupt configuration register 4 (AFIO_EXTICR4)" ]
    pub struct Exticr4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "External interrupt configuration register 4 (AFIO_EXTICR4)" ]
    pub mod exticr4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Exticr4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti12R {
            bits: u8,
        }
        impl Exti12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti13R {
            bits: u8,
        }
        impl Exti13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti14R {
            bits: u8,
        }
        impl Exti14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Exti15R {
            bits: u8,
        }
        impl Exti15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Exti15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - EXTI12 configuration" ]
            # [ inline ( always ) ]
            pub fn exti12(&self) -> Exti12R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti12R { bits }
            }
            # [ doc = "Bits 4:7 - EXTI13 configuration" ]
            # [ inline ( always ) ]
            pub fn exti13(&self) -> Exti13R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti13R { bits }
            }
            # [ doc = "Bits 8:11 - EXTI14 configuration" ]
            # [ inline ( always ) ]
            pub fn exti14(&self) -> Exti14R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti14R { bits }
            }
            # [ doc = "Bits 12:15 - EXTI15 configuration" ]
            # [ inline ( always ) ]
            pub fn exti15(&self) -> Exti15R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - EXTI12 configuration" ]
            # [ inline ( always ) ]
            pub fn exti12(&mut self) -> _Exti12W {
                _Exti12W { w: self }
            }
            # [ doc = "Bits 4:7 - EXTI13 configuration" ]
            # [ inline ( always ) ]
            pub fn exti13(&mut self) -> _Exti13W {
                _Exti13W { w: self }
            }
            # [ doc = "Bits 8:11 - EXTI14 configuration" ]
            # [ inline ( always ) ]
            pub fn exti14(&mut self) -> _Exti14W {
                _Exti14W { w: self }
            }
            # [ doc = "Bits 12:15 - EXTI15 configuration" ]
            # [ inline ( always ) ]
            pub fn exti15(&mut self) -> _Exti15W {
                _Exti15W { w: self }
            }
        }
    }
    # [ doc = "AF remap and debug I/O configuration register" ]
    pub struct Mapr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "AF remap and debug I/O configuration register" ]
    pub mod mapr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Mapr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim15RemapR {
            bits: u8,
        }
        impl Tim15RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim16RemapR {
            bits: u8,
        }
        impl Tim16RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim17RemapR {
            bits: u8,
        }
        impl Tim17RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim13RemapR {
            bits: u8,
        }
        impl Tim13RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim14RemapR {
            bits: u8,
        }
        impl Tim14RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FsmcNadvR {
            bits: u8,
        }
        impl FsmcNadvR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CecRemapR {
            bits: u8,
        }
        impl CecRemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim1DmaRemapR {
            bits: u8,
        }
        impl Tim1DmaRemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim67DacDmaRemapR {
            bits: u8,
        }
        impl Tim67DacDmaRemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tim12RemapR {
            bits: u8,
        }
        impl Tim12RemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MiscRemapR {
            bits: u8,
        }
        impl MiscRemapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim15RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim15RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim16RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim16RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim17RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim17RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim13RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim13RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim14RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim14RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FsmcNadvW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FsmcNadvW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CecRemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CecRemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim1DmaRemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim1DmaRemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim67DacDmaRemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim67DacDmaRemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tim12RemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim12RemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MiscRemapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MiscRemapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - TIM15 remapping" ]
            # [ inline ( always ) ]
            pub fn tim15_remap(&self) -> Tim15RemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim15RemapR { bits }
            }
            # [ doc = "Bit 1 - TIM16 remapping" ]
            # [ inline ( always ) ]
            pub fn tim16_remap(&self) -> Tim16RemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim16RemapR { bits }
            }
            # [ doc = "Bit 2 - TIM17 remapping" ]
            # [ inline ( always ) ]
            pub fn tim17_remap(&self) -> Tim17RemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim17RemapR { bits }
            }
            # [ doc = "Bit 8 - TIM13 remapping" ]
            # [ inline ( always ) ]
            pub fn tim13_remap(&self) -> Tim13RemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim13RemapR { bits }
            }
            # [ doc = "Bit 9 - TIM14 remapping" ]
            # [ inline ( always ) ]
            pub fn tim14_remap(&self) -> Tim14RemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim14RemapR { bits }
            }
            # [ doc = "Bit 10 - NADV connect/disconnect" ]
            # [ inline ( always ) ]
            pub fn fsmc_nadv(&self) -> FsmcNadvR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FsmcNadvR { bits }
            }
            # [ doc = "Bit 3 - CEC remapping" ]
            # [ inline ( always ) ]
            pub fn cec_remap(&self) -> CecRemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CecRemapR { bits }
            }
            # [ doc = "Bit 4 - TIM1 DMA remapping" ]
            # [ inline ( always ) ]
            pub fn tim1_dma_remap(&self) -> Tim1DmaRemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim1DmaRemapR { bits }
            }
            # [ doc = "Bit 11 - TIM67_DAC DMA remapping" ]
            # [ inline ( always ) ]
            pub fn tim67_dac_dma_remap(&self) -> Tim67DacDmaRemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim67DacDmaRemapR { bits }
            }
            # [ doc = "Bit 12 - TIM12 remapping" ]
            # [ inline ( always ) ]
            pub fn tim12_remap(&self) -> Tim12RemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim12RemapR { bits }
            }
            # [ doc = "Bit 13 - Miscellaneous features remapping" ]
            # [ inline ( always ) ]
            pub fn misc_remap(&self) -> MiscRemapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MiscRemapR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - TIM15 remapping" ]
            # [ inline ( always ) ]
            pub fn tim15_remap(&mut self) -> _Tim15RemapW {
                _Tim15RemapW { w: self }
            }
            # [ doc = "Bit 1 - TIM16 remapping" ]
            # [ inline ( always ) ]
            pub fn tim16_remap(&mut self) -> _Tim16RemapW {
                _Tim16RemapW { w: self }
            }
            # [ doc = "Bit 2 - TIM17 remapping" ]
            # [ inline ( always ) ]
            pub fn tim17_remap(&mut self) -> _Tim17RemapW {
                _Tim17RemapW { w: self }
            }
            # [ doc = "Bit 8 - TIM13 remapping" ]
            # [ inline ( always ) ]
            pub fn tim13_remap(&mut self) -> _Tim13RemapW {
                _Tim13RemapW { w: self }
            }
            # [ doc = "Bit 9 - TIM14 remapping" ]
            # [ inline ( always ) ]
            pub fn tim14_remap(&mut self) -> _Tim14RemapW {
                _Tim14RemapW { w: self }
            }
            # [ doc = "Bit 10 - NADV connect/disconnect" ]
            # [ inline ( always ) ]
            pub fn fsmc_nadv(&mut self) -> _FsmcNadvW {
                _FsmcNadvW { w: self }
            }
            # [ doc = "Bit 3 - CEC remapping" ]
            # [ inline ( always ) ]
            pub fn cec_remap(&mut self) -> _CecRemapW {
                _CecRemapW { w: self }
            }
            # [ doc = "Bit 4 - TIM1 DMA remapping" ]
            # [ inline ( always ) ]
            pub fn tim1_dma_remap(&mut self) -> _Tim1DmaRemapW {
                _Tim1DmaRemapW { w: self }
            }
            # [ doc = "Bit 11 - TIM67_DAC DMA remapping" ]
            # [ inline ( always ) ]
            pub fn tim67_dac_dma_remap(&mut self) -> _Tim67DacDmaRemapW {
                _Tim67DacDmaRemapW { w: self }
            }
            # [ doc = "Bit 12 - TIM12 remapping" ]
            # [ inline ( always ) ]
            pub fn tim12_remap(&mut self) -> _Tim12RemapW {
                _Tim12RemapW { w: self }
            }
            # [ doc = "Bit 13 - Miscellaneous features remapping" ]
            # [ inline ( always ) ]
            pub fn misc_remap(&mut self) -> _MiscRemapW {
                _MiscRemapW { w: self }
            }
        }
    }
}
# [ doc = "Alternate function I/O" ]
pub struct Afio {
    register_block: afio::RegisterBlock,
}
impl Deref for Afio {
    type Target = afio::RegisterBlock;
    fn deref(&self) -> &afio::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "EXTI" ]
pub const EXTI: Peripheral<Exti> = unsafe { Peripheral::new(1073808384) };
# [ doc = "EXTI" ]
pub mod exti {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Interrupt mask register (EXTI_IMR)" ]
        pub imr: Imr,
        # [ doc = "0x04 - Event mask register (EXTI_EMR)" ]
        pub emr: Emr,
        # [ doc = "0x08 - Rising Trigger selection register (EXTI_RTSR)" ]
        pub rtsr: Rtsr,
        # [ doc = "0x0c - Falling Trigger selection register (EXTI_FTSR)" ]
        pub ftsr: Ftsr,
        # [ doc = "0x10 - Software interrupt event register (EXTI_SWIER)" ]
        pub swier: Swier,
        # [ doc = "0x14 - Pending register (EXTI_PR)" ]
        pub pr: Pr,
    }
    # [ doc = "Interrupt mask register (EXTI_IMR)" ]
    pub struct Imr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Interrupt mask register (EXTI_IMR)" ]
    pub mod imr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Imr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `MR0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Mr0R {
            # [ doc = "Masked." ]
            Masked,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Mr0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Mr0R::Masked => 0,
                    Mr0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Mr0R {
                match bits {
                    0 => Mr0R::Masked,
                    1 => Mr0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Masked`" ]
            # [ inline ( always ) ]
            pub fn is_masked(&self) -> bool {
                *self == Mr0R::Masked
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Mr0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `MR1`" ]
        pub type Mr1R = Mr0R;
        # [ doc = "Possible values of the field `MR2`" ]
        pub type Mr2R = Mr0R;
        # [ doc = "Possible values of the field `MR3`" ]
        pub type Mr3R = Mr0R;
        # [ doc = "Possible values of the field `MR4`" ]
        pub type Mr4R = Mr0R;
        # [ doc = "Possible values of the field `MR5`" ]
        pub type Mr5R = Mr0R;
        # [ doc = "Possible values of the field `MR6`" ]
        pub type Mr6R = Mr0R;
        # [ doc = "Possible values of the field `MR7`" ]
        pub type Mr7R = Mr0R;
        # [ doc = "Possible values of the field `MR8`" ]
        pub type Mr8R = Mr0R;
        # [ doc = "Possible values of the field `MR9`" ]
        pub type Mr9R = Mr0R;
        # [ doc = "Possible values of the field `MR10`" ]
        pub type Mr10R = Mr0R;
        # [ doc = "Possible values of the field `MR11`" ]
        pub type Mr11R = Mr0R;
        # [ doc = "Possible values of the field `MR12`" ]
        pub type Mr12R = Mr0R;
        # [ doc = "Possible values of the field `MR13`" ]
        pub type Mr13R = Mr0R;
        # [ doc = "Possible values of the field `MR14`" ]
        pub type Mr14R = Mr0R;
        # [ doc = "Possible values of the field `MR15`" ]
        pub type Mr15R = Mr0R;
        # [ doc = "Possible values of the field `MR16`" ]
        pub type Mr16R = Mr0R;
        # [ doc = "Possible values of the field `MR17`" ]
        pub type Mr17R = Mr0R;
        # [ doc = "Values that can be written to the field `MR0`" ]
        pub enum Mr0W {
            # [ doc = "Masked." ]
            Masked,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Mr0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Mr0W::Masked => 0,
                    Mr0W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR1`" ]
        pub type Mr1W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR2`" ]
        pub type Mr2W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR3`" ]
        pub type Mr3W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR4`" ]
        pub type Mr4W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR5`" ]
        pub type Mr5W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR6`" ]
        pub type Mr6W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR7`" ]
        pub type Mr7W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR8`" ]
        pub type Mr8W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR9`" ]
        pub type Mr9W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR10`" ]
        pub type Mr10W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR11`" ]
        pub type Mr11W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR12`" ]
        pub type Mr12W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR13`" ]
        pub type Mr13W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR14`" ]
        pub type Mr14W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR15`" ]
        pub type Mr15W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR16`" ]
        pub type Mr16W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr16W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr16W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MR17`" ]
        pub type Mr17W = Mr0W;
        # [ doc = r" Proxy" ]
        pub struct _Mr17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr17W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Mr17W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Masked." ]
            # [ inline ( always ) ]
            pub fn masked(self) -> &'a mut W {
                self.variant(Mr0W::Masked)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Interrupt Mask on line 0" ]
            # [ inline ( always ) ]
            pub fn mr0(&self) -> Mr0R {
                Mr0R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 1 - Interrupt Mask on line 1" ]
            # [ inline ( always ) ]
            pub fn mr1(&self) -> Mr1R {
                Mr1R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 1;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 2 - Interrupt Mask on line 2" ]
            # [ inline ( always ) ]
            pub fn mr2(&self) -> Mr2R {
                Mr2R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 2;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 3 - Interrupt Mask on line 3" ]
            # [ inline ( always ) ]
            pub fn mr3(&self) -> Mr3R {
                Mr3R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 3;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 4 - Interrupt Mask on line 4" ]
            # [ inline ( always ) ]
            pub fn mr4(&self) -> Mr4R {
                Mr4R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 4;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 5 - Interrupt Mask on line 5" ]
            # [ inline ( always ) ]
            pub fn mr5(&self) -> Mr5R {
                Mr5R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 5;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 6 - Interrupt Mask on line 6" ]
            # [ inline ( always ) ]
            pub fn mr6(&self) -> Mr6R {
                Mr6R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 6;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 7 - Interrupt Mask on line 7" ]
            # [ inline ( always ) ]
            pub fn mr7(&self) -> Mr7R {
                Mr7R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 7;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 8 - Interrupt Mask on line 8" ]
            # [ inline ( always ) ]
            pub fn mr8(&self) -> Mr8R {
                Mr8R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 8;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 9 - Interrupt Mask on line 9" ]
            # [ inline ( always ) ]
            pub fn mr9(&self) -> Mr9R {
                Mr9R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 9;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 10 - Interrupt Mask on line 10" ]
            # [ inline ( always ) ]
            pub fn mr10(&self) -> Mr10R {
                Mr10R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 10;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 11 - Interrupt Mask on line 11" ]
            # [ inline ( always ) ]
            pub fn mr11(&self) -> Mr11R {
                Mr11R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 11;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 12 - Interrupt Mask on line 12" ]
            # [ inline ( always ) ]
            pub fn mr12(&self) -> Mr12R {
                Mr12R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 12;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 13 - Interrupt Mask on line 13" ]
            # [ inline ( always ) ]
            pub fn mr13(&self) -> Mr13R {
                Mr13R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 14 - Interrupt Mask on line 14" ]
            # [ inline ( always ) ]
            pub fn mr14(&self) -> Mr14R {
                Mr14R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 14;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 15 - Interrupt Mask on line 15" ]
            # [ inline ( always ) ]
            pub fn mr15(&self) -> Mr15R {
                Mr15R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 15;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 16 - Interrupt Mask on line 16" ]
            # [ inline ( always ) ]
            pub fn mr16(&self) -> Mr16R {
                Mr16R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 16;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 17 - Interrupt Mask on line 17" ]
            # [ inline ( always ) ]
            pub fn mr17(&self) -> Mr17R {
                Mr17R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 17;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Interrupt Mask on line 0" ]
            # [ inline ( always ) ]
            pub fn mr0(&mut self) -> _Mr0W {
                _Mr0W { w: self }
            }
            # [ doc = "Bit 1 - Interrupt Mask on line 1" ]
            # [ inline ( always ) ]
            pub fn mr1(&mut self) -> _Mr1W {
                _Mr1W { w: self }
            }
            # [ doc = "Bit 2 - Interrupt Mask on line 2" ]
            # [ inline ( always ) ]
            pub fn mr2(&mut self) -> _Mr2W {
                _Mr2W { w: self }
            }
            # [ doc = "Bit 3 - Interrupt Mask on line 3" ]
            # [ inline ( always ) ]
            pub fn mr3(&mut self) -> _Mr3W {
                _Mr3W { w: self }
            }
            # [ doc = "Bit 4 - Interrupt Mask on line 4" ]
            # [ inline ( always ) ]
            pub fn mr4(&mut self) -> _Mr4W {
                _Mr4W { w: self }
            }
            # [ doc = "Bit 5 - Interrupt Mask on line 5" ]
            # [ inline ( always ) ]
            pub fn mr5(&mut self) -> _Mr5W {
                _Mr5W { w: self }
            }
            # [ doc = "Bit 6 - Interrupt Mask on line 6" ]
            # [ inline ( always ) ]
            pub fn mr6(&mut self) -> _Mr6W {
                _Mr6W { w: self }
            }
            # [ doc = "Bit 7 - Interrupt Mask on line 7" ]
            # [ inline ( always ) ]
            pub fn mr7(&mut self) -> _Mr7W {
                _Mr7W { w: self }
            }
            # [ doc = "Bit 8 - Interrupt Mask on line 8" ]
            # [ inline ( always ) ]
            pub fn mr8(&mut self) -> _Mr8W {
                _Mr8W { w: self }
            }
            # [ doc = "Bit 9 - Interrupt Mask on line 9" ]
            # [ inline ( always ) ]
            pub fn mr9(&mut self) -> _Mr9W {
                _Mr9W { w: self }
            }
            # [ doc = "Bit 10 - Interrupt Mask on line 10" ]
            # [ inline ( always ) ]
            pub fn mr10(&mut self) -> _Mr10W {
                _Mr10W { w: self }
            }
            # [ doc = "Bit 11 - Interrupt Mask on line 11" ]
            # [ inline ( always ) ]
            pub fn mr11(&mut self) -> _Mr11W {
                _Mr11W { w: self }
            }
            # [ doc = "Bit 12 - Interrupt Mask on line 12" ]
            # [ inline ( always ) ]
            pub fn mr12(&mut self) -> _Mr12W {
                _Mr12W { w: self }
            }
            # [ doc = "Bit 13 - Interrupt Mask on line 13" ]
            # [ inline ( always ) ]
            pub fn mr13(&mut self) -> _Mr13W {
                _Mr13W { w: self }
            }
            # [ doc = "Bit 14 - Interrupt Mask on line 14" ]
            # [ inline ( always ) ]
            pub fn mr14(&mut self) -> _Mr14W {
                _Mr14W { w: self }
            }
            # [ doc = "Bit 15 - Interrupt Mask on line 15" ]
            # [ inline ( always ) ]
            pub fn mr15(&mut self) -> _Mr15W {
                _Mr15W { w: self }
            }
            # [ doc = "Bit 16 - Interrupt Mask on line 16" ]
            # [ inline ( always ) ]
            pub fn mr16(&mut self) -> _Mr16W {
                _Mr16W { w: self }
            }
            # [ doc = "Bit 17 - Interrupt Mask on line 17" ]
            # [ inline ( always ) ]
            pub fn mr17(&mut self) -> _Mr17W {
                _Mr17W { w: self }
            }
        }
    }
    # [ doc = "Event mask register (EXTI_EMR)" ]
    pub struct Emr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Event mask register (EXTI_EMR)" ]
    pub mod emr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Emr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr0R {
            bits: u8,
        }
        impl Mr0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr1R {
            bits: u8,
        }
        impl Mr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr2R {
            bits: u8,
        }
        impl Mr2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr3R {
            bits: u8,
        }
        impl Mr3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr4R {
            bits: u8,
        }
        impl Mr4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr5R {
            bits: u8,
        }
        impl Mr5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr6R {
            bits: u8,
        }
        impl Mr6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr7R {
            bits: u8,
        }
        impl Mr7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr8R {
            bits: u8,
        }
        impl Mr8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr9R {
            bits: u8,
        }
        impl Mr9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr10R {
            bits: u8,
        }
        impl Mr10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr11R {
            bits: u8,
        }
        impl Mr11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr12R {
            bits: u8,
        }
        impl Mr12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr13R {
            bits: u8,
        }
        impl Mr13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr14R {
            bits: u8,
        }
        impl Mr14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr15R {
            bits: u8,
        }
        impl Mr15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr16R {
            bits: u8,
        }
        impl Mr16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mr17R {
            bits: u8,
        }
        impl Mr17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr16W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mr17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr17W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Event Mask on line 0" ]
            # [ inline ( always ) ]
            pub fn mr0(&self) -> Mr0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr0R { bits }
            }
            # [ doc = "Bit 1 - Event Mask on line 1" ]
            # [ inline ( always ) ]
            pub fn mr1(&self) -> Mr1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr1R { bits }
            }
            # [ doc = "Bit 2 - Event Mask on line 2" ]
            # [ inline ( always ) ]
            pub fn mr2(&self) -> Mr2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr2R { bits }
            }
            # [ doc = "Bit 3 - Event Mask on line 3" ]
            # [ inline ( always ) ]
            pub fn mr3(&self) -> Mr3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr3R { bits }
            }
            # [ doc = "Bit 4 - Event Mask on line 4" ]
            # [ inline ( always ) ]
            pub fn mr4(&self) -> Mr4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr4R { bits }
            }
            # [ doc = "Bit 5 - Event Mask on line 5" ]
            # [ inline ( always ) ]
            pub fn mr5(&self) -> Mr5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr5R { bits }
            }
            # [ doc = "Bit 6 - Event Mask on line 6" ]
            # [ inline ( always ) ]
            pub fn mr6(&self) -> Mr6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr6R { bits }
            }
            # [ doc = "Bit 7 - Event Mask on line 7" ]
            # [ inline ( always ) ]
            pub fn mr7(&self) -> Mr7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr7R { bits }
            }
            # [ doc = "Bit 8 - Event Mask on line 8" ]
            # [ inline ( always ) ]
            pub fn mr8(&self) -> Mr8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr8R { bits }
            }
            # [ doc = "Bit 9 - Event Mask on line 9" ]
            # [ inline ( always ) ]
            pub fn mr9(&self) -> Mr9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr9R { bits }
            }
            # [ doc = "Bit 10 - Event Mask on line 10" ]
            # [ inline ( always ) ]
            pub fn mr10(&self) -> Mr10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr10R { bits }
            }
            # [ doc = "Bit 11 - Event Mask on line 11" ]
            # [ inline ( always ) ]
            pub fn mr11(&self) -> Mr11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr11R { bits }
            }
            # [ doc = "Bit 12 - Event Mask on line 12" ]
            # [ inline ( always ) ]
            pub fn mr12(&self) -> Mr12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr12R { bits }
            }
            # [ doc = "Bit 13 - Event Mask on line 13" ]
            # [ inline ( always ) ]
            pub fn mr13(&self) -> Mr13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr13R { bits }
            }
            # [ doc = "Bit 14 - Event Mask on line 14" ]
            # [ inline ( always ) ]
            pub fn mr14(&self) -> Mr14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr14R { bits }
            }
            # [ doc = "Bit 15 - Event Mask on line 15" ]
            # [ inline ( always ) ]
            pub fn mr15(&self) -> Mr15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr15R { bits }
            }
            # [ doc = "Bit 16 - Event Mask on line 16" ]
            # [ inline ( always ) ]
            pub fn mr16(&self) -> Mr16R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr16R { bits }
            }
            # [ doc = "Bit 17 - Event Mask on line 17" ]
            # [ inline ( always ) ]
            pub fn mr17(&self) -> Mr17R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mr17R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Event Mask on line 0" ]
            # [ inline ( always ) ]
            pub fn mr0(&mut self) -> _Mr0W {
                _Mr0W { w: self }
            }
            # [ doc = "Bit 1 - Event Mask on line 1" ]
            # [ inline ( always ) ]
            pub fn mr1(&mut self) -> _Mr1W {
                _Mr1W { w: self }
            }
            # [ doc = "Bit 2 - Event Mask on line 2" ]
            # [ inline ( always ) ]
            pub fn mr2(&mut self) -> _Mr2W {
                _Mr2W { w: self }
            }
            # [ doc = "Bit 3 - Event Mask on line 3" ]
            # [ inline ( always ) ]
            pub fn mr3(&mut self) -> _Mr3W {
                _Mr3W { w: self }
            }
            # [ doc = "Bit 4 - Event Mask on line 4" ]
            # [ inline ( always ) ]
            pub fn mr4(&mut self) -> _Mr4W {
                _Mr4W { w: self }
            }
            # [ doc = "Bit 5 - Event Mask on line 5" ]
            # [ inline ( always ) ]
            pub fn mr5(&mut self) -> _Mr5W {
                _Mr5W { w: self }
            }
            # [ doc = "Bit 6 - Event Mask on line 6" ]
            # [ inline ( always ) ]
            pub fn mr6(&mut self) -> _Mr6W {
                _Mr6W { w: self }
            }
            # [ doc = "Bit 7 - Event Mask on line 7" ]
            # [ inline ( always ) ]
            pub fn mr7(&mut self) -> _Mr7W {
                _Mr7W { w: self }
            }
            # [ doc = "Bit 8 - Event Mask on line 8" ]
            # [ inline ( always ) ]
            pub fn mr8(&mut self) -> _Mr8W {
                _Mr8W { w: self }
            }
            # [ doc = "Bit 9 - Event Mask on line 9" ]
            # [ inline ( always ) ]
            pub fn mr9(&mut self) -> _Mr9W {
                _Mr9W { w: self }
            }
            # [ doc = "Bit 10 - Event Mask on line 10" ]
            # [ inline ( always ) ]
            pub fn mr10(&mut self) -> _Mr10W {
                _Mr10W { w: self }
            }
            # [ doc = "Bit 11 - Event Mask on line 11" ]
            # [ inline ( always ) ]
            pub fn mr11(&mut self) -> _Mr11W {
                _Mr11W { w: self }
            }
            # [ doc = "Bit 12 - Event Mask on line 12" ]
            # [ inline ( always ) ]
            pub fn mr12(&mut self) -> _Mr12W {
                _Mr12W { w: self }
            }
            # [ doc = "Bit 13 - Event Mask on line 13" ]
            # [ inline ( always ) ]
            pub fn mr13(&mut self) -> _Mr13W {
                _Mr13W { w: self }
            }
            # [ doc = "Bit 14 - Event Mask on line 14" ]
            # [ inline ( always ) ]
            pub fn mr14(&mut self) -> _Mr14W {
                _Mr14W { w: self }
            }
            # [ doc = "Bit 15 - Event Mask on line 15" ]
            # [ inline ( always ) ]
            pub fn mr15(&mut self) -> _Mr15W {
                _Mr15W { w: self }
            }
            # [ doc = "Bit 16 - Event Mask on line 16" ]
            # [ inline ( always ) ]
            pub fn mr16(&mut self) -> _Mr16W {
                _Mr16W { w: self }
            }
            # [ doc = "Bit 17 - Event Mask on line 17" ]
            # [ inline ( always ) ]
            pub fn mr17(&mut self) -> _Mr17W {
                _Mr17W { w: self }
            }
        }
    }
    # [ doc = "Rising Trigger selection register (EXTI_RTSR)" ]
    pub struct Rtsr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Rising Trigger selection register (EXTI_RTSR)" ]
    pub mod rtsr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Rtsr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TR0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Tr0R {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Tr0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tr0R::Disabled => 0,
                    Tr0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Tr0R {
                match bits {
                    0 => Tr0R::Disabled,
                    1 => Tr0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Tr0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Tr0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `TR1`" ]
        pub type Tr1R = Tr0R;
        # [ doc = "Possible values of the field `TR2`" ]
        pub type Tr2R = Tr0R;
        # [ doc = "Possible values of the field `TR3`" ]
        pub type Tr3R = Tr0R;
        # [ doc = "Possible values of the field `TR4`" ]
        pub type Tr4R = Tr0R;
        # [ doc = "Possible values of the field `TR5`" ]
        pub type Tr5R = Tr0R;
        # [ doc = "Possible values of the field `TR6`" ]
        pub type Tr6R = Tr0R;
        # [ doc = "Possible values of the field `TR7`" ]
        pub type Tr7R = Tr0R;
        # [ doc = "Possible values of the field `TR8`" ]
        pub type Tr8R = Tr0R;
        # [ doc = "Possible values of the field `TR9`" ]
        pub type Tr9R = Tr0R;
        # [ doc = "Possible values of the field `TR10`" ]
        pub type Tr10R = Tr0R;
        # [ doc = "Possible values of the field `TR11`" ]
        pub type Tr11R = Tr0R;
        # [ doc = "Possible values of the field `TR12`" ]
        pub type Tr12R = Tr0R;
        # [ doc = "Possible values of the field `TR13`" ]
        pub type Tr13R = Tr0R;
        # [ doc = "Possible values of the field `TR14`" ]
        pub type Tr14R = Tr0R;
        # [ doc = "Possible values of the field `TR15`" ]
        pub type Tr15R = Tr0R;
        # [ doc = "Possible values of the field `TR16`" ]
        pub type Tr16R = Tr0R;
        # [ doc = "Possible values of the field `TR17`" ]
        pub type Tr17R = Tr0R;
        # [ doc = "Values that can be written to the field `TR0`" ]
        pub enum Tr0W {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Tr0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tr0W::Disabled => 0,
                    Tr0W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR1`" ]
        pub type Tr1W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR2`" ]
        pub type Tr2W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR3`" ]
        pub type Tr3W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR4`" ]
        pub type Tr4W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR5`" ]
        pub type Tr5W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR6`" ]
        pub type Tr6W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR7`" ]
        pub type Tr7W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR8`" ]
        pub type Tr8W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR9`" ]
        pub type Tr9W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR10`" ]
        pub type Tr10W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR11`" ]
        pub type Tr11W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR12`" ]
        pub type Tr12W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR13`" ]
        pub type Tr13W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR14`" ]
        pub type Tr14W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR15`" ]
        pub type Tr15W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR16`" ]
        pub type Tr16W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr16W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr16W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR17`" ]
        pub type Tr17W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr17W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr17W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Rising trigger event configuration of line 0" ]
            # [ inline ( always ) ]
            pub fn tr0(&self) -> Tr0R {
                Tr0R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 1 - Rising trigger event configuration of line 1" ]
            # [ inline ( always ) ]
            pub fn tr1(&self) -> Tr1R {
                Tr1R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 1;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 2 - Rising trigger event configuration of line 2" ]
            # [ inline ( always ) ]
            pub fn tr2(&self) -> Tr2R {
                Tr2R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 2;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 3 - Rising trigger event configuration of line 3" ]
            # [ inline ( always ) ]
            pub fn tr3(&self) -> Tr3R {
                Tr3R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 3;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 4 - Rising trigger event configuration of line 4" ]
            # [ inline ( always ) ]
            pub fn tr4(&self) -> Tr4R {
                Tr4R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 4;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 5 - Rising trigger event configuration of line 5" ]
            # [ inline ( always ) ]
            pub fn tr5(&self) -> Tr5R {
                Tr5R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 5;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 6 - Rising trigger event configuration of line 6" ]
            # [ inline ( always ) ]
            pub fn tr6(&self) -> Tr6R {
                Tr6R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 6;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 7 - Rising trigger event configuration of line 7" ]
            # [ inline ( always ) ]
            pub fn tr7(&self) -> Tr7R {
                Tr7R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 7;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 8 - Rising trigger event configuration of line 8" ]
            # [ inline ( always ) ]
            pub fn tr8(&self) -> Tr8R {
                Tr8R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 8;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 9 - Rising trigger event configuration of line 9" ]
            # [ inline ( always ) ]
            pub fn tr9(&self) -> Tr9R {
                Tr9R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 9;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 10 - Rising trigger event configuration of line 10" ]
            # [ inline ( always ) ]
            pub fn tr10(&self) -> Tr10R {
                Tr10R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 10;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 11 - Rising trigger event configuration of line 11" ]
            # [ inline ( always ) ]
            pub fn tr11(&self) -> Tr11R {
                Tr11R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 11;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 12 - Rising trigger event configuration of line 12" ]
            # [ inline ( always ) ]
            pub fn tr12(&self) -> Tr12R {
                Tr12R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 12;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 13 - Rising trigger event configuration of line 13" ]
            # [ inline ( always ) ]
            pub fn tr13(&self) -> Tr13R {
                Tr13R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 14 - Rising trigger event configuration of line 14" ]
            # [ inline ( always ) ]
            pub fn tr14(&self) -> Tr14R {
                Tr14R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 14;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 15 - Rising trigger event configuration of line 15" ]
            # [ inline ( always ) ]
            pub fn tr15(&self) -> Tr15R {
                Tr15R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 15;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 16 - Rising trigger event configuration of line 16" ]
            # [ inline ( always ) ]
            pub fn tr16(&self) -> Tr16R {
                Tr16R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 16;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 17 - Rising trigger event configuration of line 17" ]
            # [ inline ( always ) ]
            pub fn tr17(&self) -> Tr17R {
                Tr17R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 17;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Rising trigger event configuration of line 0" ]
            # [ inline ( always ) ]
            pub fn tr0(&mut self) -> _Tr0W {
                _Tr0W { w: self }
            }
            # [ doc = "Bit 1 - Rising trigger event configuration of line 1" ]
            # [ inline ( always ) ]
            pub fn tr1(&mut self) -> _Tr1W {
                _Tr1W { w: self }
            }
            # [ doc = "Bit 2 - Rising trigger event configuration of line 2" ]
            # [ inline ( always ) ]
            pub fn tr2(&mut self) -> _Tr2W {
                _Tr2W { w: self }
            }
            # [ doc = "Bit 3 - Rising trigger event configuration of line 3" ]
            # [ inline ( always ) ]
            pub fn tr3(&mut self) -> _Tr3W {
                _Tr3W { w: self }
            }
            # [ doc = "Bit 4 - Rising trigger event configuration of line 4" ]
            # [ inline ( always ) ]
            pub fn tr4(&mut self) -> _Tr4W {
                _Tr4W { w: self }
            }
            # [ doc = "Bit 5 - Rising trigger event configuration of line 5" ]
            # [ inline ( always ) ]
            pub fn tr5(&mut self) -> _Tr5W {
                _Tr5W { w: self }
            }
            # [ doc = "Bit 6 - Rising trigger event configuration of line 6" ]
            # [ inline ( always ) ]
            pub fn tr6(&mut self) -> _Tr6W {
                _Tr6W { w: self }
            }
            # [ doc = "Bit 7 - Rising trigger event configuration of line 7" ]
            # [ inline ( always ) ]
            pub fn tr7(&mut self) -> _Tr7W {
                _Tr7W { w: self }
            }
            # [ doc = "Bit 8 - Rising trigger event configuration of line 8" ]
            # [ inline ( always ) ]
            pub fn tr8(&mut self) -> _Tr8W {
                _Tr8W { w: self }
            }
            # [ doc = "Bit 9 - Rising trigger event configuration of line 9" ]
            # [ inline ( always ) ]
            pub fn tr9(&mut self) -> _Tr9W {
                _Tr9W { w: self }
            }
            # [ doc = "Bit 10 - Rising trigger event configuration of line 10" ]
            # [ inline ( always ) ]
            pub fn tr10(&mut self) -> _Tr10W {
                _Tr10W { w: self }
            }
            # [ doc = "Bit 11 - Rising trigger event configuration of line 11" ]
            # [ inline ( always ) ]
            pub fn tr11(&mut self) -> _Tr11W {
                _Tr11W { w: self }
            }
            # [ doc = "Bit 12 - Rising trigger event configuration of line 12" ]
            # [ inline ( always ) ]
            pub fn tr12(&mut self) -> _Tr12W {
                _Tr12W { w: self }
            }
            # [ doc = "Bit 13 - Rising trigger event configuration of line 13" ]
            # [ inline ( always ) ]
            pub fn tr13(&mut self) -> _Tr13W {
                _Tr13W { w: self }
            }
            # [ doc = "Bit 14 - Rising trigger event configuration of line 14" ]
            # [ inline ( always ) ]
            pub fn tr14(&mut self) -> _Tr14W {
                _Tr14W { w: self }
            }
            # [ doc = "Bit 15 - Rising trigger event configuration of line 15" ]
            # [ inline ( always ) ]
            pub fn tr15(&mut self) -> _Tr15W {
                _Tr15W { w: self }
            }
            # [ doc = "Bit 16 - Rising trigger event configuration of line 16" ]
            # [ inline ( always ) ]
            pub fn tr16(&mut self) -> _Tr16W {
                _Tr16W { w: self }
            }
            # [ doc = "Bit 17 - Rising trigger event configuration of line 17" ]
            # [ inline ( always ) ]
            pub fn tr17(&mut self) -> _Tr17W {
                _Tr17W { w: self }
            }
        }
    }
    # [ doc = "Falling Trigger selection register (EXTI_FTSR)" ]
    pub struct Ftsr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Falling Trigger selection register (EXTI_FTSR)" ]
    pub mod ftsr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ftsr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TR0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Tr0R {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Tr0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tr0R::Disabled => 0,
                    Tr0R::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Tr0R {
                match bits {
                    0 => Tr0R::Disabled,
                    1 => Tr0R::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == Tr0R::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == Tr0R::Enabled
            }
        }
        # [ doc = "Possible values of the field `TR1`" ]
        pub type Tr1R = Tr0R;
        # [ doc = "Possible values of the field `TR2`" ]
        pub type Tr2R = Tr0R;
        # [ doc = "Possible values of the field `TR3`" ]
        pub type Tr3R = Tr0R;
        # [ doc = "Possible values of the field `TR4`" ]
        pub type Tr4R = Tr0R;
        # [ doc = "Possible values of the field `TR5`" ]
        pub type Tr5R = Tr0R;
        # [ doc = "Possible values of the field `TR6`" ]
        pub type Tr6R = Tr0R;
        # [ doc = "Possible values of the field `TR7`" ]
        pub type Tr7R = Tr0R;
        # [ doc = "Possible values of the field `TR8`" ]
        pub type Tr8R = Tr0R;
        # [ doc = "Possible values of the field `TR9`" ]
        pub type Tr9R = Tr0R;
        # [ doc = "Possible values of the field `TR10`" ]
        pub type Tr10R = Tr0R;
        # [ doc = "Possible values of the field `TR11`" ]
        pub type Tr11R = Tr0R;
        # [ doc = "Possible values of the field `TR12`" ]
        pub type Tr12R = Tr0R;
        # [ doc = "Possible values of the field `TR13`" ]
        pub type Tr13R = Tr0R;
        # [ doc = "Possible values of the field `TR14`" ]
        pub type Tr14R = Tr0R;
        # [ doc = "Possible values of the field `TR15`" ]
        pub type Tr15R = Tr0R;
        # [ doc = "Possible values of the field `TR16`" ]
        pub type Tr16R = Tr0R;
        # [ doc = "Possible values of the field `TR17`" ]
        pub type Tr17R = Tr0R;
        # [ doc = "Values that can be written to the field `TR0`" ]
        pub enum Tr0W {
            # [ doc = "Disabled." ]
            Disabled,
            # [ doc = "Enabled." ]
            Enabled,
        }
        impl Tr0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tr0W::Disabled => 0,
                    Tr0W::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR1`" ]
        pub type Tr1W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR2`" ]
        pub type Tr2W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr2W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR3`" ]
        pub type Tr3W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr3W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR4`" ]
        pub type Tr4W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr4W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR5`" ]
        pub type Tr5W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr5W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR6`" ]
        pub type Tr6W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr6W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR7`" ]
        pub type Tr7W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr7W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR8`" ]
        pub type Tr8W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr8W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR9`" ]
        pub type Tr9W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr9W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR10`" ]
        pub type Tr10W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr10W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR11`" ]
        pub type Tr11W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr11W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR12`" ]
        pub type Tr12W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr12W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR13`" ]
        pub type Tr13W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr13W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR14`" ]
        pub type Tr14W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr14W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR15`" ]
        pub type Tr15W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr15W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR16`" ]
        pub type Tr16W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr16W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr16W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TR17`" ]
        pub type Tr17W = Tr0W;
        # [ doc = r" Proxy" ]
        pub struct _Tr17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr17W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Tr17W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Disabled." ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            # [ doc = "Enabled." ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Falling trigger event configuration of line 0" ]
            # [ inline ( always ) ]
            pub fn tr0(&self) -> Tr0R {
                Tr0R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 1 - Falling trigger event configuration of line 1" ]
            # [ inline ( always ) ]
            pub fn tr1(&self) -> Tr1R {
                Tr1R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 1;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 2 - Falling trigger event configuration of line 2" ]
            # [ inline ( always ) ]
            pub fn tr2(&self) -> Tr2R {
                Tr2R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 2;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 3 - Falling trigger event configuration of line 3" ]
            # [ inline ( always ) ]
            pub fn tr3(&self) -> Tr3R {
                Tr3R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 3;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 4 - Falling trigger event configuration of line 4" ]
            # [ inline ( always ) ]
            pub fn tr4(&self) -> Tr4R {
                Tr4R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 4;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 5 - Falling trigger event configuration of line 5" ]
            # [ inline ( always ) ]
            pub fn tr5(&self) -> Tr5R {
                Tr5R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 5;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 6 - Falling trigger event configuration of line 6" ]
            # [ inline ( always ) ]
            pub fn tr6(&self) -> Tr6R {
                Tr6R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 6;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 7 - Falling trigger event configuration of line 7" ]
            # [ inline ( always ) ]
            pub fn tr7(&self) -> Tr7R {
                Tr7R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 7;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 8 - Falling trigger event configuration of line 8" ]
            # [ inline ( always ) ]
            pub fn tr8(&self) -> Tr8R {
                Tr8R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 8;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 9 - Falling trigger event configuration of line 9" ]
            # [ inline ( always ) ]
            pub fn tr9(&self) -> Tr9R {
                Tr9R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 9;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 10 - Falling trigger event configuration of line 10" ]
            # [ inline ( always ) ]
            pub fn tr10(&self) -> Tr10R {
                Tr10R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 10;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 11 - Falling trigger event configuration of line 11" ]
            # [ inline ( always ) ]
            pub fn tr11(&self) -> Tr11R {
                Tr11R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 11;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 12 - Falling trigger event configuration of line 12" ]
            # [ inline ( always ) ]
            pub fn tr12(&self) -> Tr12R {
                Tr12R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 12;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 13 - Falling trigger event configuration of line 13" ]
            # [ inline ( always ) ]
            pub fn tr13(&self) -> Tr13R {
                Tr13R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 14 - Falling trigger event configuration of line 14" ]
            # [ inline ( always ) ]
            pub fn tr14(&self) -> Tr14R {
                Tr14R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 14;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 15 - Falling trigger event configuration of line 15" ]
            # [ inline ( always ) ]
            pub fn tr15(&self) -> Tr15R {
                Tr15R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 15;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 16 - Falling trigger event configuration of line 16" ]
            # [ inline ( always ) ]
            pub fn tr16(&self) -> Tr16R {
                Tr16R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 16;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            # [ doc = "Bit 17 - Falling trigger event configuration of line 17" ]
            # [ inline ( always ) ]
            pub fn tr17(&self) -> Tr17R {
                Tr17R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 17;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Falling trigger event configuration of line 0" ]
            # [ inline ( always ) ]
            pub fn tr0(&mut self) -> _Tr0W {
                _Tr0W { w: self }
            }
            # [ doc = "Bit 1 - Falling trigger event configuration of line 1" ]
            # [ inline ( always ) ]
            pub fn tr1(&mut self) -> _Tr1W {
                _Tr1W { w: self }
            }
            # [ doc = "Bit 2 - Falling trigger event configuration of line 2" ]
            # [ inline ( always ) ]
            pub fn tr2(&mut self) -> _Tr2W {
                _Tr2W { w: self }
            }
            # [ doc = "Bit 3 - Falling trigger event configuration of line 3" ]
            # [ inline ( always ) ]
            pub fn tr3(&mut self) -> _Tr3W {
                _Tr3W { w: self }
            }
            # [ doc = "Bit 4 - Falling trigger event configuration of line 4" ]
            # [ inline ( always ) ]
            pub fn tr4(&mut self) -> _Tr4W {
                _Tr4W { w: self }
            }
            # [ doc = "Bit 5 - Falling trigger event configuration of line 5" ]
            # [ inline ( always ) ]
            pub fn tr5(&mut self) -> _Tr5W {
                _Tr5W { w: self }
            }
            # [ doc = "Bit 6 - Falling trigger event configuration of line 6" ]
            # [ inline ( always ) ]
            pub fn tr6(&mut self) -> _Tr6W {
                _Tr6W { w: self }
            }
            # [ doc = "Bit 7 - Falling trigger event configuration of line 7" ]
            # [ inline ( always ) ]
            pub fn tr7(&mut self) -> _Tr7W {
                _Tr7W { w: self }
            }
            # [ doc = "Bit 8 - Falling trigger event configuration of line 8" ]
            # [ inline ( always ) ]
            pub fn tr8(&mut self) -> _Tr8W {
                _Tr8W { w: self }
            }
            # [ doc = "Bit 9 - Falling trigger event configuration of line 9" ]
            # [ inline ( always ) ]
            pub fn tr9(&mut self) -> _Tr9W {
                _Tr9W { w: self }
            }
            # [ doc = "Bit 10 - Falling trigger event configuration of line 10" ]
            # [ inline ( always ) ]
            pub fn tr10(&mut self) -> _Tr10W {
                _Tr10W { w: self }
            }
            # [ doc = "Bit 11 - Falling trigger event configuration of line 11" ]
            # [ inline ( always ) ]
            pub fn tr11(&mut self) -> _Tr11W {
                _Tr11W { w: self }
            }
            # [ doc = "Bit 12 - Falling trigger event configuration of line 12" ]
            # [ inline ( always ) ]
            pub fn tr12(&mut self) -> _Tr12W {
                _Tr12W { w: self }
            }
            # [ doc = "Bit 13 - Falling trigger event configuration of line 13" ]
            # [ inline ( always ) ]
            pub fn tr13(&mut self) -> _Tr13W {
                _Tr13W { w: self }
            }
            # [ doc = "Bit 14 - Falling trigger event configuration of line 14" ]
            # [ inline ( always ) ]
            pub fn tr14(&mut self) -> _Tr14W {
                _Tr14W { w: self }
            }
            # [ doc = "Bit 15 - Falling trigger event configuration of line 15" ]
            # [ inline ( always ) ]
            pub fn tr15(&mut self) -> _Tr15W {
                _Tr15W { w: self }
            }
            # [ doc = "Bit 16 - Falling trigger event configuration of line 16" ]
            # [ inline ( always ) ]
            pub fn tr16(&mut self) -> _Tr16W {
                _Tr16W { w: self }
            }
            # [ doc = "Bit 17 - Falling trigger event configuration of line 17" ]
            # [ inline ( always ) ]
            pub fn tr17(&mut self) -> _Tr17W {
                _Tr17W { w: self }
            }
        }
    }
    # [ doc = "Software interrupt event register (EXTI_SWIER)" ]
    pub struct Swier {
        register: VolatileCell<u32>,
    }
    # [ doc = "Software interrupt event register (EXTI_SWIER)" ]
    pub mod swier {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Swier {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier0R {
            bits: u8,
        }
        impl Swier0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier1R {
            bits: u8,
        }
        impl Swier1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier2R {
            bits: u8,
        }
        impl Swier2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier3R {
            bits: u8,
        }
        impl Swier3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier4R {
            bits: u8,
        }
        impl Swier4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier5R {
            bits: u8,
        }
        impl Swier5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier6R {
            bits: u8,
        }
        impl Swier6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier7R {
            bits: u8,
        }
        impl Swier7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier8R {
            bits: u8,
        }
        impl Swier8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier9R {
            bits: u8,
        }
        impl Swier9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier10R {
            bits: u8,
        }
        impl Swier10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier11R {
            bits: u8,
        }
        impl Swier11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier12R {
            bits: u8,
        }
        impl Swier12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier13R {
            bits: u8,
        }
        impl Swier13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier14R {
            bits: u8,
        }
        impl Swier14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier15R {
            bits: u8,
        }
        impl Swier15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier16R {
            bits: u8,
        }
        impl Swier16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Swier17R {
            bits: u8,
        }
        impl Swier17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier16W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swier17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier17W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Software Interrupt on line 0" ]
            # [ inline ( always ) ]
            pub fn swier0(&self) -> Swier0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier0R { bits }
            }
            # [ doc = "Bit 1 - Software Interrupt on line 1" ]
            # [ inline ( always ) ]
            pub fn swier1(&self) -> Swier1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier1R { bits }
            }
            # [ doc = "Bit 2 - Software Interrupt on line 2" ]
            # [ inline ( always ) ]
            pub fn swier2(&self) -> Swier2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier2R { bits }
            }
            # [ doc = "Bit 3 - Software Interrupt on line 3" ]
            # [ inline ( always ) ]
            pub fn swier3(&self) -> Swier3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier3R { bits }
            }
            # [ doc = "Bit 4 - Software Interrupt on line 4" ]
            # [ inline ( always ) ]
            pub fn swier4(&self) -> Swier4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier4R { bits }
            }
            # [ doc = "Bit 5 - Software Interrupt on line 5" ]
            # [ inline ( always ) ]
            pub fn swier5(&self) -> Swier5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier5R { bits }
            }
            # [ doc = "Bit 6 - Software Interrupt on line 6" ]
            # [ inline ( always ) ]
            pub fn swier6(&self) -> Swier6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier6R { bits }
            }
            # [ doc = "Bit 7 - Software Interrupt on line 7" ]
            # [ inline ( always ) ]
            pub fn swier7(&self) -> Swier7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier7R { bits }
            }
            # [ doc = "Bit 8 - Software Interrupt on line 8" ]
            # [ inline ( always ) ]
            pub fn swier8(&self) -> Swier8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier8R { bits }
            }
            # [ doc = "Bit 9 - Software Interrupt on line 9" ]
            # [ inline ( always ) ]
            pub fn swier9(&self) -> Swier9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier9R { bits }
            }
            # [ doc = "Bit 10 - Software Interrupt on line 10" ]
            # [ inline ( always ) ]
            pub fn swier10(&self) -> Swier10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier10R { bits }
            }
            # [ doc = "Bit 11 - Software Interrupt on line 11" ]
            # [ inline ( always ) ]
            pub fn swier11(&self) -> Swier11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier11R { bits }
            }
            # [ doc = "Bit 12 - Software Interrupt on line 12" ]
            # [ inline ( always ) ]
            pub fn swier12(&self) -> Swier12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier12R { bits }
            }
            # [ doc = "Bit 13 - Software Interrupt on line 13" ]
            # [ inline ( always ) ]
            pub fn swier13(&self) -> Swier13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier13R { bits }
            }
            # [ doc = "Bit 14 - Software Interrupt on line 14" ]
            # [ inline ( always ) ]
            pub fn swier14(&self) -> Swier14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier14R { bits }
            }
            # [ doc = "Bit 15 - Software Interrupt on line 15" ]
            # [ inline ( always ) ]
            pub fn swier15(&self) -> Swier15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier15R { bits }
            }
            # [ doc = "Bit 16 - Software Interrupt on line 16" ]
            # [ inline ( always ) ]
            pub fn swier16(&self) -> Swier16R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier16R { bits }
            }
            # [ doc = "Bit 17 - Software Interrupt on line 17" ]
            # [ inline ( always ) ]
            pub fn swier17(&self) -> Swier17R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Swier17R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Software Interrupt on line 0" ]
            # [ inline ( always ) ]
            pub fn swier0(&mut self) -> _Swier0W {
                _Swier0W { w: self }
            }
            # [ doc = "Bit 1 - Software Interrupt on line 1" ]
            # [ inline ( always ) ]
            pub fn swier1(&mut self) -> _Swier1W {
                _Swier1W { w: self }
            }
            # [ doc = "Bit 2 - Software Interrupt on line 2" ]
            # [ inline ( always ) ]
            pub fn swier2(&mut self) -> _Swier2W {
                _Swier2W { w: self }
            }
            # [ doc = "Bit 3 - Software Interrupt on line 3" ]
            # [ inline ( always ) ]
            pub fn swier3(&mut self) -> _Swier3W {
                _Swier3W { w: self }
            }
            # [ doc = "Bit 4 - Software Interrupt on line 4" ]
            # [ inline ( always ) ]
            pub fn swier4(&mut self) -> _Swier4W {
                _Swier4W { w: self }
            }
            # [ doc = "Bit 5 - Software Interrupt on line 5" ]
            # [ inline ( always ) ]
            pub fn swier5(&mut self) -> _Swier5W {
                _Swier5W { w: self }
            }
            # [ doc = "Bit 6 - Software Interrupt on line 6" ]
            # [ inline ( always ) ]
            pub fn swier6(&mut self) -> _Swier6W {
                _Swier6W { w: self }
            }
            # [ doc = "Bit 7 - Software Interrupt on line 7" ]
            # [ inline ( always ) ]
            pub fn swier7(&mut self) -> _Swier7W {
                _Swier7W { w: self }
            }
            # [ doc = "Bit 8 - Software Interrupt on line 8" ]
            # [ inline ( always ) ]
            pub fn swier8(&mut self) -> _Swier8W {
                _Swier8W { w: self }
            }
            # [ doc = "Bit 9 - Software Interrupt on line 9" ]
            # [ inline ( always ) ]
            pub fn swier9(&mut self) -> _Swier9W {
                _Swier9W { w: self }
            }
            # [ doc = "Bit 10 - Software Interrupt on line 10" ]
            # [ inline ( always ) ]
            pub fn swier10(&mut self) -> _Swier10W {
                _Swier10W { w: self }
            }
            # [ doc = "Bit 11 - Software Interrupt on line 11" ]
            # [ inline ( always ) ]
            pub fn swier11(&mut self) -> _Swier11W {
                _Swier11W { w: self }
            }
            # [ doc = "Bit 12 - Software Interrupt on line 12" ]
            # [ inline ( always ) ]
            pub fn swier12(&mut self) -> _Swier12W {
                _Swier12W { w: self }
            }
            # [ doc = "Bit 13 - Software Interrupt on line 13" ]
            # [ inline ( always ) ]
            pub fn swier13(&mut self) -> _Swier13W {
                _Swier13W { w: self }
            }
            # [ doc = "Bit 14 - Software Interrupt on line 14" ]
            # [ inline ( always ) ]
            pub fn swier14(&mut self) -> _Swier14W {
                _Swier14W { w: self }
            }
            # [ doc = "Bit 15 - Software Interrupt on line 15" ]
            # [ inline ( always ) ]
            pub fn swier15(&mut self) -> _Swier15W {
                _Swier15W { w: self }
            }
            # [ doc = "Bit 16 - Software Interrupt on line 16" ]
            # [ inline ( always ) ]
            pub fn swier16(&mut self) -> _Swier16W {
                _Swier16W { w: self }
            }
            # [ doc = "Bit 17 - Software Interrupt on line 17" ]
            # [ inline ( always ) ]
            pub fn swier17(&mut self) -> _Swier17W {
                _Swier17W { w: self }
            }
        }
    }
    # [ doc = "Pending register (EXTI_PR)" ]
    pub struct Pr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Pending register (EXTI_PR)" ]
    pub mod pr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr0R {
            bits: u8,
        }
        impl Pr0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr1R {
            bits: u8,
        }
        impl Pr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr2R {
            bits: u8,
        }
        impl Pr2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr3R {
            bits: u8,
        }
        impl Pr3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr4R {
            bits: u8,
        }
        impl Pr4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr5R {
            bits: u8,
        }
        impl Pr5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr6R {
            bits: u8,
        }
        impl Pr6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr7R {
            bits: u8,
        }
        impl Pr7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr8R {
            bits: u8,
        }
        impl Pr8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr9R {
            bits: u8,
        }
        impl Pr9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr10R {
            bits: u8,
        }
        impl Pr10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr11R {
            bits: u8,
        }
        impl Pr11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr12R {
            bits: u8,
        }
        impl Pr12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr13R {
            bits: u8,
        }
        impl Pr13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr14R {
            bits: u8,
        }
        impl Pr14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr15R {
            bits: u8,
        }
        impl Pr15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr16R {
            bits: u8,
        }
        impl Pr16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pr17R {
            bits: u8,
        }
        impl Pr17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr16W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pr17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr17W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Pending bit 0" ]
            # [ inline ( always ) ]
            pub fn pr0(&self) -> Pr0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr0R { bits }
            }
            # [ doc = "Bit 1 - Pending bit 1" ]
            # [ inline ( always ) ]
            pub fn pr1(&self) -> Pr1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr1R { bits }
            }
            # [ doc = "Bit 2 - Pending bit 2" ]
            # [ inline ( always ) ]
            pub fn pr2(&self) -> Pr2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr2R { bits }
            }
            # [ doc = "Bit 3 - Pending bit 3" ]
            # [ inline ( always ) ]
            pub fn pr3(&self) -> Pr3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr3R { bits }
            }
            # [ doc = "Bit 4 - Pending bit 4" ]
            # [ inline ( always ) ]
            pub fn pr4(&self) -> Pr4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr4R { bits }
            }
            # [ doc = "Bit 5 - Pending bit 5" ]
            # [ inline ( always ) ]
            pub fn pr5(&self) -> Pr5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr5R { bits }
            }
            # [ doc = "Bit 6 - Pending bit 6" ]
            # [ inline ( always ) ]
            pub fn pr6(&self) -> Pr6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr6R { bits }
            }
            # [ doc = "Bit 7 - Pending bit 7" ]
            # [ inline ( always ) ]
            pub fn pr7(&self) -> Pr7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr7R { bits }
            }
            # [ doc = "Bit 8 - Pending bit 8" ]
            # [ inline ( always ) ]
            pub fn pr8(&self) -> Pr8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr8R { bits }
            }
            # [ doc = "Bit 9 - Pending bit 9" ]
            # [ inline ( always ) ]
            pub fn pr9(&self) -> Pr9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr9R { bits }
            }
            # [ doc = "Bit 10 - Pending bit 10" ]
            # [ inline ( always ) ]
            pub fn pr10(&self) -> Pr10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr10R { bits }
            }
            # [ doc = "Bit 11 - Pending bit 11" ]
            # [ inline ( always ) ]
            pub fn pr11(&self) -> Pr11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr11R { bits }
            }
            # [ doc = "Bit 12 - Pending bit 12" ]
            # [ inline ( always ) ]
            pub fn pr12(&self) -> Pr12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr12R { bits }
            }
            # [ doc = "Bit 13 - Pending bit 13" ]
            # [ inline ( always ) ]
            pub fn pr13(&self) -> Pr13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr13R { bits }
            }
            # [ doc = "Bit 14 - Pending bit 14" ]
            # [ inline ( always ) ]
            pub fn pr14(&self) -> Pr14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr14R { bits }
            }
            # [ doc = "Bit 15 - Pending bit 15" ]
            # [ inline ( always ) ]
            pub fn pr15(&self) -> Pr15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr15R { bits }
            }
            # [ doc = "Bit 16 - Pending bit 16" ]
            # [ inline ( always ) ]
            pub fn pr16(&self) -> Pr16R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr16R { bits }
            }
            # [ doc = "Bit 17 - Pending bit 17" ]
            # [ inline ( always ) ]
            pub fn pr17(&self) -> Pr17R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pr17R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Pending bit 0" ]
            # [ inline ( always ) ]
            pub fn pr0(&mut self) -> _Pr0W {
                _Pr0W { w: self }
            }
            # [ doc = "Bit 1 - Pending bit 1" ]
            # [ inline ( always ) ]
            pub fn pr1(&mut self) -> _Pr1W {
                _Pr1W { w: self }
            }
            # [ doc = "Bit 2 - Pending bit 2" ]
            # [ inline ( always ) ]
            pub fn pr2(&mut self) -> _Pr2W {
                _Pr2W { w: self }
            }
            # [ doc = "Bit 3 - Pending bit 3" ]
            # [ inline ( always ) ]
            pub fn pr3(&mut self) -> _Pr3W {
                _Pr3W { w: self }
            }
            # [ doc = "Bit 4 - Pending bit 4" ]
            # [ inline ( always ) ]
            pub fn pr4(&mut self) -> _Pr4W {
                _Pr4W { w: self }
            }
            # [ doc = "Bit 5 - Pending bit 5" ]
            # [ inline ( always ) ]
            pub fn pr5(&mut self) -> _Pr5W {
                _Pr5W { w: self }
            }
            # [ doc = "Bit 6 - Pending bit 6" ]
            # [ inline ( always ) ]
            pub fn pr6(&mut self) -> _Pr6W {
                _Pr6W { w: self }
            }
            # [ doc = "Bit 7 - Pending bit 7" ]
            # [ inline ( always ) ]
            pub fn pr7(&mut self) -> _Pr7W {
                _Pr7W { w: self }
            }
            # [ doc = "Bit 8 - Pending bit 8" ]
            # [ inline ( always ) ]
            pub fn pr8(&mut self) -> _Pr8W {
                _Pr8W { w: self }
            }
            # [ doc = "Bit 9 - Pending bit 9" ]
            # [ inline ( always ) ]
            pub fn pr9(&mut self) -> _Pr9W {
                _Pr9W { w: self }
            }
            # [ doc = "Bit 10 - Pending bit 10" ]
            # [ inline ( always ) ]
            pub fn pr10(&mut self) -> _Pr10W {
                _Pr10W { w: self }
            }
            # [ doc = "Bit 11 - Pending bit 11" ]
            # [ inline ( always ) ]
            pub fn pr11(&mut self) -> _Pr11W {
                _Pr11W { w: self }
            }
            # [ doc = "Bit 12 - Pending bit 12" ]
            # [ inline ( always ) ]
            pub fn pr12(&mut self) -> _Pr12W {
                _Pr12W { w: self }
            }
            # [ doc = "Bit 13 - Pending bit 13" ]
            # [ inline ( always ) ]
            pub fn pr13(&mut self) -> _Pr13W {
                _Pr13W { w: self }
            }
            # [ doc = "Bit 14 - Pending bit 14" ]
            # [ inline ( always ) ]
            pub fn pr14(&mut self) -> _Pr14W {
                _Pr14W { w: self }
            }
            # [ doc = "Bit 15 - Pending bit 15" ]
            # [ inline ( always ) ]
            pub fn pr15(&mut self) -> _Pr15W {
                _Pr15W { w: self }
            }
            # [ doc = "Bit 16 - Pending bit 16" ]
            # [ inline ( always ) ]
            pub fn pr16(&mut self) -> _Pr16W {
                _Pr16W { w: self }
            }
            # [ doc = "Bit 17 - Pending bit 17" ]
            # [ inline ( always ) ]
            pub fn pr17(&mut self) -> _Pr17W {
                _Pr17W { w: self }
            }
        }
    }
}
# [ doc = "EXTI" ]
pub struct Exti {
    register_block: exti::RegisterBlock,
}
impl Deref for Exti {
    type Target = exti::RegisterBlock;
    fn deref(&self) -> &exti::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "DMA controller" ]
pub const DMA1: Peripheral<Dma1> = unsafe { Peripheral::new(1073872896) };
# [ doc = "DMA controller" ]
pub mod dma1 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - DMA interrupt status register (DMA_ISR)" ]
        pub isr: Isr,
        # [ doc = "0x04 - DMA interrupt flag clear register (DMA_IFCR)" ]
        pub ifcr: Ifcr,
        # [ doc = "0x08 - DMA channel configuration register (DMA_CCR)" ]
        pub ccr1: Ccr1,
        # [ doc = "0x0c - DMA channel 1 number of data register" ]
        pub cndtr1: Cndtr1,
        # [ doc = "0x10 - DMA channel 1 peripheral address register" ]
        pub cpar1: Cpar1,
        # [ doc = "0x14 - DMA channel 1 memory address register" ]
        pub cmar1: Cmar1,
        _reserved0: [u8; 4usize],
        # [ doc = "0x1c - DMA channel configuration register (DMA_CCR)" ]
        pub ccr2: Ccr2,
        # [ doc = "0x20 - DMA channel 2 number of data register" ]
        pub cndtr2: Cndtr2,
        # [ doc = "0x24 - DMA channel 2 peripheral address register" ]
        pub cpar2: Cpar2,
        # [ doc = "0x28 - DMA channel 2 memory address register" ]
        pub cmar2: Cmar2,
        _reserved1: [u8; 4usize],
        # [ doc = "0x30 - DMA channel configuration register (DMA_CCR)" ]
        pub ccr3: Ccr3,
        # [ doc = "0x34 - DMA channel 3 number of data register" ]
        pub cndtr3: Cndtr3,
        # [ doc = "0x38 - DMA channel 3 peripheral address register" ]
        pub cpar3: Cpar3,
        # [ doc = "0x3c - DMA channel 3 memory address register" ]
        pub cmar3: Cmar3,
        _reserved2: [u8; 4usize],
        # [ doc = "0x44 - DMA channel configuration register (DMA_CCR)" ]
        pub ccr4: Ccr4,
        # [ doc = "0x48 - DMA channel 4 number of data register" ]
        pub cndtr4: Cndtr4,
        # [ doc = "0x4c - DMA channel 4 peripheral address register" ]
        pub cpar4: Cpar4,
        # [ doc = "0x50 - DMA channel 4 memory address register" ]
        pub cmar4: Cmar4,
        _reserved3: [u8; 4usize],
        # [ doc = "0x58 - DMA channel configuration register (DMA_CCR)" ]
        pub ccr5: Ccr5,
        # [ doc = "0x5c - DMA channel 5 number of data register" ]
        pub cndtr5: Cndtr5,
        # [ doc = "0x60 - DMA channel 5 peripheral address register" ]
        pub cpar5: Cpar5,
        # [ doc = "0x64 - DMA channel 5 memory address register" ]
        pub cmar5: Cmar5,
        _reserved4: [u8; 4usize],
        # [ doc = "0x6c - DMA channel configuration register (DMA_CCR)" ]
        pub ccr6: Ccr6,
        # [ doc = "0x70 - DMA channel 6 number of data register" ]
        pub cndtr6: Cndtr6,
        # [ doc = "0x74 - DMA channel 6 peripheral address register" ]
        pub cpar6: Cpar6,
        # [ doc = "0x78 - DMA channel 6 memory address register" ]
        pub cmar6: Cmar6,
        _reserved5: [u8; 4usize],
        # [ doc = "0x80 - DMA channel configuration register (DMA_CCR)" ]
        pub ccr7: Ccr7,
        # [ doc = "0x84 - DMA channel 7 number of data register" ]
        pub cndtr7: Cndtr7,
        # [ doc = "0x88 - DMA channel 7 peripheral address register" ]
        pub cpar7: Cpar7,
        # [ doc = "0x8c - DMA channel 7 memory address register" ]
        pub cmar7: Cmar7,
    }
    # [ doc = "DMA interrupt status register (DMA_ISR)" ]
    pub struct Isr {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA interrupt status register (DMA_ISR)" ]
    pub mod isr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Isr {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Gif1R {
            bits: u8,
        }
        impl Gif1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tcif1R {
            bits: u8,
        }
        impl Tcif1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Htif1R {
            bits: u8,
        }
        impl Htif1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Teif1R {
            bits: u8,
        }
        impl Teif1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Gif2R {
            bits: u8,
        }
        impl Gif2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tcif2R {
            bits: u8,
        }
        impl Tcif2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Htif2R {
            bits: u8,
        }
        impl Htif2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Teif2R {
            bits: u8,
        }
        impl Teif2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Gif3R {
            bits: u8,
        }
        impl Gif3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tcif3R {
            bits: u8,
        }
        impl Tcif3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Htif3R {
            bits: u8,
        }
        impl Htif3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Teif3R {
            bits: u8,
        }
        impl Teif3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Gif4R {
            bits: u8,
        }
        impl Gif4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tcif4R {
            bits: u8,
        }
        impl Tcif4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Htif4R {
            bits: u8,
        }
        impl Htif4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Teif4R {
            bits: u8,
        }
        impl Teif4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Gif5R {
            bits: u8,
        }
        impl Gif5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tcif5R {
            bits: u8,
        }
        impl Tcif5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Htif5R {
            bits: u8,
        }
        impl Htif5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Teif5R {
            bits: u8,
        }
        impl Teif5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Gif6R {
            bits: u8,
        }
        impl Gif6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tcif6R {
            bits: u8,
        }
        impl Tcif6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Htif6R {
            bits: u8,
        }
        impl Htif6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Teif6R {
            bits: u8,
        }
        impl Teif6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Gif7R {
            bits: u8,
        }
        impl Gif7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tcif7R {
            bits: u8,
        }
        impl Tcif7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Htif7R {
            bits: u8,
        }
        impl Htif7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Teif7R {
            bits: u8,
        }
        impl Teif7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Channel 1 Global interrupt flag" ]
            # [ inline ( always ) ]
            pub fn gif1(&self) -> Gif1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif1R { bits }
            }
            # [ doc = "Bit 1 - Channel 1 Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn tcif1(&self) -> Tcif1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif1R { bits }
            }
            # [ doc = "Bit 2 - Channel 1 Half Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn htif1(&self) -> Htif1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif1R { bits }
            }
            # [ doc = "Bit 3 - Channel 1 Transfer Error flag" ]
            # [ inline ( always ) ]
            pub fn teif1(&self) -> Teif1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif1R { bits }
            }
            # [ doc = "Bit 4 - Channel 2 Global interrupt flag" ]
            # [ inline ( always ) ]
            pub fn gif2(&self) -> Gif2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif2R { bits }
            }
            # [ doc = "Bit 5 - Channel 2 Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn tcif2(&self) -> Tcif2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif2R { bits }
            }
            # [ doc = "Bit 6 - Channel 2 Half Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn htif2(&self) -> Htif2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif2R { bits }
            }
            # [ doc = "Bit 7 - Channel 2 Transfer Error flag" ]
            # [ inline ( always ) ]
            pub fn teif2(&self) -> Teif2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif2R { bits }
            }
            # [ doc = "Bit 8 - Channel 3 Global interrupt flag" ]
            # [ inline ( always ) ]
            pub fn gif3(&self) -> Gif3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif3R { bits }
            }
            # [ doc = "Bit 9 - Channel 3 Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn tcif3(&self) -> Tcif3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif3R { bits }
            }
            # [ doc = "Bit 10 - Channel 3 Half Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn htif3(&self) -> Htif3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif3R { bits }
            }
            # [ doc = "Bit 11 - Channel 3 Transfer Error flag" ]
            # [ inline ( always ) ]
            pub fn teif3(&self) -> Teif3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif3R { bits }
            }
            # [ doc = "Bit 12 - Channel 4 Global interrupt flag" ]
            # [ inline ( always ) ]
            pub fn gif4(&self) -> Gif4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif4R { bits }
            }
            # [ doc = "Bit 13 - Channel 4 Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn tcif4(&self) -> Tcif4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif4R { bits }
            }
            # [ doc = "Bit 14 - Channel 4 Half Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn htif4(&self) -> Htif4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif4R { bits }
            }
            # [ doc = "Bit 15 - Channel 4 Transfer Error flag" ]
            # [ inline ( always ) ]
            pub fn teif4(&self) -> Teif4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif4R { bits }
            }
            # [ doc = "Bit 16 - Channel 5 Global interrupt flag" ]
            # [ inline ( always ) ]
            pub fn gif5(&self) -> Gif5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif5R { bits }
            }
            # [ doc = "Bit 17 - Channel 5 Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn tcif5(&self) -> Tcif5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif5R { bits }
            }
            # [ doc = "Bit 18 - Channel 5 Half Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn htif5(&self) -> Htif5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif5R { bits }
            }
            # [ doc = "Bit 19 - Channel 5 Transfer Error flag" ]
            # [ inline ( always ) ]
            pub fn teif5(&self) -> Teif5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif5R { bits }
            }
            # [ doc = "Bit 20 - Channel 6 Global interrupt flag" ]
            # [ inline ( always ) ]
            pub fn gif6(&self) -> Gif6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif6R { bits }
            }
            # [ doc = "Bit 21 - Channel 6 Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn tcif6(&self) -> Tcif6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif6R { bits }
            }
            # [ doc = "Bit 22 - Channel 6 Half Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn htif6(&self) -> Htif6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif6R { bits }
            }
            # [ doc = "Bit 23 - Channel 6 Transfer Error flag" ]
            # [ inline ( always ) ]
            pub fn teif6(&self) -> Teif6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif6R { bits }
            }
            # [ doc = "Bit 24 - Channel 7 Global interrupt flag" ]
            # [ inline ( always ) ]
            pub fn gif7(&self) -> Gif7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif7R { bits }
            }
            # [ doc = "Bit 25 - Channel 7 Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn tcif7(&self) -> Tcif7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif7R { bits }
            }
            # [ doc = "Bit 26 - Channel 7 Half Transfer Complete flag" ]
            # [ inline ( always ) ]
            pub fn htif7(&self) -> Htif7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif7R { bits }
            }
            # [ doc = "Bit 27 - Channel 7 Transfer Error flag" ]
            # [ inline ( always ) ]
            pub fn teif7(&self) -> Teif7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif7R { bits }
            }
        }
    }
    # [ doc = "DMA interrupt flag clear register (DMA_IFCR)" ]
    pub struct Ifcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA interrupt flag clear register (DMA_IFCR)" ]
    pub mod ifcr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ifcr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cgif1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cgif2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cgif3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cgif4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cgif5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cgif6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cgif7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ctcif1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ctcif2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ctcif3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ctcif4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ctcif5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ctcif6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ctcif7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Chtif1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Chtif2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Chtif3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Chtif4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Chtif5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Chtif6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Chtif7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cteif1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cteif2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cteif3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cteif4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cteif5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cteif6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cteif7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Channel 1 Global interrupt clear" ]
            # [ inline ( always ) ]
            pub fn cgif1(&mut self) -> _Cgif1W {
                _Cgif1W { w: self }
            }
            # [ doc = "Bit 4 - Channel 2 Global interrupt clear" ]
            # [ inline ( always ) ]
            pub fn cgif2(&mut self) -> _Cgif2W {
                _Cgif2W { w: self }
            }
            # [ doc = "Bit 8 - Channel 3 Global interrupt clear" ]
            # [ inline ( always ) ]
            pub fn cgif3(&mut self) -> _Cgif3W {
                _Cgif3W { w: self }
            }
            # [ doc = "Bit 12 - Channel 4 Global interrupt clear" ]
            # [ inline ( always ) ]
            pub fn cgif4(&mut self) -> _Cgif4W {
                _Cgif4W { w: self }
            }
            # [ doc = "Bit 16 - Channel 5 Global interrupt clear" ]
            # [ inline ( always ) ]
            pub fn cgif5(&mut self) -> _Cgif5W {
                _Cgif5W { w: self }
            }
            # [ doc = "Bit 20 - Channel 6 Global interrupt clear" ]
            # [ inline ( always ) ]
            pub fn cgif6(&mut self) -> _Cgif6W {
                _Cgif6W { w: self }
            }
            # [ doc = "Bit 24 - Channel 7 Global interrupt clear" ]
            # [ inline ( always ) ]
            pub fn cgif7(&mut self) -> _Cgif7W {
                _Cgif7W { w: self }
            }
            # [ doc = "Bit 1 - Channel 1 Transfer Complete clear" ]
            # [ inline ( always ) ]
            pub fn ctcif1(&mut self) -> _Ctcif1W {
                _Ctcif1W { w: self }
            }
            # [ doc = "Bit 5 - Channel 2 Transfer Complete clear" ]
            # [ inline ( always ) ]
            pub fn ctcif2(&mut self) -> _Ctcif2W {
                _Ctcif2W { w: self }
            }
            # [ doc = "Bit 9 - Channel 3 Transfer Complete clear" ]
            # [ inline ( always ) ]
            pub fn ctcif3(&mut self) -> _Ctcif3W {
                _Ctcif3W { w: self }
            }
            # [ doc = "Bit 13 - Channel 4 Transfer Complete clear" ]
            # [ inline ( always ) ]
            pub fn ctcif4(&mut self) -> _Ctcif4W {
                _Ctcif4W { w: self }
            }
            # [ doc = "Bit 17 - Channel 5 Transfer Complete clear" ]
            # [ inline ( always ) ]
            pub fn ctcif5(&mut self) -> _Ctcif5W {
                _Ctcif5W { w: self }
            }
            # [ doc = "Bit 21 - Channel 6 Transfer Complete clear" ]
            # [ inline ( always ) ]
            pub fn ctcif6(&mut self) -> _Ctcif6W {
                _Ctcif6W { w: self }
            }
            # [ doc = "Bit 25 - Channel 7 Transfer Complete clear" ]
            # [ inline ( always ) ]
            pub fn ctcif7(&mut self) -> _Ctcif7W {
                _Ctcif7W { w: self }
            }
            # [ doc = "Bit 2 - Channel 1 Half Transfer clear" ]
            # [ inline ( always ) ]
            pub fn chtif1(&mut self) -> _Chtif1W {
                _Chtif1W { w: self }
            }
            # [ doc = "Bit 6 - Channel 2 Half Transfer clear" ]
            # [ inline ( always ) ]
            pub fn chtif2(&mut self) -> _Chtif2W {
                _Chtif2W { w: self }
            }
            # [ doc = "Bit 10 - Channel 3 Half Transfer clear" ]
            # [ inline ( always ) ]
            pub fn chtif3(&mut self) -> _Chtif3W {
                _Chtif3W { w: self }
            }
            # [ doc = "Bit 14 - Channel 4 Half Transfer clear" ]
            # [ inline ( always ) ]
            pub fn chtif4(&mut self) -> _Chtif4W {
                _Chtif4W { w: self }
            }
            # [ doc = "Bit 18 - Channel 5 Half Transfer clear" ]
            # [ inline ( always ) ]
            pub fn chtif5(&mut self) -> _Chtif5W {
                _Chtif5W { w: self }
            }
            # [ doc = "Bit 22 - Channel 6 Half Transfer clear" ]
            # [ inline ( always ) ]
            pub fn chtif6(&mut self) -> _Chtif6W {
                _Chtif6W { w: self }
            }
            # [ doc = "Bit 26 - Channel 7 Half Transfer clear" ]
            # [ inline ( always ) ]
            pub fn chtif7(&mut self) -> _Chtif7W {
                _Chtif7W { w: self }
            }
            # [ doc = "Bit 3 - Channel 1 Transfer Error clear" ]
            # [ inline ( always ) ]
            pub fn cteif1(&mut self) -> _Cteif1W {
                _Cteif1W { w: self }
            }
            # [ doc = "Bit 7 - Channel 2 Transfer Error clear" ]
            # [ inline ( always ) ]
            pub fn cteif2(&mut self) -> _Cteif2W {
                _Cteif2W { w: self }
            }
            # [ doc = "Bit 11 - Channel 3 Transfer Error clear" ]
            # [ inline ( always ) ]
            pub fn cteif3(&mut self) -> _Cteif3W {
                _Cteif3W { w: self }
            }
            # [ doc = "Bit 15 - Channel 4 Transfer Error clear" ]
            # [ inline ( always ) ]
            pub fn cteif4(&mut self) -> _Cteif4W {
                _Cteif4W { w: self }
            }
            # [ doc = "Bit 19 - Channel 5 Transfer Error clear" ]
            # [ inline ( always ) ]
            pub fn cteif5(&mut self) -> _Cteif5W {
                _Cteif5W { w: self }
            }
            # [ doc = "Bit 23 - Channel 6 Transfer Error clear" ]
            # [ inline ( always ) ]
            pub fn cteif6(&mut self) -> _Cteif6W {
                _Cteif6W { w: self }
            }
            # [ doc = "Bit 27 - Channel 7 Transfer Error clear" ]
            # [ inline ( always ) ]
            pub fn cteif7(&mut self) -> _Cteif7W {
                _Cteif7W { w: self }
            }
        }
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub mod ccr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 1 number of data register" ]
    pub struct Cndtr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 1 number of data register" ]
    pub mod cndtr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 1 peripheral address register" ]
    pub struct Cpar1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 1 peripheral address register" ]
    pub mod cpar1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 1 memory address register" ]
    pub struct Cmar1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 1 memory address register" ]
    pub mod cmar1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub struct Ccr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub mod ccr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 2 number of data register" ]
    pub struct Cndtr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 2 number of data register" ]
    pub mod cndtr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 2 peripheral address register" ]
    pub struct Cpar2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 2 peripheral address register" ]
    pub mod cpar2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 2 memory address register" ]
    pub struct Cmar2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 2 memory address register" ]
    pub mod cmar2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub struct Ccr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub mod ccr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 3 number of data register" ]
    pub struct Cndtr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 3 number of data register" ]
    pub mod cndtr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 3 peripheral address register" ]
    pub struct Cpar3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 3 peripheral address register" ]
    pub mod cpar3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 3 memory address register" ]
    pub struct Cmar3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 3 memory address register" ]
    pub mod cmar3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub struct Ccr4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub mod ccr4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 4 number of data register" ]
    pub struct Cndtr4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 4 number of data register" ]
    pub mod cndtr4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 4 peripheral address register" ]
    pub struct Cpar4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 4 peripheral address register" ]
    pub mod cpar4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 4 memory address register" ]
    pub struct Cmar4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 4 memory address register" ]
    pub mod cmar4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub struct Ccr5 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub mod ccr5 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr5 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 5 number of data register" ]
    pub struct Cndtr5 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 5 number of data register" ]
    pub mod cndtr5 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr5 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 5 peripheral address register" ]
    pub struct Cpar5 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 5 peripheral address register" ]
    pub mod cpar5 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar5 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 5 memory address register" ]
    pub struct Cmar5 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 5 memory address register" ]
    pub mod cmar5 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar5 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub struct Ccr6 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub mod ccr6 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr6 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 6 number of data register" ]
    pub struct Cndtr6 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 6 number of data register" ]
    pub mod cndtr6 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr6 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 6 peripheral address register" ]
    pub struct Cpar6 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 6 peripheral address register" ]
    pub mod cpar6 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar6 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 6 memory address register" ]
    pub struct Cmar6 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 6 memory address register" ]
    pub mod cmar6 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar6 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub struct Ccr7 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel configuration register (DMA_CCR)" ]
    pub mod ccr7 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr7 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Channel enable" ]
            # [ inline ( always ) ]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            # [ doc = "Bit 1 - Transfer complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            # [ doc = "Bit 2 - Half Transfer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            # [ doc = "Bit 3 - Transfer error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            # [ doc = "Bit 4 - Data transfer direction" ]
            # [ inline ( always ) ]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            # [ doc = "Bit 5 - Circular mode" ]
            # [ inline ( always ) ]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            # [ doc = "Bit 6 - Peripheral increment mode" ]
            # [ inline ( always ) ]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            # [ doc = "Bit 7 - Memory increment mode" ]
            # [ inline ( always ) ]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            # [ doc = "Bits 8:9 - Peripheral size" ]
            # [ inline ( always ) ]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            # [ doc = "Bits 10:11 - Memory size" ]
            # [ inline ( always ) ]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            # [ doc = "Bits 12:13 - Channel Priority level" ]
            # [ inline ( always ) ]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            # [ doc = "Bit 14 - Memory to memory mode" ]
            # [ inline ( always ) ]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 7 number of data register" ]
    pub struct Cndtr7 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 7 number of data register" ]
    pub mod cndtr7 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr7 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Number of data to transfer" ]
            # [ inline ( always ) ]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 7 peripheral address register" ]
    pub struct Cpar7 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 7 peripheral address register" ]
    pub mod cpar7 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar7 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Peripheral address" ]
            # [ inline ( always ) ]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    # [ doc = "DMA channel 7 memory address register" ]
    pub struct Cmar7 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA channel 7 memory address register" ]
    pub mod cmar7 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar7 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Memory address" ]
            # [ inline ( always ) ]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
}
# [ doc = "DMA controller" ]
pub struct Dma1 {
    register_block: dma1::RegisterBlock,
}
impl Deref for Dma1 {
    type Target = dma1::RegisterBlock;
    fn deref(&self) -> &dma1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "DMA2" ]
pub const DMA2: Peripheral<Dma2> = unsafe { Peripheral::new(1073873920) };
# [ doc = r" Register block" ]
pub struct Dma2 {
    register_block: dma1::RegisterBlock,
}
impl Deref for Dma2 {
    type Target = dma1::RegisterBlock;
    fn deref(&self) -> &dma1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Real time clock" ]
pub const RTC: Peripheral<Rtc> = unsafe { Peripheral::new(1073752064) };
# [ doc = "Real time clock" ]
pub mod rtc {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - RTC Control Register High" ]
        pub crh: Crh,
        # [ doc = "0x04 - RTC Control Register Low" ]
        pub crl: Crl,
        # [ doc = "0x08 - RTC Prescaler Load Register High" ]
        pub prlh: Prlh,
        # [ doc = "0x0c - RTC Prescaler Load Register Low" ]
        pub prll: Prll,
        # [ doc = "0x10 - RTC Prescaler Divider Register High" ]
        pub divh: Divh,
        # [ doc = "0x14 - RTC Prescaler Divider Register Low" ]
        pub divl: Divl,
        # [ doc = "0x18 - RTC Counter Register High" ]
        pub cnth: Cnth,
        # [ doc = "0x1c - RTC Counter Register Low" ]
        pub cntl: Cntl,
        # [ doc = "0x20 - RTC Alarm Register High" ]
        pub alrh: Alrh,
        # [ doc = "0x24 - RTC Alarm Register Low" ]
        pub alrl: Alrl,
    }
    # [ doc = "RTC Control Register High" ]
    pub struct Crh {
        register: VolatileCell<u32>,
    }
    # [ doc = "RTC Control Register High" ]
    pub mod crh {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Crh {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SecieR {
            bits: u8,
        }
        impl SecieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AlrieR {
            bits: u8,
        }
        impl AlrieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OwieR {
            bits: u8,
        }
        impl OwieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SecieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SecieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AlrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AlrieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OwieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OwieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Second interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn secie(&self) -> SecieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SecieR { bits }
            }
            # [ doc = "Bit 1 - Alarm interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn alrie(&self) -> AlrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AlrieR { bits }
            }
            # [ doc = "Bit 2 - Overflow interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn owie(&self) -> OwieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OwieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Second interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn secie(&mut self) -> _SecieW {
                _SecieW { w: self }
            }
            # [ doc = "Bit 1 - Alarm interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn alrie(&mut self) -> _AlrieW {
                _AlrieW { w: self }
            }
            # [ doc = "Bit 2 - Overflow interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn owie(&mut self) -> _OwieW {
                _OwieW { w: self }
            }
        }
    }
    # [ doc = "RTC Control Register Low" ]
    pub struct Crl {
        register: VolatileCell<u32>,
    }
    # [ doc = "RTC Control Register Low" ]
    pub mod crl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Crl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SecfR {
            bits: u8,
        }
        impl SecfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AlrfR {
            bits: u8,
        }
        impl AlrfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OwfR {
            bits: u8,
        }
        impl OwfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RsfR {
            bits: u8,
        }
        impl RsfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CnfR {
            bits: u8,
        }
        impl CnfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtoffR {
            bits: u8,
        }
        impl RtoffR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SecfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SecfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AlrfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AlrfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OwfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OwfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RsfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RsfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CnfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CnfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Second Flag" ]
            # [ inline ( always ) ]
            pub fn secf(&self) -> SecfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SecfR { bits }
            }
            # [ doc = "Bit 1 - Alarm Flag" ]
            # [ inline ( always ) ]
            pub fn alrf(&self) -> AlrfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AlrfR { bits }
            }
            # [ doc = "Bit 2 - Overflow Flag" ]
            # [ inline ( always ) ]
            pub fn owf(&self) -> OwfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OwfR { bits }
            }
            # [ doc = "Bit 3 - Registers Synchronized Flag" ]
            # [ inline ( always ) ]
            pub fn rsf(&self) -> RsfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RsfR { bits }
            }
            # [ doc = "Bit 4 - Configuration Flag" ]
            # [ inline ( always ) ]
            pub fn cnf(&self) -> CnfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CnfR { bits }
            }
            # [ doc = "Bit 5 - RTC operation OFF" ]
            # [ inline ( always ) ]
            pub fn rtoff(&self) -> RtoffR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RtoffR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 32 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Second Flag" ]
            # [ inline ( always ) ]
            pub fn secf(&mut self) -> _SecfW {
                _SecfW { w: self }
            }
            # [ doc = "Bit 1 - Alarm Flag" ]
            # [ inline ( always ) ]
            pub fn alrf(&mut self) -> _AlrfW {
                _AlrfW { w: self }
            }
            # [ doc = "Bit 2 - Overflow Flag" ]
            # [ inline ( always ) ]
            pub fn owf(&mut self) -> _OwfW {
                _OwfW { w: self }
            }
            # [ doc = "Bit 3 - Registers Synchronized Flag" ]
            # [ inline ( always ) ]
            pub fn rsf(&mut self) -> _RsfW {
                _RsfW { w: self }
            }
            # [ doc = "Bit 4 - Configuration Flag" ]
            # [ inline ( always ) ]
            pub fn cnf(&mut self) -> _CnfW {
                _CnfW { w: self }
            }
        }
    }
    # [ doc = "RTC Prescaler Load Register High" ]
    pub struct Prlh {
        register: VolatileCell<u32>,
    }
    # [ doc = "RTC Prescaler Load Register High" ]
    pub mod prlh {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Prlh {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PrlhW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PrlhW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - RTC Prescaler Load Register High" ]
            # [ inline ( always ) ]
            pub fn prlh(&mut self) -> _PrlhW {
                _PrlhW { w: self }
            }
        }
    }
    # [ doc = "RTC Prescaler Load Register Low" ]
    pub struct Prll {
        register: VolatileCell<u32>,
    }
    # [ doc = "RTC Prescaler Load Register Low" ]
    pub mod prll {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Prll {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PrllW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PrllW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 32768 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - RTC Prescaler Divider Register Low" ]
            # [ inline ( always ) ]
            pub fn prll(&mut self) -> _PrllW {
                _PrllW { w: self }
            }
        }
    }
    # [ doc = "RTC Prescaler Divider Register High" ]
    pub struct Divh {
        register: VolatileCell<u32>,
    }
    # [ doc = "RTC Prescaler Divider Register High" ]
    pub mod divh {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Divh {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DivhR {
            bits: u8,
        }
        impl DivhR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - RTC prescaler divider register high" ]
            # [ inline ( always ) ]
            pub fn divh(&self) -> DivhR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DivhR { bits }
            }
        }
    }
    # [ doc = "RTC Prescaler Divider Register Low" ]
    pub struct Divl {
        register: VolatileCell<u32>,
    }
    # [ doc = "RTC Prescaler Divider Register Low" ]
    pub mod divl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Divl {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DivlR {
            bits: u16,
        }
        impl DivlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - RTC prescaler divider register Low" ]
            # [ inline ( always ) ]
            pub fn divl(&self) -> DivlR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DivlR { bits }
            }
        }
    }
    # [ doc = "RTC Counter Register High" ]
    pub struct Cnth {
        register: VolatileCell<u32>,
    }
    # [ doc = "RTC Counter Register High" ]
    pub mod cnth {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cnth {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CnthR {
            bits: u16,
        }
        impl CnthR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CnthW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CnthW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - RTC counter register high" ]
            # [ inline ( always ) ]
            pub fn cnth(&self) -> CnthR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CnthR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - RTC counter register high" ]
            # [ inline ( always ) ]
            pub fn cnth(&mut self) -> _CnthW {
                _CnthW { w: self }
            }
        }
    }
    # [ doc = "RTC Counter Register Low" ]
    pub struct Cntl {
        register: VolatileCell<u32>,
    }
    # [ doc = "RTC Counter Register Low" ]
    pub mod cntl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cntl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CntlR {
            bits: u16,
        }
        impl CntlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CntlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - RTC counter register Low" ]
            # [ inline ( always ) ]
            pub fn cntl(&self) -> CntlR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntlR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - RTC counter register Low" ]
            # [ inline ( always ) ]
            pub fn cntl(&mut self) -> _CntlW {
                _CntlW { w: self }
            }
        }
    }
    # [ doc = "RTC Alarm Register High" ]
    pub struct Alrh {
        register: VolatileCell<u32>,
    }
    # [ doc = "RTC Alarm Register High" ]
    pub mod alrh {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Alrh {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AlrhW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AlrhW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 65535 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - RTC alarm register high" ]
            # [ inline ( always ) ]
            pub fn alrh(&mut self) -> _AlrhW {
                _AlrhW { w: self }
            }
        }
    }
    # [ doc = "RTC Alarm Register Low" ]
    pub struct Alrl {
        register: VolatileCell<u32>,
    }
    # [ doc = "RTC Alarm Register Low" ]
    pub mod alrl {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Alrl {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AlrlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AlrlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 65535 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - RTC alarm register low" ]
            # [ inline ( always ) ]
            pub fn alrl(&mut self) -> _AlrlW {
                _AlrlW { w: self }
            }
        }
    }
}
# [ doc = "Real time clock" ]
pub struct Rtc {
    register_block: rtc::RegisterBlock,
}
impl Deref for Rtc {
    type Target = rtc::RegisterBlock;
    fn deref(&self) -> &rtc::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Backup registers" ]
pub const BKP: Peripheral<Bkp> = unsafe { Peripheral::new(1073769476) };
# [ doc = "Backup registers" ]
pub mod bkp {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Backup data register (BKP_DR)" ]
        pub dr1: Dr1,
        # [ doc = "0x04 - Backup data register (BKP_DR)" ]
        pub dr2: Dr2,
        # [ doc = "0x08 - Backup data register (BKP_DR)" ]
        pub dr3: Dr3,
        # [ doc = "0x0c - Backup data register (BKP_DR)" ]
        pub dr4: Dr4,
        # [ doc = "0x10 - Backup data register (BKP_DR)" ]
        pub dr5: Dr5,
        # [ doc = "0x14 - Backup data register (BKP_DR)" ]
        pub dr6: Dr6,
        # [ doc = "0x18 - Backup data register (BKP_DR)" ]
        pub dr7: Dr7,
        # [ doc = "0x1c - Backup data register (BKP_DR)" ]
        pub dr8: Dr8,
        # [ doc = "0x20 - Backup data register (BKP_DR)" ]
        pub dr9: Dr9,
        # [ doc = "0x24 - Backup data register (BKP_DR)" ]
        pub dr10: Dr10,
        # [ doc = "0x28 - RTC clock calibration register (BKP_RTCCR)" ]
        pub rtccr: Rtccr,
        # [ doc = "0x2c - Backup control register (BKP_CR)" ]
        pub cr: Cr,
        # [ doc = "0x30 - BKP_CSR control/status register (BKP_CSR)" ]
        pub csr: Csr,
        _reserved0: [u8; 8usize],
        # [ doc = "0x3c - Backup data register (BKP_DR)" ]
        pub dr11: Dr11,
        # [ doc = "0x40 - Backup data register (BKP_DR)" ]
        pub dr12: Dr12,
        # [ doc = "0x44 - Backup data register (BKP_DR)" ]
        pub dr13: Dr13,
        # [ doc = "0x48 - Backup data register (BKP_DR)" ]
        pub dr14: Dr14,
        # [ doc = "0x4c - Backup data register (BKP_DR)" ]
        pub dr15: Dr15,
        # [ doc = "0x50 - Backup data register (BKP_DR)" ]
        pub dr16: Dr16,
        # [ doc = "0x54 - Backup data register (BKP_DR)" ]
        pub dr17: Dr17,
        # [ doc = "0x58 - Backup data register (BKP_DR)" ]
        pub dr18: Dr18,
        # [ doc = "0x5c - Backup data register (BKP_DR)" ]
        pub dr19: Dr19,
        # [ doc = "0x60 - Backup data register (BKP_DR)" ]
        pub dr20: Dr20,
        # [ doc = "0x64 - Backup data register (BKP_DR)" ]
        pub dr21: Dr21,
        # [ doc = "0x68 - Backup data register (BKP_DR)" ]
        pub dr22: Dr22,
        # [ doc = "0x6c - Backup data register (BKP_DR)" ]
        pub dr23: Dr23,
        # [ doc = "0x70 - Backup data register (BKP_DR)" ]
        pub dr24: Dr24,
        # [ doc = "0x74 - Backup data register (BKP_DR)" ]
        pub dr25: Dr25,
        # [ doc = "0x78 - Backup data register (BKP_DR)" ]
        pub dr26: Dr26,
        # [ doc = "0x7c - Backup data register (BKP_DR)" ]
        pub dr27: Dr27,
        # [ doc = "0x80 - Backup data register (BKP_DR)" ]
        pub dr28: Dr28,
        # [ doc = "0x84 - Backup data register (BKP_DR)" ]
        pub dr29: Dr29,
        # [ doc = "0x88 - Backup data register (BKP_DR)" ]
        pub dr30: Dr30,
        # [ doc = "0x8c - Backup data register (BKP_DR)" ]
        pub dr31: Dr31,
        # [ doc = "0x90 - Backup data register (BKP_DR)" ]
        pub dr32: Dr32,
        # [ doc = "0x94 - Backup data register (BKP_DR)" ]
        pub dr33: Dr33,
        # [ doc = "0x98 - Backup data register (BKP_DR)" ]
        pub dr34: Dr34,
        # [ doc = "0x9c - Backup data register (BKP_DR)" ]
        pub dr35: Dr35,
        # [ doc = "0xa0 - Backup data register (BKP_DR)" ]
        pub dr36: Dr36,
        # [ doc = "0xa4 - Backup data register (BKP_DR)" ]
        pub dr37: Dr37,
        # [ doc = "0xa8 - Backup data register (BKP_DR)" ]
        pub dr38: Dr38,
        # [ doc = "0xac - Backup data register (BKP_DR)" ]
        pub dr39: Dr39,
        # [ doc = "0xb0 - Backup data register (BKP_DR)" ]
        pub dr40: Dr40,
        # [ doc = "0xb4 - Backup data register (BKP_DR)" ]
        pub dr41: Dr41,
        # [ doc = "0xb8 - Backup data register (BKP_DR)" ]
        pub dr42: Dr42,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D1R {
            bits: u16,
        }
        impl D1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d1(&self) -> D1R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d1(&mut self) -> _D1W {
                _D1W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D2R {
            bits: u16,
        }
        impl D2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d2(&self) -> D2R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D2R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d2(&mut self) -> _D2W {
                _D2W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D3R {
            bits: u16,
        }
        impl D3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d3(&self) -> D3R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d3(&mut self) -> _D3W {
                _D3W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D4R {
            bits: u16,
        }
        impl D4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d4(&self) -> D4R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D4R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d4(&mut self) -> _D4W {
                _D4W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr5 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr5 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr5 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D5R {
            bits: u16,
        }
        impl D5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d5(&self) -> D5R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D5R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d5(&mut self) -> _D5W {
                _D5W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr6 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr6 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr6 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D6R {
            bits: u16,
        }
        impl D6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d6(&self) -> D6R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D6R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d6(&mut self) -> _D6W {
                _D6W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr7 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr7 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr7 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D7R {
            bits: u16,
        }
        impl D7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d7(&self) -> D7R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d7(&mut self) -> _D7W {
                _D7W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr8 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr8 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr8 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D8R {
            bits: u16,
        }
        impl D8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d8(&self) -> D8R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D8R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d8(&mut self) -> _D8W {
                _D8W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr9 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr9 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr9 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D9R {
            bits: u16,
        }
        impl D9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d9(&self) -> D9R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D9R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d9(&mut self) -> _D9W {
                _D9W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr10 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr10 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr10 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D10R {
            bits: u16,
        }
        impl D10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d10(&self) -> D10R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D10R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d10(&mut self) -> _D10W {
                _D10W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr11 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr11 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr11 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dr11R {
            bits: u16,
        }
        impl Dr11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dr11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn dr11(&self) -> Dr11R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dr11R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn dr11(&mut self) -> _Dr11W {
                _Dr11W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr12 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr12 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr12 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dr12R {
            bits: u16,
        }
        impl Dr12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dr12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn dr12(&self) -> Dr12R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dr12R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn dr12(&mut self) -> _Dr12W {
                _Dr12W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr13 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr13 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr13 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dr13R {
            bits: u16,
        }
        impl Dr13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dr13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn dr13(&self) -> Dr13R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dr13R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn dr13(&mut self) -> _Dr13W {
                _Dr13W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr14 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr14 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr14 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D14R {
            bits: u16,
        }
        impl D14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d14(&self) -> D14R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D14R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d14(&mut self) -> _D14W {
                _D14W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr15 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr15 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr15 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D15R {
            bits: u16,
        }
        impl D15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d15(&self) -> D15R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d15(&mut self) -> _D15W {
                _D15W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr16 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr16 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr16 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D16R {
            bits: u16,
        }
        impl D16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D16W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d16(&self) -> D16R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D16R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d16(&mut self) -> _D16W {
                _D16W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr17 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr17 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr17 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D17R {
            bits: u16,
        }
        impl D17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D17W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d17(&self) -> D17R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D17R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d17(&mut self) -> _D17W {
                _D17W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr18 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr18 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr18 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D18R {
            bits: u16,
        }
        impl D18R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D18W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d18(&self) -> D18R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D18R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d18(&mut self) -> _D18W {
                _D18W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr19 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr19 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr19 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D19R {
            bits: u16,
        }
        impl D19R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D19W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d19(&self) -> D19R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D19R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d19(&mut self) -> _D19W {
                _D19W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr20 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr20 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr20 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D20R {
            bits: u16,
        }
        impl D20R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D20W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d20(&self) -> D20R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D20R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d20(&mut self) -> _D20W {
                _D20W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr21 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr21 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr21 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D21R {
            bits: u16,
        }
        impl D21R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D21W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d21(&self) -> D21R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D21R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d21(&mut self) -> _D21W {
                _D21W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr22 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr22 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr22 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D22R {
            bits: u16,
        }
        impl D22R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D22W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d22(&self) -> D22R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D22R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d22(&mut self) -> _D22W {
                _D22W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr23 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr23 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr23 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D23R {
            bits: u16,
        }
        impl D23R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D23W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d23(&self) -> D23R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D23R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d23(&mut self) -> _D23W {
                _D23W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr24 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr24 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr24 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D24R {
            bits: u16,
        }
        impl D24R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D24W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d24(&self) -> D24R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D24R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d24(&mut self) -> _D24W {
                _D24W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr25 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr25 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr25 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D25R {
            bits: u16,
        }
        impl D25R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D25W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d25(&self) -> D25R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D25R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d25(&mut self) -> _D25W {
                _D25W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr26 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr26 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr26 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D26R {
            bits: u16,
        }
        impl D26R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D26W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d26(&self) -> D26R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D26R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d26(&mut self) -> _D26W {
                _D26W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr27 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr27 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr27 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D27R {
            bits: u16,
        }
        impl D27R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D27W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d27(&self) -> D27R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D27R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d27(&mut self) -> _D27W {
                _D27W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr28 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr28 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr28 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D28R {
            bits: u16,
        }
        impl D28R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D28W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d28(&self) -> D28R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D28R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d28(&mut self) -> _D28W {
                _D28W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr29 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr29 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr29 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D29R {
            bits: u16,
        }
        impl D29R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D29W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d29(&self) -> D29R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D29R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d29(&mut self) -> _D29W {
                _D29W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr30 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr30 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr30 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D30R {
            bits: u16,
        }
        impl D30R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D30W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d30(&self) -> D30R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D30R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d30(&mut self) -> _D30W {
                _D30W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr31 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr31 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr31 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D31R {
            bits: u16,
        }
        impl D31R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D31W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d31(&self) -> D31R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D31R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d31(&mut self) -> _D31W {
                _D31W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr32 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr32 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr32 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D32R {
            bits: u16,
        }
        impl D32R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D32W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D32W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d32(&self) -> D32R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D32R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d32(&mut self) -> _D32W {
                _D32W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr33 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr33 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr33 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D33R {
            bits: u16,
        }
        impl D33R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D33W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D33W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d33(&self) -> D33R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D33R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d33(&mut self) -> _D33W {
                _D33W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr34 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr34 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr34 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D34R {
            bits: u16,
        }
        impl D34R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D34W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D34W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d34(&self) -> D34R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D34R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d34(&mut self) -> _D34W {
                _D34W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr35 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr35 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr35 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D35R {
            bits: u16,
        }
        impl D35R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D35W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D35W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d35(&self) -> D35R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D35R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d35(&mut self) -> _D35W {
                _D35W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr36 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr36 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr36 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D36R {
            bits: u16,
        }
        impl D36R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D36W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D36W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d36(&self) -> D36R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D36R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d36(&mut self) -> _D36W {
                _D36W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr37 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr37 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr37 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D37R {
            bits: u16,
        }
        impl D37R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D37W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D37W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d37(&self) -> D37R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D37R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d37(&mut self) -> _D37W {
                _D37W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr38 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr38 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr38 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D38R {
            bits: u16,
        }
        impl D38R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D38W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D38W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d38(&self) -> D38R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D38R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d38(&mut self) -> _D38W {
                _D38W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr39 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr39 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr39 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D39R {
            bits: u16,
        }
        impl D39R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D39W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D39W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d39(&self) -> D39R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D39R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d39(&mut self) -> _D39W {
                _D39W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr40 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr40 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr40 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D40R {
            bits: u16,
        }
        impl D40R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D40W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D40W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d40(&self) -> D40R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D40R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d40(&mut self) -> _D40W {
                _D40W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr41 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr41 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr41 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D41R {
            bits: u16,
        }
        impl D41R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D41W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D41W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d41(&self) -> D41R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D41R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d41(&mut self) -> _D41W {
                _D41W { w: self }
            }
        }
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub struct Dr42 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup data register (BKP_DR)" ]
    pub mod dr42 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr42 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct D42R {
            bits: u16,
        }
        impl D42R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _D42W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D42W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d42(&self) -> D42R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D42R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Backup data" ]
            # [ inline ( always ) ]
            pub fn d42(&mut self) -> _D42W {
                _D42W { w: self }
            }
        }
    }
    # [ doc = "RTC clock calibration register (BKP_RTCCR)" ]
    pub struct Rtccr {
        register: VolatileCell<u32>,
    }
    # [ doc = "RTC clock calibration register (BKP_RTCCR)" ]
    pub mod rtccr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Rtccr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CalR {
            bits: u8,
        }
        impl CalR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcoR {
            bits: u8,
        }
        impl CcoR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AsoeR {
            bits: u8,
        }
        impl AsoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AsosR {
            bits: u8,
        }
        impl AsosR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CalW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CalW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcoW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AsoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AsoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AsosW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AsosW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:6 - Calibration value" ]
            # [ inline ( always ) ]
            pub fn cal(&self) -> CalR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CalR { bits }
            }
            # [ doc = "Bit 7 - Calibration Clock Output" ]
            # [ inline ( always ) ]
            pub fn cco(&self) -> CcoR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcoR { bits }
            }
            # [ doc = "Bit 8 - Alarm or second output enable" ]
            # [ inline ( always ) ]
            pub fn asoe(&self) -> AsoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AsoeR { bits }
            }
            # [ doc = "Bit 9 - Alarm or second output selection" ]
            # [ inline ( always ) ]
            pub fn asos(&self) -> AsosR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AsosR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:6 - Calibration value" ]
            # [ inline ( always ) ]
            pub fn cal(&mut self) -> _CalW {
                _CalW { w: self }
            }
            # [ doc = "Bit 7 - Calibration Clock Output" ]
            # [ inline ( always ) ]
            pub fn cco(&mut self) -> _CcoW {
                _CcoW { w: self }
            }
            # [ doc = "Bit 8 - Alarm or second output enable" ]
            # [ inline ( always ) ]
            pub fn asoe(&mut self) -> _AsoeW {
                _AsoeW { w: self }
            }
            # [ doc = "Bit 9 - Alarm or second output selection" ]
            # [ inline ( always ) ]
            pub fn asos(&mut self) -> _AsosW {
                _AsosW { w: self }
            }
        }
    }
    # [ doc = "Backup control register (BKP_CR)" ]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Backup control register (BKP_CR)" ]
    pub mod cr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TpeR {
            bits: u8,
        }
        impl TpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TpalR {
            bits: u8,
        }
        impl TpalR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TpalW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TpalW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Tamper pin enable" ]
            # [ inline ( always ) ]
            pub fn tpe(&self) -> TpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TpeR { bits }
            }
            # [ doc = "Bit 1 - Tamper pin active level" ]
            # [ inline ( always ) ]
            pub fn tpal(&self) -> TpalR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TpalR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Tamper pin enable" ]
            # [ inline ( always ) ]
            pub fn tpe(&mut self) -> _TpeW {
                _TpeW { w: self }
            }
            # [ doc = "Bit 1 - Tamper pin active level" ]
            # [ inline ( always ) ]
            pub fn tpal(&mut self) -> _TpalW {
                _TpalW { w: self }
            }
        }
    }
    # [ doc = "BKP_CSR control/status register (BKP_CSR)" ]
    pub struct Csr {
        register: VolatileCell<u32>,
    }
    # [ doc = "BKP_CSR control/status register (BKP_CSR)" ]
    pub mod csr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Csr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TpieR {
            bits: u8,
        }
        impl TpieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TefR {
            bits: u8,
        }
        impl TefR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TifR {
            bits: u8,
        }
        impl TifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CteW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CteW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CtiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtiW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TpieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TpieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 2 - Tamper Pin interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tpie(&self) -> TpieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TpieR { bits }
            }
            # [ doc = "Bit 8 - Tamper Event Flag" ]
            # [ inline ( always ) ]
            pub fn tef(&self) -> TefR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TefR { bits }
            }
            # [ doc = "Bit 9 - Tamper Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn tif(&self) -> TifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TifR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Clear Tamper event" ]
            # [ inline ( always ) ]
            pub fn cte(&mut self) -> _CteW {
                _CteW { w: self }
            }
            # [ doc = "Bit 1 - Clear Tamper Interrupt" ]
            # [ inline ( always ) ]
            pub fn cti(&mut self) -> _CtiW {
                _CtiW { w: self }
            }
            # [ doc = "Bit 2 - Tamper Pin interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tpie(&mut self) -> _TpieW {
                _TpieW { w: self }
            }
        }
    }
}
# [ doc = "Backup registers" ]
pub struct Bkp {
    register_block: bkp::RegisterBlock,
}
impl Deref for Bkp {
    type Target = bkp::RegisterBlock;
    fn deref(&self) -> &bkp::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Independent watchdog" ]
pub const IWDG: Peripheral<Iwdg> = unsafe { Peripheral::new(1073754112) };
# [ doc = "Independent watchdog" ]
pub mod iwdg {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Key register (IWDG_KR)" ]
        pub kr: Kr,
        # [ doc = "0x04 - Prescaler register (IWDG_PR)" ]
        pub pr: Pr,
        # [ doc = "0x08 - Reload register (IWDG_RLR)" ]
        pub rlr: Rlr,
        # [ doc = "0x0c - Status register (IWDG_SR)" ]
        pub sr: Sr,
    }
    # [ doc = "Key register (IWDG_KR)" ]
    pub struct Kr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Key register (IWDG_KR)" ]
    pub mod kr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Kr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _KeyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _KeyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Key value" ]
            # [ inline ( always ) ]
            pub fn key(&mut self) -> _KeyW {
                _KeyW { w: self }
            }
        }
    }
    # [ doc = "Prescaler register (IWDG_PR)" ]
    pub struct Pr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Prescaler register (IWDG_PR)" ]
    pub mod pr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PrR {
            bits: u8,
        }
        impl PrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Prescaler divider" ]
            # [ inline ( always ) ]
            pub fn pr(&self) -> PrR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:2 - Prescaler divider" ]
            # [ inline ( always ) ]
            pub fn pr(&mut self) -> _PrW {
                _PrW { w: self }
            }
        }
    }
    # [ doc = "Reload register (IWDG_RLR)" ]
    pub struct Rlr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Reload register (IWDG_RLR)" ]
    pub mod rlr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Rlr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RlR {
            bits: u16,
        }
        impl RlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - Watchdog counter reload value" ]
            # [ inline ( always ) ]
            pub fn rl(&self) -> RlR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RlR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4095 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:11 - Watchdog counter reload value" ]
            # [ inline ( always ) ]
            pub fn rl(&mut self) -> _RlW {
                _RlW { w: self }
            }
        }
    }
    # [ doc = "Status register (IWDG_SR)" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Status register (IWDG_SR)" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PvuR {
            bits: u8,
        }
        impl PvuR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RvuR {
            bits: u8,
        }
        impl RvuR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Watchdog prescaler value update" ]
            # [ inline ( always ) ]
            pub fn pvu(&self) -> PvuR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PvuR { bits }
            }
            # [ doc = "Bit 1 - Watchdog counter reload value update" ]
            # [ inline ( always ) ]
            pub fn rvu(&self) -> RvuR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RvuR { bits }
            }
        }
    }
}
# [ doc = "Independent watchdog" ]
pub struct Iwdg {
    register_block: iwdg::RegisterBlock,
}
impl Deref for Iwdg {
    type Target = iwdg::RegisterBlock;
    fn deref(&self) -> &iwdg::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Window watchdog" ]
pub const WWDG: Peripheral<Wwdg> = unsafe { Peripheral::new(1073753088) };
# [ doc = "Window watchdog" ]
pub mod wwdg {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Control register (WWDG_CR)" ]
        pub cr: Cr,
        # [ doc = "0x04 - Configuration register (WWDG_CFR)" ]
        pub cfr: Cfr,
        # [ doc = "0x08 - Status register (WWDG_SR)" ]
        pub sr: Sr,
    }
    # [ doc = "Control register (WWDG_CR)" ]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register (WWDG_CR)" ]
    pub mod cr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TR {
            bits: u8,
        }
        impl TR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WdgaR {
            bits: u8,
        }
        impl WdgaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WdgaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdgaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:6 - 7-bit counter (MSB to LSB)" ]
            # [ inline ( always ) ]
            pub fn t(&self) -> TR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TR { bits }
            }
            # [ doc = "Bit 7 - Activation bit" ]
            # [ inline ( always ) ]
            pub fn wdga(&self) -> WdgaR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WdgaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 127 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:6 - 7-bit counter (MSB to LSB)" ]
            # [ inline ( always ) ]
            pub fn t(&mut self) -> _TW {
                _TW { w: self }
            }
            # [ doc = "Bit 7 - Activation bit" ]
            # [ inline ( always ) ]
            pub fn wdga(&mut self) -> _WdgaW {
                _WdgaW { w: self }
            }
        }
    }
    # [ doc = "Configuration register (WWDG_CFR)" ]
    pub struct Cfr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Configuration register (WWDG_CFR)" ]
    pub mod cfr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cfr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WR {
            bits: u8,
        }
        impl WR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WdgtbR {
            bits: u8,
        }
        impl WdgtbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EwiR {
            bits: u8,
        }
        impl EwiR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WdgtbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdgtbW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EwiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EwiW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:6 - 7-bit window value" ]
            # [ inline ( always ) ]
            pub fn w(&self) -> WR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WR { bits }
            }
            # [ doc = "Bits 7:8 - Timer Base" ]
            # [ inline ( always ) ]
            pub fn wdgtb(&self) -> WdgtbR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WdgtbR { bits }
            }
            # [ doc = "Bit 9 - Early Wakeup Interrupt" ]
            # [ inline ( always ) ]
            pub fn ewi(&self) -> EwiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EwiR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 127 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:6 - 7-bit window value" ]
            # [ inline ( always ) ]
            pub fn w(&mut self) -> _WW {
                _WW { w: self }
            }
            # [ doc = "Bits 7:8 - Timer Base" ]
            # [ inline ( always ) ]
            pub fn wdgtb(&mut self) -> _WdgtbW {
                _WdgtbW { w: self }
            }
            # [ doc = "Bit 9 - Early Wakeup Interrupt" ]
            # [ inline ( always ) ]
            pub fn ewi(&mut self) -> _EwiW {
                _EwiW { w: self }
            }
        }
    }
    # [ doc = "Status register (WWDG_SR)" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Status register (WWDG_SR)" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EwiR {
            bits: u8,
        }
        impl EwiR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EwiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EwiW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Early Wakeup Interrupt" ]
            # [ inline ( always ) ]
            pub fn ewi(&self) -> EwiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EwiR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Early Wakeup Interrupt" ]
            # [ inline ( always ) ]
            pub fn ewi(&mut self) -> _EwiW {
                _EwiW { w: self }
            }
        }
    }
}
# [ doc = "Window watchdog" ]
pub struct Wwdg {
    register_block: wwdg::RegisterBlock,
}
impl Deref for Wwdg {
    type Target = wwdg::RegisterBlock;
    fn deref(&self) -> &wwdg::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Advanced timer" ]
pub const TIM1: Peripheral<Tim1> = unsafe { Peripheral::new(1073818624) };
# [ doc = "Advanced timer" ]
pub mod tim1 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - control register 1" ]
        pub cr1: Cr1,
        # [ doc = "0x04 - control register 2" ]
        pub cr2: Cr2,
        # [ doc = "0x08 - slave mode control register" ]
        pub smcr: Smcr,
        # [ doc = "0x0c - DMA/Interrupt enable register" ]
        pub dier: Dier,
        # [ doc = "0x10 - status register" ]
        pub sr: Sr,
        # [ doc = "0x14 - event generation register" ]
        pub egr: Egr,
        # [ doc = "0x18 - capture/compare mode register (output mode)" ]
        pub ccmr1_output: Ccmr1Output,
        # [ doc = "0x1c - capture/compare mode register (output mode)" ]
        pub ccmr2_output: Ccmr2Output,
        # [ doc = "0x20 - capture/compare enable register" ]
        pub ccer: Ccer,
        # [ doc = "0x24 - counter" ]
        pub cnt: Cnt,
        # [ doc = "0x28 - prescaler" ]
        pub psc: Psc,
        # [ doc = "0x2c - auto-reload register" ]
        pub arr: Arr,
        # [ doc = "0x30 - repetition counter register" ]
        pub rcr: Rcr,
        # [ doc = "0x34 - capture/compare register 1" ]
        pub ccr1: Ccr1,
        # [ doc = "0x38 - capture/compare register 2" ]
        pub ccr2: Ccr2,
        # [ doc = "0x3c - capture/compare register 3" ]
        pub ccr3: Ccr3,
        # [ doc = "0x40 - capture/compare register 4" ]
        pub ccr4: Ccr4,
        # [ doc = "0x44 - break and dead-time register" ]
        pub bdtr: Bdtr,
        # [ doc = "0x48 - DMA control register" ]
        pub dcr: Dcr,
        # [ doc = "0x4c - DMA address for full transfer" ]
        pub dmar: Dmar,
    }
    # [ doc = "control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CkdR {
            bits: u8,
        }
        impl CkdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CmsR {
            bits: u8,
        }
        impl CmsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OpmR {
            bits: u8,
        }
        impl OpmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CenR {
            bits: u8,
        }
        impl CenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CkdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CkdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OpmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 8:9 - Clock division" ]
            # [ inline ( always ) ]
            pub fn ckd(&self) -> CkdR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CkdR { bits }
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            # [ doc = "Bits 5:6 - Center-aligned mode selection" ]
            # [ inline ( always ) ]
            pub fn cms(&self) -> CmsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CmsR { bits }
            }
            # [ doc = "Bit 4 - Direction" ]
            # [ inline ( always ) ]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            # [ doc = "Bit 3 - One-pulse mode" ]
            # [ inline ( always ) ]
            pub fn opm(&self) -> OpmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpmR { bits }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&self) -> CenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 8:9 - Clock division" ]
            # [ inline ( always ) ]
            pub fn ckd(&mut self) -> _CkdW {
                _CkdW { w: self }
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            # [ doc = "Bits 5:6 - Center-aligned mode selection" ]
            # [ inline ( always ) ]
            pub fn cms(&mut self) -> _CmsW {
                _CmsW { w: self }
            }
            # [ doc = "Bit 4 - Direction" ]
            # [ inline ( always ) ]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            # [ doc = "Bit 3 - One-pulse mode" ]
            # [ inline ( always ) ]
            pub fn opm(&mut self) -> _OpmW {
                _OpmW { w: self }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    # [ doc = "control register 2" ]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 2" ]
    pub mod cr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ois4R {
            bits: u8,
        }
        impl Ois4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ois3nR {
            bits: u8,
        }
        impl Ois3nR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ois3R {
            bits: u8,
        }
        impl Ois3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ois2nR {
            bits: u8,
        }
        impl Ois2nR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ois2R {
            bits: u8,
        }
        impl Ois2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ois1nR {
            bits: u8,
        }
        impl Ois1nR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ois1R {
            bits: u8,
        }
        impl Ois1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ti1sR {
            bits: u8,
        }
        impl Ti1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MmsR {
            bits: u8,
        }
        impl MmsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcdsR {
            bits: u8,
        }
        impl CcdsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcusR {
            bits: u8,
        }
        impl CcusR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcpcR {
            bits: u8,
        }
        impl CcpcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ois4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ois3nW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois3nW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ois3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ois2nW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois2nW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ois2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ois1nW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois1nW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ois1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ti1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ti1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MmsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcdsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcdsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcusW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcusW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcpcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcpcW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 14 - Output Idle state 4" ]
            # [ inline ( always ) ]
            pub fn ois4(&self) -> Ois4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois4R { bits }
            }
            # [ doc = "Bit 13 - Output Idle state 3" ]
            # [ inline ( always ) ]
            pub fn ois3n(&self) -> Ois3nR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois3nR { bits }
            }
            # [ doc = "Bit 12 - Output Idle state 3" ]
            # [ inline ( always ) ]
            pub fn ois3(&self) -> Ois3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois3R { bits }
            }
            # [ doc = "Bit 11 - Output Idle state 2" ]
            # [ inline ( always ) ]
            pub fn ois2n(&self) -> Ois2nR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois2nR { bits }
            }
            # [ doc = "Bit 10 - Output Idle state 2" ]
            # [ inline ( always ) ]
            pub fn ois2(&self) -> Ois2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois2R { bits }
            }
            # [ doc = "Bit 9 - Output Idle state 1" ]
            # [ inline ( always ) ]
            pub fn ois1n(&self) -> Ois1nR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois1nR { bits }
            }
            # [ doc = "Bit 8 - Output Idle state 1" ]
            # [ inline ( always ) ]
            pub fn ois1(&self) -> Ois1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois1R { bits }
            }
            # [ doc = "Bit 7 - TI1 selection" ]
            # [ inline ( always ) ]
            pub fn ti1s(&self) -> Ti1sR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ti1sR { bits }
            }
            # [ doc = "Bits 4:6 - Master mode selection" ]
            # [ inline ( always ) ]
            pub fn mms(&self) -> MmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MmsR { bits }
            }
            # [ doc = "Bit 3 - Capture/compare DMA selection" ]
            # [ inline ( always ) ]
            pub fn ccds(&self) -> CcdsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcdsR { bits }
            }
            # [ doc = "Bit 2 - Capture/compare control update selection" ]
            # [ inline ( always ) ]
            pub fn ccus(&self) -> CcusR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcusR { bits }
            }
            # [ doc = "Bit 0 - Capture/compare preloaded control" ]
            # [ inline ( always ) ]
            pub fn ccpc(&self) -> CcpcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcpcR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 14 - Output Idle state 4" ]
            # [ inline ( always ) ]
            pub fn ois4(&mut self) -> _Ois4W {
                _Ois4W { w: self }
            }
            # [ doc = "Bit 13 - Output Idle state 3" ]
            # [ inline ( always ) ]
            pub fn ois3n(&mut self) -> _Ois3nW {
                _Ois3nW { w: self }
            }
            # [ doc = "Bit 12 - Output Idle state 3" ]
            # [ inline ( always ) ]
            pub fn ois3(&mut self) -> _Ois3W {
                _Ois3W { w: self }
            }
            # [ doc = "Bit 11 - Output Idle state 2" ]
            # [ inline ( always ) ]
            pub fn ois2n(&mut self) -> _Ois2nW {
                _Ois2nW { w: self }
            }
            # [ doc = "Bit 10 - Output Idle state 2" ]
            # [ inline ( always ) ]
            pub fn ois2(&mut self) -> _Ois2W {
                _Ois2W { w: self }
            }
            # [ doc = "Bit 9 - Output Idle state 1" ]
            # [ inline ( always ) ]
            pub fn ois1n(&mut self) -> _Ois1nW {
                _Ois1nW { w: self }
            }
            # [ doc = "Bit 8 - Output Idle state 1" ]
            # [ inline ( always ) ]
            pub fn ois1(&mut self) -> _Ois1W {
                _Ois1W { w: self }
            }
            # [ doc = "Bit 7 - TI1 selection" ]
            # [ inline ( always ) ]
            pub fn ti1s(&mut self) -> _Ti1sW {
                _Ti1sW { w: self }
            }
            # [ doc = "Bits 4:6 - Master mode selection" ]
            # [ inline ( always ) ]
            pub fn mms(&mut self) -> _MmsW {
                _MmsW { w: self }
            }
            # [ doc = "Bit 3 - Capture/compare DMA selection" ]
            # [ inline ( always ) ]
            pub fn ccds(&mut self) -> _CcdsW {
                _CcdsW { w: self }
            }
            # [ doc = "Bit 2 - Capture/compare control update selection" ]
            # [ inline ( always ) ]
            pub fn ccus(&mut self) -> _CcusW {
                _CcusW { w: self }
            }
            # [ doc = "Bit 0 - Capture/compare preloaded control" ]
            # [ inline ( always ) ]
            pub fn ccpc(&mut self) -> _CcpcW {
                _CcpcW { w: self }
            }
        }
    }
    # [ doc = "slave mode control register" ]
    pub struct Smcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "slave mode control register" ]
    pub mod smcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Smcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EtpR {
            bits: u8,
        }
        impl EtpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EceR {
            bits: u8,
        }
        impl EceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EtpsR {
            bits: u8,
        }
        impl EtpsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EtfR {
            bits: u8,
        }
        impl EtfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MsmR {
            bits: u8,
        }
        impl MsmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TsR {
            bits: u8,
        }
        impl TsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SmsR {
            bits: u8,
        }
        impl SmsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EtpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EtpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EtpsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EtpsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EtfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EtfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MsmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - External trigger polarity" ]
            # [ inline ( always ) ]
            pub fn etp(&self) -> EtpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EtpR { bits }
            }
            # [ doc = "Bit 14 - External clock enable" ]
            # [ inline ( always ) ]
            pub fn ece(&self) -> EceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EceR { bits }
            }
            # [ doc = "Bits 12:13 - External trigger prescaler" ]
            # [ inline ( always ) ]
            pub fn etps(&self) -> EtpsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EtpsR { bits }
            }
            # [ doc = "Bits 8:11 - External trigger filter" ]
            # [ inline ( always ) ]
            pub fn etf(&self) -> EtfR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EtfR { bits }
            }
            # [ doc = "Bit 7 - Master/Slave mode" ]
            # [ inline ( always ) ]
            pub fn msm(&self) -> MsmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsmR { bits }
            }
            # [ doc = "Bits 4:6 - Trigger selection" ]
            # [ inline ( always ) ]
            pub fn ts(&self) -> TsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsR { bits }
            }
            # [ doc = "Bits 0:2 - Slave mode selection" ]
            # [ inline ( always ) ]
            pub fn sms(&self) -> SmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmsR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - External trigger polarity" ]
            # [ inline ( always ) ]
            pub fn etp(&mut self) -> _EtpW {
                _EtpW { w: self }
            }
            # [ doc = "Bit 14 - External clock enable" ]
            # [ inline ( always ) ]
            pub fn ece(&mut self) -> _EceW {
                _EceW { w: self }
            }
            # [ doc = "Bits 12:13 - External trigger prescaler" ]
            # [ inline ( always ) ]
            pub fn etps(&mut self) -> _EtpsW {
                _EtpsW { w: self }
            }
            # [ doc = "Bits 8:11 - External trigger filter" ]
            # [ inline ( always ) ]
            pub fn etf(&mut self) -> _EtfW {
                _EtfW { w: self }
            }
            # [ doc = "Bit 7 - Master/Slave mode" ]
            # [ inline ( always ) ]
            pub fn msm(&mut self) -> _MsmW {
                _MsmW { w: self }
            }
            # [ doc = "Bits 4:6 - Trigger selection" ]
            # [ inline ( always ) ]
            pub fn ts(&mut self) -> _TsW {
                _TsW { w: self }
            }
            # [ doc = "Bits 0:2 - Slave mode selection" ]
            # [ inline ( always ) ]
            pub fn sms(&mut self) -> _SmsW {
                _SmsW { w: self }
            }
        }
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub mod dier {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ieR {
            bits: u8,
        }
        impl Cc1ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2ieR {
            bits: u8,
        }
        impl Cc2ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3ieR {
            bits: u8,
        }
        impl Cc3ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4ieR {
            bits: u8,
        }
        impl Cc4ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ComieR {
            bits: u8,
        }
        impl ComieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TieR {
            bits: u8,
        }
        impl TieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BieR {
            bits: u8,
        }
        impl BieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UdeR {
            bits: u8,
        }
        impl UdeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1deR {
            bits: u8,
        }
        impl Cc1deR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2deR {
            bits: u8,
        }
        impl Cc2deR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3deR {
            bits: u8,
        }
        impl Cc3deR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4deR {
            bits: u8,
        }
        impl Cc4deR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ComdeR {
            bits: u8,
        }
        impl ComdeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TdeR {
            bits: u8,
        }
        impl TdeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ComieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1deW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2deW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3deW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4deW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ComdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComdeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TdeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc1ie(&self) -> Cc1ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ieR { bits }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc2ie(&self) -> Cc2ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ieR { bits }
            }
            # [ doc = "Bit 3 - Capture/Compare 3 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc3ie(&self) -> Cc3ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3ieR { bits }
            }
            # [ doc = "Bit 4 - Capture/Compare 4 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc4ie(&self) -> Cc4ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4ieR { bits }
            }
            # [ doc = "Bit 5 - COM interrupt enable" ]
            # [ inline ( always ) ]
            pub fn comie(&self) -> ComieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComieR { bits }
            }
            # [ doc = "Bit 6 - Trigger interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tie(&self) -> TieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TieR { bits }
            }
            # [ doc = "Bit 7 - Break interrupt enable" ]
            # [ inline ( always ) ]
            pub fn bie(&self) -> BieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BieR { bits }
            }
            # [ doc = "Bit 8 - Update DMA request enable" ]
            # [ inline ( always ) ]
            pub fn ude(&self) -> UdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdeR { bits }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc1de(&self) -> Cc1deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1deR { bits }
            }
            # [ doc = "Bit 10 - Capture/Compare 2 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc2de(&self) -> Cc2deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2deR { bits }
            }
            # [ doc = "Bit 11 - Capture/Compare 3 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc3de(&self) -> Cc3deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3deR { bits }
            }
            # [ doc = "Bit 12 - Capture/Compare 4 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc4de(&self) -> Cc4deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4deR { bits }
            }
            # [ doc = "Bit 13 - COM DMA request enable" ]
            # [ inline ( always ) ]
            pub fn comde(&self) -> ComdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComdeR { bits }
            }
            # [ doc = "Bit 14 - Trigger DMA request enable" ]
            # [ inline ( always ) ]
            pub fn tde(&self) -> TdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TdeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc1ie(&mut self) -> _Cc1ieW {
                _Cc1ieW { w: self }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc2ie(&mut self) -> _Cc2ieW {
                _Cc2ieW { w: self }
            }
            # [ doc = "Bit 3 - Capture/Compare 3 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc3ie(&mut self) -> _Cc3ieW {
                _Cc3ieW { w: self }
            }
            # [ doc = "Bit 4 - Capture/Compare 4 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc4ie(&mut self) -> _Cc4ieW {
                _Cc4ieW { w: self }
            }
            # [ doc = "Bit 5 - COM interrupt enable" ]
            # [ inline ( always ) ]
            pub fn comie(&mut self) -> _ComieW {
                _ComieW { w: self }
            }
            # [ doc = "Bit 6 - Trigger interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tie(&mut self) -> _TieW {
                _TieW { w: self }
            }
            # [ doc = "Bit 7 - Break interrupt enable" ]
            # [ inline ( always ) ]
            pub fn bie(&mut self) -> _BieW {
                _BieW { w: self }
            }
            # [ doc = "Bit 8 - Update DMA request enable" ]
            # [ inline ( always ) ]
            pub fn ude(&mut self) -> _UdeW {
                _UdeW { w: self }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc1de(&mut self) -> _Cc1deW {
                _Cc1deW { w: self }
            }
            # [ doc = "Bit 10 - Capture/Compare 2 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc2de(&mut self) -> _Cc2deW {
                _Cc2deW { w: self }
            }
            # [ doc = "Bit 11 - Capture/Compare 3 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc3de(&mut self) -> _Cc3deW {
                _Cc3deW { w: self }
            }
            # [ doc = "Bit 12 - Capture/Compare 4 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc4de(&mut self) -> _Cc4deW {
                _Cc4deW { w: self }
            }
            # [ doc = "Bit 13 - COM DMA request enable" ]
            # [ inline ( always ) ]
            pub fn comde(&mut self) -> _ComdeW {
                _ComdeW { w: self }
            }
            # [ doc = "Bit 14 - Trigger DMA request enable" ]
            # [ inline ( always ) ]
            pub fn tde(&mut self) -> _TdeW {
                _TdeW { w: self }
            }
        }
    }
    # [ doc = "status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4ofR {
            bits: u8,
        }
        impl Cc4ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3ofR {
            bits: u8,
        }
        impl Cc3ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2ofR {
            bits: u8,
        }
        impl Cc2ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ofR {
            bits: u8,
        }
        impl Cc1ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BifR {
            bits: u8,
        }
        impl BifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TifR {
            bits: u8,
        }
        impl TifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ComifR {
            bits: u8,
        }
        impl ComifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4ifR {
            bits: u8,
        }
        impl Cc4ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3ifR {
            bits: u8,
        }
        impl Cc3ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2ifR {
            bits: u8,
        }
        impl Cc2ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ifR {
            bits: u8,
        }
        impl Cc1ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UifR {
            bits: u8,
        }
        impl UifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ComifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 12 - Capture/Compare 4 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc4of(&self) -> Cc4ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4ofR { bits }
            }
            # [ doc = "Bit 11 - Capture/Compare 3 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc3of(&self) -> Cc3ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3ofR { bits }
            }
            # [ doc = "Bit 10 - Capture/compare 2 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc2of(&self) -> Cc2ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ofR { bits }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc1of(&self) -> Cc1ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ofR { bits }
            }
            # [ doc = "Bit 7 - Break interrupt flag" ]
            # [ inline ( always ) ]
            pub fn bif(&self) -> BifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BifR { bits }
            }
            # [ doc = "Bit 6 - Trigger interrupt flag" ]
            # [ inline ( always ) ]
            pub fn tif(&self) -> TifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TifR { bits }
            }
            # [ doc = "Bit 5 - COM interrupt flag" ]
            # [ inline ( always ) ]
            pub fn comif(&self) -> ComifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComifR { bits }
            }
            # [ doc = "Bit 4 - Capture/Compare 4 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc4if(&self) -> Cc4ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4ifR { bits }
            }
            # [ doc = "Bit 3 - Capture/Compare 3 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc3if(&self) -> Cc3ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3ifR { bits }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc2if(&self) -> Cc2ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ifR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc1if(&self) -> Cc1ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ifR { bits }
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&self) -> UifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UifR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 12 - Capture/Compare 4 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc4of(&mut self) -> _Cc4ofW {
                _Cc4ofW { w: self }
            }
            # [ doc = "Bit 11 - Capture/Compare 3 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc3of(&mut self) -> _Cc3ofW {
                _Cc3ofW { w: self }
            }
            # [ doc = "Bit 10 - Capture/compare 2 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc2of(&mut self) -> _Cc2ofW {
                _Cc2ofW { w: self }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc1of(&mut self) -> _Cc1ofW {
                _Cc1ofW { w: self }
            }
            # [ doc = "Bit 7 - Break interrupt flag" ]
            # [ inline ( always ) ]
            pub fn bif(&mut self) -> _BifW {
                _BifW { w: self }
            }
            # [ doc = "Bit 6 - Trigger interrupt flag" ]
            # [ inline ( always ) ]
            pub fn tif(&mut self) -> _TifW {
                _TifW { w: self }
            }
            # [ doc = "Bit 5 - COM interrupt flag" ]
            # [ inline ( always ) ]
            pub fn comif(&mut self) -> _ComifW {
                _ComifW { w: self }
            }
            # [ doc = "Bit 4 - Capture/Compare 4 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc4if(&mut self) -> _Cc4ifW {
                _Cc4ifW { w: self }
            }
            # [ doc = "Bit 3 - Capture/Compare 3 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc3if(&mut self) -> _Cc3ifW {
                _Cc3ifW { w: self }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc2if(&mut self) -> _Cc2ifW {
                _Cc2ifW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc1if(&mut self) -> _Cc1ifW {
                _Cc1ifW { w: self }
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    # [ doc = "event generation register" ]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    # [ doc = "event generation register" ]
    pub mod egr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ComgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 7 - Break generation" ]
            # [ inline ( always ) ]
            pub fn bg(&mut self) -> _BgW {
                _BgW { w: self }
            }
            # [ doc = "Bit 6 - Trigger generation" ]
            # [ inline ( always ) ]
            pub fn tg(&mut self) -> _TgW {
                _TgW { w: self }
            }
            # [ doc = "Bit 5 - Capture/Compare control update generation" ]
            # [ inline ( always ) ]
            pub fn comg(&mut self) -> _ComgW {
                _ComgW { w: self }
            }
            # [ doc = "Bit 4 - Capture/compare 4 generation" ]
            # [ inline ( always ) ]
            pub fn cc4g(&mut self) -> _Cc4gW {
                _Cc4gW { w: self }
            }
            # [ doc = "Bit 3 - Capture/compare 3 generation" ]
            # [ inline ( always ) ]
            pub fn cc3g(&mut self) -> _Cc3gW {
                _Cc3gW { w: self }
            }
            # [ doc = "Bit 2 - Capture/compare 2 generation" ]
            # [ inline ( always ) ]
            pub fn cc2g(&mut self) -> _Cc2gW {
                _Cc2gW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare 1 generation" ]
            # [ inline ( always ) ]
            pub fn cc1g(&mut self) -> _Cc1gW {
                _Cc1gW { w: self }
            }
            # [ doc = "Bit 0 - Update generation" ]
            # [ inline ( always ) ]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register (output mode)" ]
    pub struct Ccmr1Output {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register (output mode)" ]
    pub mod ccmr1_output {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Output {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2ceR {
            bits: u8,
        }
        impl Oc2ceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2mR {
            bits: u8,
        }
        impl Oc2mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2peR {
            bits: u8,
        }
        impl Oc2peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2feR {
            bits: u8,
        }
        impl Oc2feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1ceR {
            bits: u8,
        }
        impl Oc1ceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1mR {
            bits: u8,
        }
        impl Oc1mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1peR {
            bits: u8,
        }
        impl Oc1peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1feR {
            bits: u8,
        }
        impl Oc1feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2ceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1ceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - Output Compare 2 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc2ce(&self) -> Oc2ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2ceR { bits }
            }
            # [ doc = "Bits 12:14 - Output Compare 2 mode" ]
            # [ inline ( always ) ]
            pub fn oc2m(&self) -> Oc2mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2mR { bits }
            }
            # [ doc = "Bit 11 - Output Compare 2 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc2pe(&self) -> Oc2peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2peR { bits }
            }
            # [ doc = "Bit 10 - Output Compare 2 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc2fe(&self) -> Oc2feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2feR { bits }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            # [ doc = "Bit 7 - Output Compare 1 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc1ce(&self) -> Oc1ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1ceR { bits }
            }
            # [ doc = "Bits 4:6 - Output Compare 1 mode" ]
            # [ inline ( always ) ]
            pub fn oc1m(&self) -> Oc1mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1mR { bits }
            }
            # [ doc = "Bit 3 - Output Compare 1 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc1pe(&self) -> Oc1peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1peR { bits }
            }
            # [ doc = "Bit 2 - Output Compare 1 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc1fe(&self) -> Oc1feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1feR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - Output Compare 2 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc2ce(&mut self) -> _Oc2ceW {
                _Oc2ceW { w: self }
            }
            # [ doc = "Bits 12:14 - Output Compare 2 mode" ]
            # [ inline ( always ) ]
            pub fn oc2m(&mut self) -> _Oc2mW {
                _Oc2mW { w: self }
            }
            # [ doc = "Bit 11 - Output Compare 2 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc2pe(&mut self) -> _Oc2peW {
                _Oc2peW { w: self }
            }
            # [ doc = "Bit 10 - Output Compare 2 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc2fe(&mut self) -> _Oc2feW {
                _Oc2feW { w: self }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            # [ doc = "Bit 7 - Output Compare 1 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc1ce(&mut self) -> _Oc1ceW {
                _Oc1ceW { w: self }
            }
            # [ doc = "Bits 4:6 - Output Compare 1 mode" ]
            # [ inline ( always ) ]
            pub fn oc1m(&mut self) -> _Oc1mW {
                _Oc1mW { w: self }
            }
            # [ doc = "Bit 3 - Output Compare 1 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc1pe(&mut self) -> _Oc1peW {
                _Oc1peW { w: self }
            }
            # [ doc = "Bit 2 - Output Compare 1 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc1fe(&mut self) -> _Oc1feW {
                _Oc1feW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register 1 (input mode)" ]
    pub struct Ccmr1Input {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register 1 (input mode)" ]
    pub mod ccmr1_input {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Input {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic2fR {
            bits: u8,
        }
        impl Ic2fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic2pcsR {
            bits: u8,
        }
        impl Ic2pcsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic1fR {
            bits: u8,
        }
        impl Ic1fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IcpcsR {
            bits: u8,
        }
        impl IcpcsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic2fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic2pcsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2pcsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic1fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IcpcsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IcpcsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 15:18 - Input capture 2 filter" ]
            # [ inline ( always ) ]
            pub fn ic2f(&self) -> Ic2fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2fR { bits }
            }
            # [ doc = "Bits 10:11 - Input capture 2 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic2pcs(&self) -> Ic2pcsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2pcsR { bits }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            # [ doc = "Bits 4:7 - Input capture 1 filter" ]
            # [ inline ( always ) ]
            pub fn ic1f(&self) -> Ic1fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1fR { bits }
            }
            # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
            # [ inline ( always ) ]
            pub fn icpcs(&self) -> IcpcsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IcpcsR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 15:18 - Input capture 2 filter" ]
            # [ inline ( always ) ]
            pub fn ic2f(&mut self) -> _Ic2fW {
                _Ic2fW { w: self }
            }
            # [ doc = "Bits 10:11 - Input capture 2 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic2pcs(&mut self) -> _Ic2pcsW {
                _Ic2pcsW { w: self }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            # [ doc = "Bits 4:7 - Input capture 1 filter" ]
            # [ inline ( always ) ]
            pub fn ic1f(&mut self) -> _Ic1fW {
                _Ic1fW { w: self }
            }
            # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
            # [ inline ( always ) ]
            pub fn icpcs(&mut self) -> _IcpcsW {
                _IcpcsW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register (output mode)" ]
    pub struct Ccmr2Output {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register (output mode)" ]
    pub mod ccmr2_output {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr2Output {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc4ceR {
            bits: u8,
        }
        impl Oc4ceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc4mR {
            bits: u8,
        }
        impl Oc4mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc4peR {
            bits: u8,
        }
        impl Oc4peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc4feR {
            bits: u8,
        }
        impl Oc4feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4sR {
            bits: u8,
        }
        impl Cc4sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc3ceR {
            bits: u8,
        }
        impl Oc3ceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc3mR {
            bits: u8,
        }
        impl Oc3mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc3peR {
            bits: u8,
        }
        impl Oc3peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc3feR {
            bits: u8,
        }
        impl Oc3feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3sR {
            bits: u8,
        }
        impl Cc3sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc4ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4ceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc4mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc4peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc4feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc3ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3ceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc3mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc3peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc3feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - Output compare 4 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc4ce(&self) -> Oc4ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4ceR { bits }
            }
            # [ doc = "Bits 12:14 - Output compare 4 mode" ]
            # [ inline ( always ) ]
            pub fn oc4m(&self) -> Oc4mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4mR { bits }
            }
            # [ doc = "Bit 11 - Output compare 4 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc4pe(&self) -> Oc4peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4peR { bits }
            }
            # [ doc = "Bit 10 - Output compare 4 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc4fe(&self) -> Oc4feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4feR { bits }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 4 selection" ]
            # [ inline ( always ) ]
            pub fn cc4s(&self) -> Cc4sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4sR { bits }
            }
            # [ doc = "Bit 7 - Output compare 3 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc3ce(&self) -> Oc3ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3ceR { bits }
            }
            # [ doc = "Bits 4:6 - Output compare 3 mode" ]
            # [ inline ( always ) ]
            pub fn oc3m(&self) -> Oc3mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3mR { bits }
            }
            # [ doc = "Bit 3 - Output compare 3 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc3pe(&self) -> Oc3peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3peR { bits }
            }
            # [ doc = "Bit 2 - Output compare 3 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc3fe(&self) -> Oc3feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3feR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 3 selection" ]
            # [ inline ( always ) ]
            pub fn cc3s(&self) -> Cc3sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - Output compare 4 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc4ce(&mut self) -> _Oc4ceW {
                _Oc4ceW { w: self }
            }
            # [ doc = "Bits 12:14 - Output compare 4 mode" ]
            # [ inline ( always ) ]
            pub fn oc4m(&mut self) -> _Oc4mW {
                _Oc4mW { w: self }
            }
            # [ doc = "Bit 11 - Output compare 4 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc4pe(&mut self) -> _Oc4peW {
                _Oc4peW { w: self }
            }
            # [ doc = "Bit 10 - Output compare 4 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc4fe(&mut self) -> _Oc4feW {
                _Oc4feW { w: self }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 4 selection" ]
            # [ inline ( always ) ]
            pub fn cc4s(&mut self) -> _Cc4sW {
                _Cc4sW { w: self }
            }
            # [ doc = "Bit 7 - Output compare 3 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc3ce(&mut self) -> _Oc3ceW {
                _Oc3ceW { w: self }
            }
            # [ doc = "Bits 4:6 - Output compare 3 mode" ]
            # [ inline ( always ) ]
            pub fn oc3m(&mut self) -> _Oc3mW {
                _Oc3mW { w: self }
            }
            # [ doc = "Bit 3 - Output compare 3 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc3pe(&mut self) -> _Oc3peW {
                _Oc3peW { w: self }
            }
            # [ doc = "Bit 2 - Output compare 3 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc3fe(&mut self) -> _Oc3feW {
                _Oc3feW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 3 selection" ]
            # [ inline ( always ) ]
            pub fn cc3s(&mut self) -> _Cc3sW {
                _Cc3sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register 2 (input mode)" ]
    pub struct Ccmr2Input {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register 2 (input mode)" ]
    pub mod ccmr2_input {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr2Input {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic4fR {
            bits: u8,
        }
        impl Ic4fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic4pscR {
            bits: u8,
        }
        impl Ic4pscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4sR {
            bits: u8,
        }
        impl Cc4sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic3fR {
            bits: u8,
        }
        impl Ic3fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic3pscR {
            bits: u8,
        }
        impl Ic3pscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3sR {
            bits: u8,
        }
        impl Cc3sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic4fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic4fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic4pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic4pscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic3fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic3fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic3pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic3pscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 15:18 - Input capture 4 filter" ]
            # [ inline ( always ) ]
            pub fn ic4f(&self) -> Ic4fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic4fR { bits }
            }
            # [ doc = "Bits 10:11 - Input capture 4 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic4psc(&self) -> Ic4pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic4pscR { bits }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 4 selection" ]
            # [ inline ( always ) ]
            pub fn cc4s(&self) -> Cc4sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4sR { bits }
            }
            # [ doc = "Bits 4:7 - Input capture 3 filter" ]
            # [ inline ( always ) ]
            pub fn ic3f(&self) -> Ic3fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic3fR { bits }
            }
            # [ doc = "Bits 2:3 - Input capture 3 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic3psc(&self) -> Ic3pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic3pscR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/compare 3 selection" ]
            # [ inline ( always ) ]
            pub fn cc3s(&self) -> Cc3sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 15:18 - Input capture 4 filter" ]
            # [ inline ( always ) ]
            pub fn ic4f(&mut self) -> _Ic4fW {
                _Ic4fW { w: self }
            }
            # [ doc = "Bits 10:11 - Input capture 4 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic4psc(&mut self) -> _Ic4pscW {
                _Ic4pscW { w: self }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 4 selection" ]
            # [ inline ( always ) ]
            pub fn cc4s(&mut self) -> _Cc4sW {
                _Cc4sW { w: self }
            }
            # [ doc = "Bits 4:7 - Input capture 3 filter" ]
            # [ inline ( always ) ]
            pub fn ic3f(&mut self) -> _Ic3fW {
                _Ic3fW { w: self }
            }
            # [ doc = "Bits 2:3 - Input capture 3 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic3psc(&mut self) -> _Ic3pscW {
                _Ic3pscW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/compare 3 selection" ]
            # [ inline ( always ) ]
            pub fn cc3s(&mut self) -> _Cc3sW {
                _Cc3sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare enable register" ]
    pub struct Ccer {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare enable register" ]
    pub mod ccer {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccer {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4pR {
            bits: u8,
        }
        impl Cc4pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4eR {
            bits: u8,
        }
        impl Cc4eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3npR {
            bits: u8,
        }
        impl Cc3npR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3neR {
            bits: u8,
        }
        impl Cc3neR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3pR {
            bits: u8,
        }
        impl Cc3pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3eR {
            bits: u8,
        }
        impl Cc3eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2npR {
            bits: u8,
        }
        impl Cc2npR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2neR {
            bits: u8,
        }
        impl Cc2neR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2pR {
            bits: u8,
        }
        impl Cc2pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2eR {
            bits: u8,
        }
        impl Cc2eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1npR {
            bits: u8,
        }
        impl Cc1npR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1neR {
            bits: u8,
        }
        impl Cc1neR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1pR {
            bits: u8,
        }
        impl Cc1pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1eR {
            bits: u8,
        }
        impl Cc1eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3npW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3neW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3neW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2npW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2neW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2neW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1npW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1neW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1neW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 13 - Capture/Compare 3 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc4p(&self) -> Cc4pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4pR { bits }
            }
            # [ doc = "Bit 12 - Capture/Compare 4 output enable" ]
            # [ inline ( always ) ]
            pub fn cc4e(&self) -> Cc4eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4eR { bits }
            }
            # [ doc = "Bit 11 - Capture/Compare 3 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc3np(&self) -> Cc3npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3npR { bits }
            }
            # [ doc = "Bit 10 - Capture/Compare 3 complementary output enable" ]
            # [ inline ( always ) ]
            pub fn cc3ne(&self) -> Cc3neR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3neR { bits }
            }
            # [ doc = "Bit 9 - Capture/Compare 3 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc3p(&self) -> Cc3pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3pR { bits }
            }
            # [ doc = "Bit 8 - Capture/Compare 3 output enable" ]
            # [ inline ( always ) ]
            pub fn cc3e(&self) -> Cc3eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3eR { bits }
            }
            # [ doc = "Bit 7 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2np(&self) -> Cc2npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2npR { bits }
            }
            # [ doc = "Bit 6 - Capture/Compare 2 complementary output enable" ]
            # [ inline ( always ) ]
            pub fn cc2ne(&self) -> Cc2neR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2neR { bits }
            }
            # [ doc = "Bit 5 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2p(&self) -> Cc2pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2pR { bits }
            }
            # [ doc = "Bit 4 - Capture/Compare 2 output enable" ]
            # [ inline ( always ) ]
            pub fn cc2e(&self) -> Cc2eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2eR { bits }
            }
            # [ doc = "Bit 3 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1np(&self) -> Cc1npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1npR { bits }
            }
            # [ doc = "Bit 2 - Capture/Compare 1 complementary output enable" ]
            # [ inline ( always ) ]
            pub fn cc1ne(&self) -> Cc1neR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1neR { bits }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1p(&self) -> Cc1pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1pR { bits }
            }
            # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
            # [ inline ( always ) ]
            pub fn cc1e(&self) -> Cc1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1eR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 13 - Capture/Compare 3 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc4p(&mut self) -> _Cc4pW {
                _Cc4pW { w: self }
            }
            # [ doc = "Bit 12 - Capture/Compare 4 output enable" ]
            # [ inline ( always ) ]
            pub fn cc4e(&mut self) -> _Cc4eW {
                _Cc4eW { w: self }
            }
            # [ doc = "Bit 11 - Capture/Compare 3 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc3np(&mut self) -> _Cc3npW {
                _Cc3npW { w: self }
            }
            # [ doc = "Bit 10 - Capture/Compare 3 complementary output enable" ]
            # [ inline ( always ) ]
            pub fn cc3ne(&mut self) -> _Cc3neW {
                _Cc3neW { w: self }
            }
            # [ doc = "Bit 9 - Capture/Compare 3 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc3p(&mut self) -> _Cc3pW {
                _Cc3pW { w: self }
            }
            # [ doc = "Bit 8 - Capture/Compare 3 output enable" ]
            # [ inline ( always ) ]
            pub fn cc3e(&mut self) -> _Cc3eW {
                _Cc3eW { w: self }
            }
            # [ doc = "Bit 7 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2np(&mut self) -> _Cc2npW {
                _Cc2npW { w: self }
            }
            # [ doc = "Bit 6 - Capture/Compare 2 complementary output enable" ]
            # [ inline ( always ) ]
            pub fn cc2ne(&mut self) -> _Cc2neW {
                _Cc2neW { w: self }
            }
            # [ doc = "Bit 5 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2p(&mut self) -> _Cc2pW {
                _Cc2pW { w: self }
            }
            # [ doc = "Bit 4 - Capture/Compare 2 output enable" ]
            # [ inline ( always ) ]
            pub fn cc2e(&mut self) -> _Cc2eW {
                _Cc2eW { w: self }
            }
            # [ doc = "Bit 3 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1np(&mut self) -> _Cc1npW {
                _Cc1npW { w: self }
            }
            # [ doc = "Bit 2 - Capture/Compare 1 complementary output enable" ]
            # [ inline ( always ) ]
            pub fn cc1ne(&mut self) -> _Cc1neW {
                _Cc1neW { w: self }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1p(&mut self) -> _Cc1pW {
                _Cc1pW { w: self }
            }
            # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
            # [ inline ( always ) ]
            pub fn cc1e(&mut self) -> _Cc1eW {
                _Cc1eW { w: self }
            }
        }
    }
    # [ doc = "counter" ]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    # [ doc = "counter" ]
    pub mod cnt {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&mut self) -> _CntW {
                _CntW { w: self }
            }
        }
    }
    # [ doc = "prescaler" ]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    # [ doc = "prescaler" ]
    pub mod psc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    # [ doc = "auto-reload register" ]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    # [ doc = "auto-reload register" ]
    pub mod arr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArrR {
            bits: u16,
        }
        impl ArrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&self) -> ArrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&mut self) -> _ArrW {
                _ArrW { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 1" ]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 1" ]
    pub mod ccr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr1R {
            bits: u16,
        }
        impl Ccr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
            # [ inline ( always ) ]
            pub fn ccr1(&self) -> Ccr1R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
            # [ inline ( always ) ]
            pub fn ccr1(&mut self) -> _Ccr1W {
                _Ccr1W { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 2" ]
    pub struct Ccr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 2" ]
    pub mod ccr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr2R {
            bits: u16,
        }
        impl Ccr2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare 2 value" ]
            # [ inline ( always ) ]
            pub fn ccr2(&self) -> Ccr2R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr2R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare 2 value" ]
            # [ inline ( always ) ]
            pub fn ccr2(&mut self) -> _Ccr2W {
                _Ccr2W { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 3" ]
    pub struct Ccr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 3" ]
    pub mod ccr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr3R {
            bits: u16,
        }
        impl Ccr3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare value" ]
            # [ inline ( always ) ]
            pub fn ccr3(&self) -> Ccr3R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare value" ]
            # [ inline ( always ) ]
            pub fn ccr3(&mut self) -> _Ccr3W {
                _Ccr3W { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 4" ]
    pub struct Ccr4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 4" ]
    pub mod ccr4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr4R {
            bits: u16,
        }
        impl Ccr4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare value" ]
            # [ inline ( always ) ]
            pub fn ccr4(&self) -> Ccr4R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr4R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare value" ]
            # [ inline ( always ) ]
            pub fn ccr4(&mut self) -> _Ccr4W {
                _Ccr4W { w: self }
            }
        }
    }
    # [ doc = "DMA control register" ]
    pub struct Dcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA control register" ]
    pub mod dcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DblR {
            bits: u8,
        }
        impl DblR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbaR {
            bits: u8,
        }
        impl DbaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DblW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DblW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 8:12 - DMA burst length" ]
            # [ inline ( always ) ]
            pub fn dbl(&self) -> DblR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DblR { bits }
            }
            # [ doc = "Bits 0:4 - DMA base address" ]
            # [ inline ( always ) ]
            pub fn dba(&self) -> DbaR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 8:12 - DMA burst length" ]
            # [ inline ( always ) ]
            pub fn dbl(&mut self) -> _DblW {
                _DblW { w: self }
            }
            # [ doc = "Bits 0:4 - DMA base address" ]
            # [ inline ( always ) ]
            pub fn dba(&mut self) -> _DbaW {
                _DbaW { w: self }
            }
        }
    }
    # [ doc = "DMA address for full transfer" ]
    pub struct Dmar {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA address for full transfer" ]
    pub mod dmar {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dmar {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmabR {
            bits: u16,
        }
        impl DmabR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmabW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmabW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - DMA register for burst accesses" ]
            # [ inline ( always ) ]
            pub fn dmab(&self) -> DmabR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DmabR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - DMA register for burst accesses" ]
            # [ inline ( always ) ]
            pub fn dmab(&mut self) -> _DmabW {
                _DmabW { w: self }
            }
        }
    }
    # [ doc = "repetition counter register" ]
    pub struct Rcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "repetition counter register" ]
    pub mod rcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Rcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RepR {
            bits: u8,
        }
        impl RepR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RepW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RepW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Repetition counter value" ]
            # [ inline ( always ) ]
            pub fn rep(&self) -> RepR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RepR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Repetition counter value" ]
            # [ inline ( always ) ]
            pub fn rep(&mut self) -> _RepW {
                _RepW { w: self }
            }
        }
    }
    # [ doc = "break and dead-time register" ]
    pub struct Bdtr {
        register: VolatileCell<u32>,
    }
    # [ doc = "break and dead-time register" ]
    pub mod bdtr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bdtr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MoeR {
            bits: u8,
        }
        impl MoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AoeR {
            bits: u8,
        }
        impl AoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BkpR {
            bits: u8,
        }
        impl BkpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BkeR {
            bits: u8,
        }
        impl BkeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OssrR {
            bits: u8,
        }
        impl OssrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OssiR {
            bits: u8,
        }
        impl OssiR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LockR {
            bits: u8,
        }
        impl LockR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DtgR {
            bits: u8,
        }
        impl DtgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BkpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BkeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OssrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OssrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OssiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OssiW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LockW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DtgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DtgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - Main output enable" ]
            # [ inline ( always ) ]
            pub fn moe(&self) -> MoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MoeR { bits }
            }
            # [ doc = "Bit 14 - Automatic output enable" ]
            # [ inline ( always ) ]
            pub fn aoe(&self) -> AoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AoeR { bits }
            }
            # [ doc = "Bit 13 - Break polarity" ]
            # [ inline ( always ) ]
            pub fn bkp(&self) -> BkpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkpR { bits }
            }
            # [ doc = "Bit 12 - Break enable" ]
            # [ inline ( always ) ]
            pub fn bke(&self) -> BkeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkeR { bits }
            }
            # [ doc = "Bit 11 - Off-state selection for Run mode" ]
            # [ inline ( always ) ]
            pub fn ossr(&self) -> OssrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OssrR { bits }
            }
            # [ doc = "Bit 10 - Off-state selection for Idle mode" ]
            # [ inline ( always ) ]
            pub fn ossi(&self) -> OssiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OssiR { bits }
            }
            # [ doc = "Bits 8:9 - Lock configuration" ]
            # [ inline ( always ) ]
            pub fn lock(&self) -> LockR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LockR { bits }
            }
            # [ doc = "Bits 0:7 - Dead-time generator setup" ]
            # [ inline ( always ) ]
            pub fn dtg(&self) -> DtgR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DtgR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - Main output enable" ]
            # [ inline ( always ) ]
            pub fn moe(&mut self) -> _MoeW {
                _MoeW { w: self }
            }
            # [ doc = "Bit 14 - Automatic output enable" ]
            # [ inline ( always ) ]
            pub fn aoe(&mut self) -> _AoeW {
                _AoeW { w: self }
            }
            # [ doc = "Bit 13 - Break polarity" ]
            # [ inline ( always ) ]
            pub fn bkp(&mut self) -> _BkpW {
                _BkpW { w: self }
            }
            # [ doc = "Bit 12 - Break enable" ]
            # [ inline ( always ) ]
            pub fn bke(&mut self) -> _BkeW {
                _BkeW { w: self }
            }
            # [ doc = "Bit 11 - Off-state selection for Run mode" ]
            # [ inline ( always ) ]
            pub fn ossr(&mut self) -> _OssrW {
                _OssrW { w: self }
            }
            # [ doc = "Bit 10 - Off-state selection for Idle mode" ]
            # [ inline ( always ) ]
            pub fn ossi(&mut self) -> _OssiW {
                _OssiW { w: self }
            }
            # [ doc = "Bits 8:9 - Lock configuration" ]
            # [ inline ( always ) ]
            pub fn lock(&mut self) -> _LockW {
                _LockW { w: self }
            }
            # [ doc = "Bits 0:7 - Dead-time generator setup" ]
            # [ inline ( always ) ]
            pub fn dtg(&mut self) -> _DtgW {
                _DtgW { w: self }
            }
        }
    }
}
# [ doc = "Advanced timer" ]
pub struct Tim1 {
    register_block: tim1::RegisterBlock,
}
impl Deref for Tim1 {
    type Target = tim1::RegisterBlock;
    fn deref(&self) -> &tim1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "General purpose timer" ]
pub const TIM2: Peripheral<Tim2> = unsafe { Peripheral::new(1073741824) };
# [ doc = "General purpose timer" ]
pub mod tim2 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - control register 1" ]
        pub cr1: Cr1,
        # [ doc = "0x04 - control register 2" ]
        pub cr2: Cr2,
        # [ doc = "0x08 - slave mode control register" ]
        pub smcr: Smcr,
        # [ doc = "0x0c - DMA/Interrupt enable register" ]
        pub dier: Dier,
        # [ doc = "0x10 - status register" ]
        pub sr: Sr,
        # [ doc = "0x14 - event generation register" ]
        pub egr: Egr,
        # [ doc = "0x18 - capture/compare mode register 1 (output mode)" ]
        pub ccmr1_output: Ccmr1Output,
        # [ doc = "0x1c - capture/compare mode register 2 (output mode)" ]
        pub ccmr2_output: Ccmr2Output,
        # [ doc = "0x20 - capture/compare enable register" ]
        pub ccer: Ccer,
        # [ doc = "0x24 - counter" ]
        pub cnt: Cnt,
        # [ doc = "0x28 - prescaler" ]
        pub psc: Psc,
        # [ doc = "0x2c - auto-reload register" ]
        pub arr: Arr,
        _reserved0: [u8; 4usize],
        # [ doc = "0x34 - capture/compare register 1" ]
        pub ccr1: Ccr1,
        # [ doc = "0x38 - capture/compare register 2" ]
        pub ccr2: Ccr2,
        # [ doc = "0x3c - capture/compare register 3" ]
        pub ccr3: Ccr3,
        # [ doc = "0x40 - capture/compare register 4" ]
        pub ccr4: Ccr4,
        _reserved1: [u8; 4usize],
        # [ doc = "0x48 - DMA control register" ]
        pub dcr: Dcr,
        # [ doc = "0x4c - DMA address for full transfer" ]
        pub dmar: Dmar,
    }
    # [ doc = "control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CkdR {
            bits: u8,
        }
        impl CkdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CmsR {
            bits: u8,
        }
        impl CmsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OpmR {
            bits: u8,
        }
        impl OpmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CenR {
            bits: u8,
        }
        impl CenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CkdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CkdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OpmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 8:9 - Clock division" ]
            # [ inline ( always ) ]
            pub fn ckd(&self) -> CkdR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CkdR { bits }
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            # [ doc = "Bits 5:6 - Center-aligned mode selection" ]
            # [ inline ( always ) ]
            pub fn cms(&self) -> CmsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CmsR { bits }
            }
            # [ doc = "Bit 4 - Direction" ]
            # [ inline ( always ) ]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            # [ doc = "Bit 3 - One-pulse mode" ]
            # [ inline ( always ) ]
            pub fn opm(&self) -> OpmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpmR { bits }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&self) -> CenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 8:9 - Clock division" ]
            # [ inline ( always ) ]
            pub fn ckd(&mut self) -> _CkdW {
                _CkdW { w: self }
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            # [ doc = "Bits 5:6 - Center-aligned mode selection" ]
            # [ inline ( always ) ]
            pub fn cms(&mut self) -> _CmsW {
                _CmsW { w: self }
            }
            # [ doc = "Bit 4 - Direction" ]
            # [ inline ( always ) ]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            # [ doc = "Bit 3 - One-pulse mode" ]
            # [ inline ( always ) ]
            pub fn opm(&mut self) -> _OpmW {
                _OpmW { w: self }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    # [ doc = "control register 2" ]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 2" ]
    pub mod cr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ti1sR {
            bits: u8,
        }
        impl Ti1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MmsR {
            bits: u8,
        }
        impl MmsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcdsR {
            bits: u8,
        }
        impl CcdsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ti1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ti1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MmsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcdsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcdsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 7 - TI1 selection" ]
            # [ inline ( always ) ]
            pub fn ti1s(&self) -> Ti1sR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ti1sR { bits }
            }
            # [ doc = "Bits 4:6 - Master mode selection" ]
            # [ inline ( always ) ]
            pub fn mms(&self) -> MmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MmsR { bits }
            }
            # [ doc = "Bit 3 - Capture/compare DMA selection" ]
            # [ inline ( always ) ]
            pub fn ccds(&self) -> CcdsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcdsR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 7 - TI1 selection" ]
            # [ inline ( always ) ]
            pub fn ti1s(&mut self) -> _Ti1sW {
                _Ti1sW { w: self }
            }
            # [ doc = "Bits 4:6 - Master mode selection" ]
            # [ inline ( always ) ]
            pub fn mms(&mut self) -> _MmsW {
                _MmsW { w: self }
            }
            # [ doc = "Bit 3 - Capture/compare DMA selection" ]
            # [ inline ( always ) ]
            pub fn ccds(&mut self) -> _CcdsW {
                _CcdsW { w: self }
            }
        }
    }
    # [ doc = "slave mode control register" ]
    pub struct Smcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "slave mode control register" ]
    pub mod smcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Smcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EtpR {
            bits: u8,
        }
        impl EtpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EceR {
            bits: u8,
        }
        impl EceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EtpsR {
            bits: u8,
        }
        impl EtpsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EtfR {
            bits: u8,
        }
        impl EtfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MsmR {
            bits: u8,
        }
        impl MsmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TsR {
            bits: u8,
        }
        impl TsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SmsR {
            bits: u8,
        }
        impl SmsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OccsR {
            bits: u8,
        }
        impl OccsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EtpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EtpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EtpsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EtpsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EtfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EtfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MsmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OccsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OccsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - External trigger polarity" ]
            # [ inline ( always ) ]
            pub fn etp(&self) -> EtpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EtpR { bits }
            }
            # [ doc = "Bit 14 - External clock enable" ]
            # [ inline ( always ) ]
            pub fn ece(&self) -> EceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EceR { bits }
            }
            # [ doc = "Bits 12:13 - External trigger prescaler" ]
            # [ inline ( always ) ]
            pub fn etps(&self) -> EtpsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EtpsR { bits }
            }
            # [ doc = "Bits 8:11 - External trigger filter" ]
            # [ inline ( always ) ]
            pub fn etf(&self) -> EtfR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EtfR { bits }
            }
            # [ doc = "Bit 7 - Master/Slave mode" ]
            # [ inline ( always ) ]
            pub fn msm(&self) -> MsmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsmR { bits }
            }
            # [ doc = "Bits 4:6 - Trigger selection" ]
            # [ inline ( always ) ]
            pub fn ts(&self) -> TsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsR { bits }
            }
            # [ doc = "Bits 0:2 - Slave mode selection" ]
            # [ inline ( always ) ]
            pub fn sms(&self) -> SmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmsR { bits }
            }
            # [ doc = "Bit 3 - OCREF clear selection" ]
            # [ inline ( always ) ]
            pub fn occs(&self) -> OccsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OccsR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - External trigger polarity" ]
            # [ inline ( always ) ]
            pub fn etp(&mut self) -> _EtpW {
                _EtpW { w: self }
            }
            # [ doc = "Bit 14 - External clock enable" ]
            # [ inline ( always ) ]
            pub fn ece(&mut self) -> _EceW {
                _EceW { w: self }
            }
            # [ doc = "Bits 12:13 - External trigger prescaler" ]
            # [ inline ( always ) ]
            pub fn etps(&mut self) -> _EtpsW {
                _EtpsW { w: self }
            }
            # [ doc = "Bits 8:11 - External trigger filter" ]
            # [ inline ( always ) ]
            pub fn etf(&mut self) -> _EtfW {
                _EtfW { w: self }
            }
            # [ doc = "Bit 7 - Master/Slave mode" ]
            # [ inline ( always ) ]
            pub fn msm(&mut self) -> _MsmW {
                _MsmW { w: self }
            }
            # [ doc = "Bits 4:6 - Trigger selection" ]
            # [ inline ( always ) ]
            pub fn ts(&mut self) -> _TsW {
                _TsW { w: self }
            }
            # [ doc = "Bits 0:2 - Slave mode selection" ]
            # [ inline ( always ) ]
            pub fn sms(&mut self) -> _SmsW {
                _SmsW { w: self }
            }
            # [ doc = "Bit 3 - OCREF clear selection" ]
            # [ inline ( always ) ]
            pub fn occs(&mut self) -> _OccsW {
                _OccsW { w: self }
            }
        }
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub mod dier {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TdeR {
            bits: u8,
        }
        impl TdeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4deR {
            bits: u8,
        }
        impl Cc4deR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3deR {
            bits: u8,
        }
        impl Cc3deR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2deR {
            bits: u8,
        }
        impl Cc2deR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1deR {
            bits: u8,
        }
        impl Cc1deR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UdeR {
            bits: u8,
        }
        impl UdeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TieR {
            bits: u8,
        }
        impl TieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4ieR {
            bits: u8,
        }
        impl Cc4ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3ieR {
            bits: u8,
        }
        impl Cc3ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2ieR {
            bits: u8,
        }
        impl Cc2ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ieR {
            bits: u8,
        }
        impl Cc1ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TdeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4deW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3deW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2deW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1deW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 14 - Trigger DMA request enable" ]
            # [ inline ( always ) ]
            pub fn tde(&self) -> TdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TdeR { bits }
            }
            # [ doc = "Bit 12 - Capture/Compare 4 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc4de(&self) -> Cc4deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4deR { bits }
            }
            # [ doc = "Bit 11 - Capture/Compare 3 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc3de(&self) -> Cc3deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3deR { bits }
            }
            # [ doc = "Bit 10 - Capture/Compare 2 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc2de(&self) -> Cc2deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2deR { bits }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc1de(&self) -> Cc1deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1deR { bits }
            }
            # [ doc = "Bit 8 - Update DMA request enable" ]
            # [ inline ( always ) ]
            pub fn ude(&self) -> UdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdeR { bits }
            }
            # [ doc = "Bit 6 - Trigger interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tie(&self) -> TieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TieR { bits }
            }
            # [ doc = "Bit 4 - Capture/Compare 4 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc4ie(&self) -> Cc4ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4ieR { bits }
            }
            # [ doc = "Bit 3 - Capture/Compare 3 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc3ie(&self) -> Cc3ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3ieR { bits }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc2ie(&self) -> Cc2ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ieR { bits }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc1ie(&self) -> Cc1ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ieR { bits }
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 14 - Trigger DMA request enable" ]
            # [ inline ( always ) ]
            pub fn tde(&mut self) -> _TdeW {
                _TdeW { w: self }
            }
            # [ doc = "Bit 12 - Capture/Compare 4 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc4de(&mut self) -> _Cc4deW {
                _Cc4deW { w: self }
            }
            # [ doc = "Bit 11 - Capture/Compare 3 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc3de(&mut self) -> _Cc3deW {
                _Cc3deW { w: self }
            }
            # [ doc = "Bit 10 - Capture/Compare 2 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc2de(&mut self) -> _Cc2deW {
                _Cc2deW { w: self }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc1de(&mut self) -> _Cc1deW {
                _Cc1deW { w: self }
            }
            # [ doc = "Bit 8 - Update DMA request enable" ]
            # [ inline ( always ) ]
            pub fn ude(&mut self) -> _UdeW {
                _UdeW { w: self }
            }
            # [ doc = "Bit 6 - Trigger interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tie(&mut self) -> _TieW {
                _TieW { w: self }
            }
            # [ doc = "Bit 4 - Capture/Compare 4 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc4ie(&mut self) -> _Cc4ieW {
                _Cc4ieW { w: self }
            }
            # [ doc = "Bit 3 - Capture/Compare 3 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc3ie(&mut self) -> _Cc3ieW {
                _Cc3ieW { w: self }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc2ie(&mut self) -> _Cc2ieW {
                _Cc2ieW { w: self }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc1ie(&mut self) -> _Cc1ieW {
                _Cc1ieW { w: self }
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
        }
    }
    # [ doc = "status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4ofR {
            bits: u8,
        }
        impl Cc4ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3ofR {
            bits: u8,
        }
        impl Cc3ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2ofR {
            bits: u8,
        }
        impl Cc2ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ofR {
            bits: u8,
        }
        impl Cc1ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TifR {
            bits: u8,
        }
        impl TifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4ifR {
            bits: u8,
        }
        impl Cc4ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3ifR {
            bits: u8,
        }
        impl Cc3ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2ifR {
            bits: u8,
        }
        impl Cc2ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ifR {
            bits: u8,
        }
        impl Cc1ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UifR {
            bits: u8,
        }
        impl UifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 12 - Capture/Compare 4 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc4of(&self) -> Cc4ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4ofR { bits }
            }
            # [ doc = "Bit 11 - Capture/Compare 3 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc3of(&self) -> Cc3ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3ofR { bits }
            }
            # [ doc = "Bit 10 - Capture/compare 2 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc2of(&self) -> Cc2ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ofR { bits }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc1of(&self) -> Cc1ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ofR { bits }
            }
            # [ doc = "Bit 6 - Trigger interrupt flag" ]
            # [ inline ( always ) ]
            pub fn tif(&self) -> TifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TifR { bits }
            }
            # [ doc = "Bit 4 - Capture/Compare 4 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc4if(&self) -> Cc4ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4ifR { bits }
            }
            # [ doc = "Bit 3 - Capture/Compare 3 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc3if(&self) -> Cc3ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3ifR { bits }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc2if(&self) -> Cc2ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ifR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc1if(&self) -> Cc1ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ifR { bits }
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&self) -> UifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UifR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 12 - Capture/Compare 4 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc4of(&mut self) -> _Cc4ofW {
                _Cc4ofW { w: self }
            }
            # [ doc = "Bit 11 - Capture/Compare 3 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc3of(&mut self) -> _Cc3ofW {
                _Cc3ofW { w: self }
            }
            # [ doc = "Bit 10 - Capture/compare 2 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc2of(&mut self) -> _Cc2ofW {
                _Cc2ofW { w: self }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc1of(&mut self) -> _Cc1ofW {
                _Cc1ofW { w: self }
            }
            # [ doc = "Bit 6 - Trigger interrupt flag" ]
            # [ inline ( always ) ]
            pub fn tif(&mut self) -> _TifW {
                _TifW { w: self }
            }
            # [ doc = "Bit 4 - Capture/Compare 4 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc4if(&mut self) -> _Cc4ifW {
                _Cc4ifW { w: self }
            }
            # [ doc = "Bit 3 - Capture/Compare 3 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc3if(&mut self) -> _Cc3ifW {
                _Cc3ifW { w: self }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc2if(&mut self) -> _Cc2ifW {
                _Cc2ifW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc1if(&mut self) -> _Cc1ifW {
                _Cc1ifW { w: self }
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    # [ doc = "event generation register" ]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    # [ doc = "event generation register" ]
    pub mod egr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 6 - Trigger generation" ]
            # [ inline ( always ) ]
            pub fn tg(&mut self) -> _TgW {
                _TgW { w: self }
            }
            # [ doc = "Bit 4 - Capture/compare 4 generation" ]
            # [ inline ( always ) ]
            pub fn cc4g(&mut self) -> _Cc4gW {
                _Cc4gW { w: self }
            }
            # [ doc = "Bit 3 - Capture/compare 3 generation" ]
            # [ inline ( always ) ]
            pub fn cc3g(&mut self) -> _Cc3gW {
                _Cc3gW { w: self }
            }
            # [ doc = "Bit 2 - Capture/compare 2 generation" ]
            # [ inline ( always ) ]
            pub fn cc2g(&mut self) -> _Cc2gW {
                _Cc2gW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare 1 generation" ]
            # [ inline ( always ) ]
            pub fn cc1g(&mut self) -> _Cc1gW {
                _Cc1gW { w: self }
            }
            # [ doc = "Bit 0 - Update generation" ]
            # [ inline ( always ) ]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register 1 (output mode)" ]
    pub struct Ccmr1Output {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register 1 (output mode)" ]
    pub mod ccmr1_output {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Output {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2ceR {
            bits: u8,
        }
        impl Oc2ceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2mR {
            bits: u8,
        }
        impl Oc2mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2peR {
            bits: u8,
        }
        impl Oc2peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2feR {
            bits: u8,
        }
        impl Oc2feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1ceR {
            bits: u8,
        }
        impl Oc1ceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1mR {
            bits: u8,
        }
        impl Oc1mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1peR {
            bits: u8,
        }
        impl Oc1peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1feR {
            bits: u8,
        }
        impl Oc1feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2ceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1ceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - Output compare 2 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc2ce(&self) -> Oc2ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2ceR { bits }
            }
            # [ doc = "Bits 12:14 - Output compare 2 mode" ]
            # [ inline ( always ) ]
            pub fn oc2m(&self) -> Oc2mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2mR { bits }
            }
            # [ doc = "Bit 11 - Output compare 2 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc2pe(&self) -> Oc2peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2peR { bits }
            }
            # [ doc = "Bit 10 - Output compare 2 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc2fe(&self) -> Oc2feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2feR { bits }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            # [ doc = "Bit 7 - Output compare 1 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc1ce(&self) -> Oc1ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1ceR { bits }
            }
            # [ doc = "Bits 4:6 - Output compare 1 mode" ]
            # [ inline ( always ) ]
            pub fn oc1m(&self) -> Oc1mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1mR { bits }
            }
            # [ doc = "Bit 3 - Output compare 1 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc1pe(&self) -> Oc1peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1peR { bits }
            }
            # [ doc = "Bit 2 - Output compare 1 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc1fe(&self) -> Oc1feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1feR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - Output compare 2 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc2ce(&mut self) -> _Oc2ceW {
                _Oc2ceW { w: self }
            }
            # [ doc = "Bits 12:14 - Output compare 2 mode" ]
            # [ inline ( always ) ]
            pub fn oc2m(&mut self) -> _Oc2mW {
                _Oc2mW { w: self }
            }
            # [ doc = "Bit 11 - Output compare 2 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc2pe(&mut self) -> _Oc2peW {
                _Oc2peW { w: self }
            }
            # [ doc = "Bit 10 - Output compare 2 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc2fe(&mut self) -> _Oc2feW {
                _Oc2feW { w: self }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            # [ doc = "Bit 7 - Output compare 1 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc1ce(&mut self) -> _Oc1ceW {
                _Oc1ceW { w: self }
            }
            # [ doc = "Bits 4:6 - Output compare 1 mode" ]
            # [ inline ( always ) ]
            pub fn oc1m(&mut self) -> _Oc1mW {
                _Oc1mW { w: self }
            }
            # [ doc = "Bit 3 - Output compare 1 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc1pe(&mut self) -> _Oc1peW {
                _Oc1peW { w: self }
            }
            # [ doc = "Bit 2 - Output compare 1 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc1fe(&mut self) -> _Oc1feW {
                _Oc1feW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register 1 (input mode)" ]
    pub struct Ccmr1Input {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register 1 (input mode)" ]
    pub mod ccmr1_input {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Input {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic2fR {
            bits: u8,
        }
        impl Ic2fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic2pscR {
            bits: u8,
        }
        impl Ic2pscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic1fR {
            bits: u8,
        }
        impl Ic1fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic1pscR {
            bits: u8,
        }
        impl Ic1pscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic2fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic2pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2pscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic1fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic1pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1pscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 12:15 - Input capture 2 filter" ]
            # [ inline ( always ) ]
            pub fn ic2f(&self) -> Ic2fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2fR { bits }
            }
            # [ doc = "Bits 10:11 - Input capture 2 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic2psc(&self) -> Ic2pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2pscR { bits }
            }
            # [ doc = "Bits 8:9 - Capture/compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            # [ doc = "Bits 4:7 - Input capture 1 filter" ]
            # [ inline ( always ) ]
            pub fn ic1f(&self) -> Ic1fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1fR { bits }
            }
            # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic1psc(&self) -> Ic1pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1pscR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 12:15 - Input capture 2 filter" ]
            # [ inline ( always ) ]
            pub fn ic2f(&mut self) -> _Ic2fW {
                _Ic2fW { w: self }
            }
            # [ doc = "Bits 10:11 - Input capture 2 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic2psc(&mut self) -> _Ic2pscW {
                _Ic2pscW { w: self }
            }
            # [ doc = "Bits 8:9 - Capture/compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            # [ doc = "Bits 4:7 - Input capture 1 filter" ]
            # [ inline ( always ) ]
            pub fn ic1f(&mut self) -> _Ic1fW {
                _Ic1fW { w: self }
            }
            # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic1psc(&mut self) -> _Ic1pscW {
                _Ic1pscW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register 2 (output mode)" ]
    pub struct Ccmr2Output {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register 2 (output mode)" ]
    pub mod ccmr2_output {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr2Output {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc4ceR {
            bits: u8,
        }
        impl Oc4ceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc4mR {
            bits: u8,
        }
        impl Oc4mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc4peR {
            bits: u8,
        }
        impl Oc4peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc4feR {
            bits: u8,
        }
        impl Oc4feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4sR {
            bits: u8,
        }
        impl Cc4sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc3ceR {
            bits: u8,
        }
        impl Oc3ceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc3mR {
            bits: u8,
        }
        impl Oc3mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc3peR {
            bits: u8,
        }
        impl Oc3peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc3feR {
            bits: u8,
        }
        impl Oc3feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3sR {
            bits: u8,
        }
        impl Cc3sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc4ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4ceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc4mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc4peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc4feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc3ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3ceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc3mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc3peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc3feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - Output compare 4 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc4ce(&self) -> Oc4ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4ceR { bits }
            }
            # [ doc = "Bits 12:14 - Output compare 4 mode" ]
            # [ inline ( always ) ]
            pub fn oc4m(&self) -> Oc4mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4mR { bits }
            }
            # [ doc = "Bit 11 - Output compare 4 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc4pe(&self) -> Oc4peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4peR { bits }
            }
            # [ doc = "Bit 10 - Output compare 4 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc4fe(&self) -> Oc4feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4feR { bits }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 4 selection" ]
            # [ inline ( always ) ]
            pub fn cc4s(&self) -> Cc4sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4sR { bits }
            }
            # [ doc = "Bit 7 - Output compare 3 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc3ce(&self) -> Oc3ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3ceR { bits }
            }
            # [ doc = "Bits 4:6 - Output compare 3 mode" ]
            # [ inline ( always ) ]
            pub fn oc3m(&self) -> Oc3mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3mR { bits }
            }
            # [ doc = "Bit 3 - Output compare 3 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc3pe(&self) -> Oc3peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3peR { bits }
            }
            # [ doc = "Bit 2 - Output compare 3 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc3fe(&self) -> Oc3feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3feR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 3 selection" ]
            # [ inline ( always ) ]
            pub fn cc3s(&self) -> Cc3sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - Output compare 4 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc4ce(&mut self) -> _Oc4ceW {
                _Oc4ceW { w: self }
            }
            # [ doc = "Bits 12:14 - Output compare 4 mode" ]
            # [ inline ( always ) ]
            pub fn oc4m(&mut self) -> _Oc4mW {
                _Oc4mW { w: self }
            }
            # [ doc = "Bit 11 - Output compare 4 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc4pe(&mut self) -> _Oc4peW {
                _Oc4peW { w: self }
            }
            # [ doc = "Bit 10 - Output compare 4 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc4fe(&mut self) -> _Oc4feW {
                _Oc4feW { w: self }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 4 selection" ]
            # [ inline ( always ) ]
            pub fn cc4s(&mut self) -> _Cc4sW {
                _Cc4sW { w: self }
            }
            # [ doc = "Bit 7 - Output compare 3 clear enable" ]
            # [ inline ( always ) ]
            pub fn oc3ce(&mut self) -> _Oc3ceW {
                _Oc3ceW { w: self }
            }
            # [ doc = "Bits 4:6 - Output compare 3 mode" ]
            # [ inline ( always ) ]
            pub fn oc3m(&mut self) -> _Oc3mW {
                _Oc3mW { w: self }
            }
            # [ doc = "Bit 3 - Output compare 3 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc3pe(&mut self) -> _Oc3peW {
                _Oc3peW { w: self }
            }
            # [ doc = "Bit 2 - Output compare 3 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc3fe(&mut self) -> _Oc3feW {
                _Oc3feW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 3 selection" ]
            # [ inline ( always ) ]
            pub fn cc3s(&mut self) -> _Cc3sW {
                _Cc3sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register 2 (input mode)" ]
    pub struct Ccmr2Input {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register 2 (input mode)" ]
    pub mod ccmr2_input {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr2Input {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic4fR {
            bits: u8,
        }
        impl Ic4fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic4pscR {
            bits: u8,
        }
        impl Ic4pscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4sR {
            bits: u8,
        }
        impl Cc4sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic3fR {
            bits: u8,
        }
        impl Ic3fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic3pscR {
            bits: u8,
        }
        impl Ic3pscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3sR {
            bits: u8,
        }
        impl Cc3sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic4fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic4fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic4pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic4pscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic3fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic3fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic3pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic3pscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 12:15 - Input capture 4 filter" ]
            # [ inline ( always ) ]
            pub fn ic4f(&self) -> Ic4fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic4fR { bits }
            }
            # [ doc = "Bits 10:11 - Input capture 4 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic4psc(&self) -> Ic4pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic4pscR { bits }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 4 selection" ]
            # [ inline ( always ) ]
            pub fn cc4s(&self) -> Cc4sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4sR { bits }
            }
            # [ doc = "Bits 4:7 - Input capture 3 filter" ]
            # [ inline ( always ) ]
            pub fn ic3f(&self) -> Ic3fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic3fR { bits }
            }
            # [ doc = "Bits 2:3 - Input capture 3 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic3psc(&self) -> Ic3pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic3pscR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 3 selection" ]
            # [ inline ( always ) ]
            pub fn cc3s(&self) -> Cc3sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 12:15 - Input capture 4 filter" ]
            # [ inline ( always ) ]
            pub fn ic4f(&mut self) -> _Ic4fW {
                _Ic4fW { w: self }
            }
            # [ doc = "Bits 10:11 - Input capture 4 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic4psc(&mut self) -> _Ic4pscW {
                _Ic4pscW { w: self }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 4 selection" ]
            # [ inline ( always ) ]
            pub fn cc4s(&mut self) -> _Cc4sW {
                _Cc4sW { w: self }
            }
            # [ doc = "Bits 4:7 - Input capture 3 filter" ]
            # [ inline ( always ) ]
            pub fn ic3f(&mut self) -> _Ic3fW {
                _Ic3fW { w: self }
            }
            # [ doc = "Bits 2:3 - Input capture 3 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic3psc(&mut self) -> _Ic3pscW {
                _Ic3pscW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 3 selection" ]
            # [ inline ( always ) ]
            pub fn cc3s(&mut self) -> _Cc3sW {
                _Cc3sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare enable register" ]
    pub struct Ccer {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare enable register" ]
    pub mod ccer {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccer {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4pR {
            bits: u8,
        }
        impl Cc4pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc4eR {
            bits: u8,
        }
        impl Cc4eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3pR {
            bits: u8,
        }
        impl Cc3pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc3eR {
            bits: u8,
        }
        impl Cc3eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2pR {
            bits: u8,
        }
        impl Cc2pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2eR {
            bits: u8,
        }
        impl Cc2eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1pR {
            bits: u8,
        }
        impl Cc1pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1eR {
            bits: u8,
        }
        impl Cc1eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc4eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc3eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 13 - Capture/Compare 3 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc4p(&self) -> Cc4pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4pR { bits }
            }
            # [ doc = "Bit 12 - Capture/Compare 4 output enable" ]
            # [ inline ( always ) ]
            pub fn cc4e(&self) -> Cc4eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4eR { bits }
            }
            # [ doc = "Bit 9 - Capture/Compare 3 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc3p(&self) -> Cc3pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3pR { bits }
            }
            # [ doc = "Bit 8 - Capture/Compare 3 output enable" ]
            # [ inline ( always ) ]
            pub fn cc3e(&self) -> Cc3eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3eR { bits }
            }
            # [ doc = "Bit 5 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2p(&self) -> Cc2pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2pR { bits }
            }
            # [ doc = "Bit 4 - Capture/Compare 2 output enable" ]
            # [ inline ( always ) ]
            pub fn cc2e(&self) -> Cc2eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2eR { bits }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1p(&self) -> Cc1pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1pR { bits }
            }
            # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
            # [ inline ( always ) ]
            pub fn cc1e(&self) -> Cc1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1eR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 13 - Capture/Compare 3 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc4p(&mut self) -> _Cc4pW {
                _Cc4pW { w: self }
            }
            # [ doc = "Bit 12 - Capture/Compare 4 output enable" ]
            # [ inline ( always ) ]
            pub fn cc4e(&mut self) -> _Cc4eW {
                _Cc4eW { w: self }
            }
            # [ doc = "Bit 9 - Capture/Compare 3 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc3p(&mut self) -> _Cc3pW {
                _Cc3pW { w: self }
            }
            # [ doc = "Bit 8 - Capture/Compare 3 output enable" ]
            # [ inline ( always ) ]
            pub fn cc3e(&mut self) -> _Cc3eW {
                _Cc3eW { w: self }
            }
            # [ doc = "Bit 5 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2p(&mut self) -> _Cc2pW {
                _Cc2pW { w: self }
            }
            # [ doc = "Bit 4 - Capture/Compare 2 output enable" ]
            # [ inline ( always ) ]
            pub fn cc2e(&mut self) -> _Cc2eW {
                _Cc2eW { w: self }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1p(&mut self) -> _Cc1pW {
                _Cc1pW { w: self }
            }
            # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
            # [ inline ( always ) ]
            pub fn cc1e(&mut self) -> _Cc1eW {
                _Cc1eW { w: self }
            }
        }
    }
    # [ doc = "counter" ]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    # [ doc = "counter" ]
    pub mod cnt {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&mut self) -> _CntW {
                _CntW { w: self }
            }
        }
    }
    # [ doc = "prescaler" ]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    # [ doc = "prescaler" ]
    pub mod psc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    # [ doc = "auto-reload register" ]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    # [ doc = "auto-reload register" ]
    pub mod arr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArrR {
            bits: u16,
        }
        impl ArrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&self) -> ArrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&mut self) -> _ArrW {
                _ArrW { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 1" ]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 1" ]
    pub mod ccr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr1R {
            bits: u16,
        }
        impl Ccr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
            # [ inline ( always ) ]
            pub fn ccr1(&self) -> Ccr1R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
            # [ inline ( always ) ]
            pub fn ccr1(&mut self) -> _Ccr1W {
                _Ccr1W { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 2" ]
    pub struct Ccr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 2" ]
    pub mod ccr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr2R {
            bits: u16,
        }
        impl Ccr2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare 2 value" ]
            # [ inline ( always ) ]
            pub fn ccr2(&self) -> Ccr2R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr2R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare 2 value" ]
            # [ inline ( always ) ]
            pub fn ccr2(&mut self) -> _Ccr2W {
                _Ccr2W { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 3" ]
    pub struct Ccr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 3" ]
    pub mod ccr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr3R {
            bits: u16,
        }
        impl Ccr3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare value" ]
            # [ inline ( always ) ]
            pub fn ccr3(&self) -> Ccr3R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare value" ]
            # [ inline ( always ) ]
            pub fn ccr3(&mut self) -> _Ccr3W {
                _Ccr3W { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 4" ]
    pub struct Ccr4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 4" ]
    pub mod ccr4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr4R {
            bits: u16,
        }
        impl Ccr4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare value" ]
            # [ inline ( always ) ]
            pub fn ccr4(&self) -> Ccr4R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr4R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare value" ]
            # [ inline ( always ) ]
            pub fn ccr4(&mut self) -> _Ccr4W {
                _Ccr4W { w: self }
            }
        }
    }
    # [ doc = "DMA control register" ]
    pub struct Dcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA control register" ]
    pub mod dcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DblR {
            bits: u8,
        }
        impl DblR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbaR {
            bits: u8,
        }
        impl DbaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DblW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DblW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 8:12 - DMA burst length" ]
            # [ inline ( always ) ]
            pub fn dbl(&self) -> DblR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DblR { bits }
            }
            # [ doc = "Bits 0:4 - DMA base address" ]
            # [ inline ( always ) ]
            pub fn dba(&self) -> DbaR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 8:12 - DMA burst length" ]
            # [ inline ( always ) ]
            pub fn dbl(&mut self) -> _DblW {
                _DblW { w: self }
            }
            # [ doc = "Bits 0:4 - DMA base address" ]
            # [ inline ( always ) ]
            pub fn dba(&mut self) -> _DbaW {
                _DbaW { w: self }
            }
        }
    }
    # [ doc = "DMA address for full transfer" ]
    pub struct Dmar {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA address for full transfer" ]
    pub mod dmar {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dmar {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmabR {
            bits: u16,
        }
        impl DmabR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmabW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmabW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - DMA register for burst accesses" ]
            # [ inline ( always ) ]
            pub fn dmab(&self) -> DmabR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DmabR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - DMA register for burst accesses" ]
            # [ inline ( always ) ]
            pub fn dmab(&mut self) -> _DmabW {
                _DmabW { w: self }
            }
        }
    }
}
# [ doc = "General purpose timer" ]
pub struct Tim2 {
    register_block: tim2::RegisterBlock,
}
impl Deref for Tim2 {
    type Target = tim2::RegisterBlock;
    fn deref(&self) -> &tim2::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "TIM3" ]
pub const TIM3: Peripheral<Tim3> = unsafe { Peripheral::new(1073742848) };
# [ doc = r" Register block" ]
pub struct Tim3 {
    register_block: tim2::RegisterBlock,
}
impl Deref for Tim3 {
    type Target = tim2::RegisterBlock;
    fn deref(&self) -> &tim2::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "TIM4" ]
pub const TIM4: Peripheral<Tim4> = unsafe { Peripheral::new(1073743872) };
# [ doc = r" Register block" ]
pub struct Tim4 {
    register_block: tim2::RegisterBlock,
}
impl Deref for Tim4 {
    type Target = tim2::RegisterBlock;
    fn deref(&self) -> &tim2::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "TIM5" ]
pub const TIM5: Peripheral<Tim5> = unsafe { Peripheral::new(1073744896) };
# [ doc = r" Register block" ]
pub struct Tim5 {
    register_block: tim2::RegisterBlock,
}
impl Deref for Tim5 {
    type Target = tim2::RegisterBlock;
    fn deref(&self) -> &tim2::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "General purpose timer" ]
pub const TIM12: Peripheral<Tim12> = unsafe { Peripheral::new(1073747968) };
# [ doc = "General purpose timer" ]
pub mod tim12 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - control register 1" ]
        pub cr1: Cr1,
        # [ doc = "0x04 - control register 2" ]
        pub cr2: Cr2,
        # [ doc = "0x08 - slave mode control register" ]
        pub smcr: Smcr,
        # [ doc = "0x0c - DMA/Interrupt enable register" ]
        pub dier: Dier,
        # [ doc = "0x10 - status register" ]
        pub sr: Sr,
        # [ doc = "0x14 - event generation register" ]
        pub egr: Egr,
        # [ doc = "0x18 - capture/compare mode register 1 (output mode)" ]
        pub ccmr1_output: Ccmr1Output,
        _reserved0: [u8; 4usize],
        # [ doc = "0x20 - capture/compare enable register" ]
        pub ccer: Ccer,
        # [ doc = "0x24 - counter" ]
        pub cnt: Cnt,
        # [ doc = "0x28 - prescaler" ]
        pub psc: Psc,
        # [ doc = "0x2c - auto-reload register" ]
        pub arr: Arr,
        _reserved1: [u8; 4usize],
        # [ doc = "0x34 - capture/compare register 1" ]
        pub ccr1: Ccr1,
        # [ doc = "0x38 - capture/compare register 2" ]
        pub ccr2: Ccr2,
    }
    # [ doc = "control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CkdR {
            bits: u8,
        }
        impl CkdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OpmR {
            bits: u8,
        }
        impl OpmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CenR {
            bits: u8,
        }
        impl CenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CkdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CkdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OpmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 8:9 - Clock division" ]
            # [ inline ( always ) ]
            pub fn ckd(&self) -> CkdR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CkdR { bits }
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            # [ doc = "Bit 3 - One-pulse mode" ]
            # [ inline ( always ) ]
            pub fn opm(&self) -> OpmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpmR { bits }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&self) -> CenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 8:9 - Clock division" ]
            # [ inline ( always ) ]
            pub fn ckd(&mut self) -> _CkdW {
                _CkdW { w: self }
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            # [ doc = "Bit 3 - One-pulse mode" ]
            # [ inline ( always ) ]
            pub fn opm(&mut self) -> _OpmW {
                _OpmW { w: self }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    # [ doc = "control register 2" ]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 2" ]
    pub mod cr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MmsR {
            bits: u8,
        }
        impl MmsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MmsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 4:6 - Master mode selection" ]
            # [ inline ( always ) ]
            pub fn mms(&self) -> MmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MmsR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 4:6 - Master mode selection" ]
            # [ inline ( always ) ]
            pub fn mms(&mut self) -> _MmsW {
                _MmsW { w: self }
            }
        }
    }
    # [ doc = "slave mode control register" ]
    pub struct Smcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "slave mode control register" ]
    pub mod smcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Smcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MsmR {
            bits: u8,
        }
        impl MsmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TsR {
            bits: u8,
        }
        impl TsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SmsR {
            bits: u8,
        }
        impl SmsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MsmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 7 - Master/Slave mode" ]
            # [ inline ( always ) ]
            pub fn msm(&self) -> MsmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsmR { bits }
            }
            # [ doc = "Bits 4:6 - Trigger selection" ]
            # [ inline ( always ) ]
            pub fn ts(&self) -> TsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsR { bits }
            }
            # [ doc = "Bits 0:2 - Slave mode selection" ]
            # [ inline ( always ) ]
            pub fn sms(&self) -> SmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmsR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 7 - Master/Slave mode" ]
            # [ inline ( always ) ]
            pub fn msm(&mut self) -> _MsmW {
                _MsmW { w: self }
            }
            # [ doc = "Bits 4:6 - Trigger selection" ]
            # [ inline ( always ) ]
            pub fn ts(&mut self) -> _TsW {
                _TsW { w: self }
            }
            # [ doc = "Bits 0:2 - Slave mode selection" ]
            # [ inline ( always ) ]
            pub fn sms(&mut self) -> _SmsW {
                _SmsW { w: self }
            }
        }
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub mod dier {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TieR {
            bits: u8,
        }
        impl TieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2ieR {
            bits: u8,
        }
        impl Cc2ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ieR {
            bits: u8,
        }
        impl Cc1ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 6 - Trigger interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tie(&self) -> TieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TieR { bits }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc2ie(&self) -> Cc2ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ieR { bits }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc1ie(&self) -> Cc1ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ieR { bits }
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 6 - Trigger interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tie(&mut self) -> _TieW {
                _TieW { w: self }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc2ie(&mut self) -> _Cc2ieW {
                _Cc2ieW { w: self }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc1ie(&mut self) -> _Cc1ieW {
                _Cc1ieW { w: self }
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
        }
    }
    # [ doc = "status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2ofR {
            bits: u8,
        }
        impl Cc2ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ofR {
            bits: u8,
        }
        impl Cc1ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TifR {
            bits: u8,
        }
        impl TifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2ifR {
            bits: u8,
        }
        impl Cc2ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ifR {
            bits: u8,
        }
        impl Cc1ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UifR {
            bits: u8,
        }
        impl UifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 10 - Capture/compare 2 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc2of(&self) -> Cc2ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ofR { bits }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc1of(&self) -> Cc1ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ofR { bits }
            }
            # [ doc = "Bit 6 - Trigger interrupt flag" ]
            # [ inline ( always ) ]
            pub fn tif(&self) -> TifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TifR { bits }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc2if(&self) -> Cc2ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ifR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc1if(&self) -> Cc1ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ifR { bits }
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&self) -> UifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UifR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 10 - Capture/compare 2 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc2of(&mut self) -> _Cc2ofW {
                _Cc2ofW { w: self }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc1of(&mut self) -> _Cc1ofW {
                _Cc1ofW { w: self }
            }
            # [ doc = "Bit 6 - Trigger interrupt flag" ]
            # [ inline ( always ) ]
            pub fn tif(&mut self) -> _TifW {
                _TifW { w: self }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc2if(&mut self) -> _Cc2ifW {
                _Cc2ifW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc1if(&mut self) -> _Cc1ifW {
                _Cc1ifW { w: self }
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    # [ doc = "event generation register" ]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    # [ doc = "event generation register" ]
    pub mod egr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 6 - Trigger generation" ]
            # [ inline ( always ) ]
            pub fn tg(&mut self) -> _TgW {
                _TgW { w: self }
            }
            # [ doc = "Bit 2 - Capture/compare 2 generation" ]
            # [ inline ( always ) ]
            pub fn cc2g(&mut self) -> _Cc2gW {
                _Cc2gW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare 1 generation" ]
            # [ inline ( always ) ]
            pub fn cc1g(&mut self) -> _Cc1gW {
                _Cc1gW { w: self }
            }
            # [ doc = "Bit 0 - Update generation" ]
            # [ inline ( always ) ]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register 1 (output mode)" ]
    pub struct Ccmr1Output {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register 1 (output mode)" ]
    pub mod ccmr1_output {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Output {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2mR {
            bits: u8,
        }
        impl Oc2mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2peR {
            bits: u8,
        }
        impl Oc2peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2feR {
            bits: u8,
        }
        impl Oc2feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1mR {
            bits: u8,
        }
        impl Oc1mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1peR {
            bits: u8,
        }
        impl Oc1peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1feR {
            bits: u8,
        }
        impl Oc1feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 12:14 - Output Compare 2 mode" ]
            # [ inline ( always ) ]
            pub fn oc2m(&self) -> Oc2mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2mR { bits }
            }
            # [ doc = "Bit 11 - Output Compare 2 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc2pe(&self) -> Oc2peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2peR { bits }
            }
            # [ doc = "Bit 10 - Output Compare 2 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc2fe(&self) -> Oc2feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2feR { bits }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            # [ doc = "Bits 4:6 - Output Compare 1 mode" ]
            # [ inline ( always ) ]
            pub fn oc1m(&self) -> Oc1mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1mR { bits }
            }
            # [ doc = "Bit 3 - Output Compare 1 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc1pe(&self) -> Oc1peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1peR { bits }
            }
            # [ doc = "Bit 2 - Output Compare 1 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc1fe(&self) -> Oc1feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1feR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 12:14 - Output Compare 2 mode" ]
            # [ inline ( always ) ]
            pub fn oc2m(&mut self) -> _Oc2mW {
                _Oc2mW { w: self }
            }
            # [ doc = "Bit 11 - Output Compare 2 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc2pe(&mut self) -> _Oc2peW {
                _Oc2peW { w: self }
            }
            # [ doc = "Bit 10 - Output Compare 2 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc2fe(&mut self) -> _Oc2feW {
                _Oc2feW { w: self }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            # [ doc = "Bits 4:6 - Output Compare 1 mode" ]
            # [ inline ( always ) ]
            pub fn oc1m(&mut self) -> _Oc1mW {
                _Oc1mW { w: self }
            }
            # [ doc = "Bit 3 - Output Compare 1 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc1pe(&mut self) -> _Oc1peW {
                _Oc1peW { w: self }
            }
            # [ doc = "Bit 2 - Output Compare 1 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc1fe(&mut self) -> _Oc1feW {
                _Oc1feW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register 1 (input mode)" ]
    pub struct Ccmr1Input {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register 1 (input mode)" ]
    pub mod ccmr1_input {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Input {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic2fR {
            bits: u8,
        }
        impl Ic2fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic2pscR {
            bits: u8,
        }
        impl Ic2pscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic1fR {
            bits: u8,
        }
        impl Ic1fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic1pscR {
            bits: u8,
        }
        impl Ic1pscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic2fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic2pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2pscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic1fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic1pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1pscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 12:14 - Input capture 2 filter" ]
            # [ inline ( always ) ]
            pub fn ic2f(&self) -> Ic2fR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2fR { bits }
            }
            # [ doc = "Bits 10:11 - Input capture 2 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic2psc(&self) -> Ic2pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2pscR { bits }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            # [ doc = "Bits 4:7 - Input capture 1 filter" ]
            # [ inline ( always ) ]
            pub fn ic1f(&self) -> Ic1fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1fR { bits }
            }
            # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic1psc(&self) -> Ic1pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1pscR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 12:14 - Input capture 2 filter" ]
            # [ inline ( always ) ]
            pub fn ic2f(&mut self) -> _Ic2fW {
                _Ic2fW { w: self }
            }
            # [ doc = "Bits 10:11 - Input capture 2 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic2psc(&mut self) -> _Ic2pscW {
                _Ic2pscW { w: self }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            # [ doc = "Bits 4:7 - Input capture 1 filter" ]
            # [ inline ( always ) ]
            pub fn ic1f(&mut self) -> _Ic1fW {
                _Ic1fW { w: self }
            }
            # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic1psc(&mut self) -> _Ic1pscW {
                _Ic1pscW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare enable register" ]
    pub struct Ccer {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare enable register" ]
    pub mod ccer {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccer {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2npR {
            bits: u8,
        }
        impl Cc2npR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2pR {
            bits: u8,
        }
        impl Cc2pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2eR {
            bits: u8,
        }
        impl Cc2eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1npR {
            bits: u8,
        }
        impl Cc1npR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1pR {
            bits: u8,
        }
        impl Cc1pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1eR {
            bits: u8,
        }
        impl Cc1eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2npW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1npW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 7 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2np(&self) -> Cc2npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2npR { bits }
            }
            # [ doc = "Bit 5 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2p(&self) -> Cc2pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2pR { bits }
            }
            # [ doc = "Bit 4 - Capture/Compare 2 output enable" ]
            # [ inline ( always ) ]
            pub fn cc2e(&self) -> Cc2eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2eR { bits }
            }
            # [ doc = "Bit 3 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1np(&self) -> Cc1npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1npR { bits }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1p(&self) -> Cc1pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1pR { bits }
            }
            # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
            # [ inline ( always ) ]
            pub fn cc1e(&self) -> Cc1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1eR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 7 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2np(&mut self) -> _Cc2npW {
                _Cc2npW { w: self }
            }
            # [ doc = "Bit 5 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2p(&mut self) -> _Cc2pW {
                _Cc2pW { w: self }
            }
            # [ doc = "Bit 4 - Capture/Compare 2 output enable" ]
            # [ inline ( always ) ]
            pub fn cc2e(&mut self) -> _Cc2eW {
                _Cc2eW { w: self }
            }
            # [ doc = "Bit 3 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1np(&mut self) -> _Cc1npW {
                _Cc1npW { w: self }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1p(&mut self) -> _Cc1pW {
                _Cc1pW { w: self }
            }
            # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
            # [ inline ( always ) ]
            pub fn cc1e(&mut self) -> _Cc1eW {
                _Cc1eW { w: self }
            }
        }
    }
    # [ doc = "counter" ]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    # [ doc = "counter" ]
    pub mod cnt {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&mut self) -> _CntW {
                _CntW { w: self }
            }
        }
    }
    # [ doc = "prescaler" ]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    # [ doc = "prescaler" ]
    pub mod psc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    # [ doc = "auto-reload register" ]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    # [ doc = "auto-reload register" ]
    pub mod arr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArrR {
            bits: u16,
        }
        impl ArrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&self) -> ArrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&mut self) -> _ArrW {
                _ArrW { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 1" ]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 1" ]
    pub mod ccr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr1R {
            bits: u16,
        }
        impl Ccr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
            # [ inline ( always ) ]
            pub fn ccr1(&self) -> Ccr1R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
            # [ inline ( always ) ]
            pub fn ccr1(&mut self) -> _Ccr1W {
                _Ccr1W { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 2" ]
    pub struct Ccr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 2" ]
    pub mod ccr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr2R {
            bits: u16,
        }
        impl Ccr2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare 2 value" ]
            # [ inline ( always ) ]
            pub fn ccr2(&self) -> Ccr2R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr2R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare 2 value" ]
            # [ inline ( always ) ]
            pub fn ccr2(&mut self) -> _Ccr2W {
                _Ccr2W { w: self }
            }
        }
    }
}
# [ doc = "General purpose timer" ]
pub struct Tim12 {
    register_block: tim12::RegisterBlock,
}
impl Deref for Tim12 {
    type Target = tim12::RegisterBlock;
    fn deref(&self) -> &tim12::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "General purpose timer" ]
pub const TIM13: Peripheral<Tim13> = unsafe { Peripheral::new(1073748992) };
# [ doc = "General purpose timer" ]
pub mod tim13 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - control register 1" ]
        pub cr1: Cr1,
        _reserved0: [u8; 8usize],
        # [ doc = "0x0c - DMA/Interrupt enable register" ]
        pub dier: Dier,
        # [ doc = "0x10 - status register" ]
        pub sr: Sr,
        # [ doc = "0x14 - event generation register" ]
        pub egr: Egr,
        # [ doc = "0x18 - capture/compare mode register (output mode)" ]
        pub ccmr1_output: Ccmr1Output,
        _reserved1: [u8; 4usize],
        # [ doc = "0x20 - capture/compare enable register" ]
        pub ccer: Ccer,
        # [ doc = "0x24 - counter" ]
        pub cnt: Cnt,
        # [ doc = "0x28 - prescaler" ]
        pub psc: Psc,
        # [ doc = "0x2c - auto-reload register" ]
        pub arr: Arr,
        _reserved2: [u8; 4usize],
        # [ doc = "0x34 - capture/compare register 1" ]
        pub ccr1: Ccr1,
    }
    # [ doc = "control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CkdR {
            bits: u8,
        }
        impl CkdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CenR {
            bits: u8,
        }
        impl CenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CkdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CkdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 8:9 - Clock division" ]
            # [ inline ( always ) ]
            pub fn ckd(&self) -> CkdR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CkdR { bits }
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&self) -> CenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 8:9 - Clock division" ]
            # [ inline ( always ) ]
            pub fn ckd(&mut self) -> _CkdW {
                _CkdW { w: self }
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub mod dier {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ieR {
            bits: u8,
        }
        impl Cc1ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc1ie(&self) -> Cc1ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ieR { bits }
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc1ie(&mut self) -> _Cc1ieW {
                _Cc1ieW { w: self }
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
        }
    }
    # [ doc = "status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ofR {
            bits: u8,
        }
        impl Cc1ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ifR {
            bits: u8,
        }
        impl Cc1ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UifR {
            bits: u8,
        }
        impl UifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc1of(&self) -> Cc1ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ofR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc1if(&self) -> Cc1ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ifR { bits }
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&self) -> UifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UifR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc1of(&mut self) -> _Cc1ofW {
                _Cc1ofW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc1if(&mut self) -> _Cc1ifW {
                _Cc1ifW { w: self }
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    # [ doc = "event generation register" ]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    # [ doc = "event generation register" ]
    pub mod egr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 1 - Capture/compare 1 generation" ]
            # [ inline ( always ) ]
            pub fn cc1g(&mut self) -> _Cc1gW {
                _Cc1gW { w: self }
            }
            # [ doc = "Bit 0 - Update generation" ]
            # [ inline ( always ) ]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register (output mode)" ]
    pub struct Ccmr1Output {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register (output mode)" ]
    pub mod ccmr1_output {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Output {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1feR {
            bits: u8,
        }
        impl Oc1feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1peR {
            bits: u8,
        }
        impl Oc1peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1mR {
            bits: u8,
        }
        impl Oc1mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
            # [ doc = "Bit 2 - Output compare 1 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc1fe(&self) -> Oc1feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1feR { bits }
            }
            # [ doc = "Bit 3 - Output Compare 1 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc1pe(&self) -> Oc1peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1peR { bits }
            }
            # [ doc = "Bits 4:6 - Output Compare 1 mode" ]
            # [ inline ( always ) ]
            pub fn oc1m(&self) -> Oc1mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1mR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
            # [ doc = "Bit 2 - Output compare 1 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc1fe(&mut self) -> _Oc1feW {
                _Oc1feW { w: self }
            }
            # [ doc = "Bit 3 - Output Compare 1 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc1pe(&mut self) -> _Oc1peW {
                _Oc1peW { w: self }
            }
            # [ doc = "Bits 4:6 - Output Compare 1 mode" ]
            # [ inline ( always ) ]
            pub fn oc1m(&mut self) -> _Oc1mW {
                _Oc1mW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register (input mode)" ]
    pub struct Ccmr1Input {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register (input mode)" ]
    pub mod ccmr1_input {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Input {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic1fR {
            bits: u8,
        }
        impl Ic1fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic1pscR {
            bits: u8,
        }
        impl Ic1pscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic1fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic1pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1pscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 4:7 - Input capture 1 filter" ]
            # [ inline ( always ) ]
            pub fn ic1f(&self) -> Ic1fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1fR { bits }
            }
            # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic1psc(&self) -> Ic1pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1pscR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 4:7 - Input capture 1 filter" ]
            # [ inline ( always ) ]
            pub fn ic1f(&mut self) -> _Ic1fW {
                _Ic1fW { w: self }
            }
            # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic1psc(&mut self) -> _Ic1pscW {
                _Ic1pscW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare enable register" ]
    pub struct Ccer {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare enable register" ]
    pub mod ccer {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccer {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1npR {
            bits: u8,
        }
        impl Cc1npR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1pR {
            bits: u8,
        }
        impl Cc1pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1eR {
            bits: u8,
        }
        impl Cc1eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1npW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 3 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1np(&self) -> Cc1npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1npR { bits }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1p(&self) -> Cc1pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1pR { bits }
            }
            # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
            # [ inline ( always ) ]
            pub fn cc1e(&self) -> Cc1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1eR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 3 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1np(&mut self) -> _Cc1npW {
                _Cc1npW { w: self }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1p(&mut self) -> _Cc1pW {
                _Cc1pW { w: self }
            }
            # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
            # [ inline ( always ) ]
            pub fn cc1e(&mut self) -> _Cc1eW {
                _Cc1eW { w: self }
            }
        }
    }
    # [ doc = "counter" ]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    # [ doc = "counter" ]
    pub mod cnt {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&mut self) -> _CntW {
                _CntW { w: self }
            }
        }
    }
    # [ doc = "prescaler" ]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    # [ doc = "prescaler" ]
    pub mod psc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    # [ doc = "auto-reload register" ]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    # [ doc = "auto-reload register" ]
    pub mod arr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArrR {
            bits: u16,
        }
        impl ArrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&self) -> ArrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&mut self) -> _ArrW {
                _ArrW { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 1" ]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 1" ]
    pub mod ccr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr1R {
            bits: u16,
        }
        impl Ccr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
            # [ inline ( always ) ]
            pub fn ccr1(&self) -> Ccr1R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
            # [ inline ( always ) ]
            pub fn ccr1(&mut self) -> _Ccr1W {
                _Ccr1W { w: self }
            }
        }
    }
}
# [ doc = "General purpose timer" ]
pub struct Tim13 {
    register_block: tim13::RegisterBlock,
}
impl Deref for Tim13 {
    type Target = tim13::RegisterBlock;
    fn deref(&self) -> &tim13::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "TIM14" ]
pub const TIM14: Peripheral<Tim14> = unsafe { Peripheral::new(1073750016) };
# [ doc = r" Register block" ]
pub struct Tim14 {
    register_block: tim13::RegisterBlock,
}
impl Deref for Tim14 {
    type Target = tim13::RegisterBlock;
    fn deref(&self) -> &tim13::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Basic timer" ]
pub const TIM6: Peripheral<Tim6> = unsafe { Peripheral::new(1073745920) };
# [ doc = "Basic timer" ]
pub mod tim6 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - control register 1" ]
        pub cr1: Cr1,
        # [ doc = "0x04 - control register 2" ]
        pub cr2: Cr2,
        _reserved0: [u8; 4usize],
        # [ doc = "0x0c - DMA/Interrupt enable register" ]
        pub dier: Dier,
        # [ doc = "0x10 - status register" ]
        pub sr: Sr,
        # [ doc = "0x14 - event generation register" ]
        pub egr: Egr,
        _reserved1: [u8; 12usize],
        # [ doc = "0x24 - counter" ]
        pub cnt: Cnt,
        # [ doc = "0x28 - prescaler" ]
        pub psc: Psc,
        # [ doc = "0x2c - auto-reload register" ]
        pub arr: Arr,
    }
    # [ doc = "control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `OPM`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OpmR {
            # [ doc = "Counter is not stopped at update event" ]
            Continuous,
            # [ doc = "Counter stops counting at the next update event (clearing the CEN bit)" ]
            OnePulse,
        }
        impl OpmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OpmR::Continuous => 0,
                    OpmR::OnePulse => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OpmR {
                match bits {
                    0 => OpmR::Continuous,
                    1 => OpmR::OnePulse,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Continuous`" ]
            # [ inline ( always ) ]
            pub fn is_continuous(&self) -> bool {
                *self == OpmR::Continuous
            }
            # [ doc = "Checks if the value of the field is `OnePulse`" ]
            # [ inline ( always ) ]
            pub fn is_one_pulse(&self) -> bool {
                *self == OpmR::OnePulse
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `CEN`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CenR {
            # [ doc = "Counter disabled" ]
            Disabled,
            # [ doc = "Counter enabled" ]
            Enabled,
        }
        impl CenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CenR::Disabled => 0,
                    CenR::Enabled => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CenR {
                match bits {
                    0 => CenR::Disabled,
                    1 => CenR::Enabled,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Disabled`" ]
            # [ inline ( always ) ]
            pub fn is_disabled(&self) -> bool {
                *self == CenR::Disabled
            }
            # [ doc = "Checks if the value of the field is `Enabled`" ]
            # [ inline ( always ) ]
            pub fn is_enabled(&self) -> bool {
                *self == CenR::Enabled
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OPM`" ]
        pub enum OpmW {
            # [ doc = "Counter is not stopped at update event" ]
            Continuous,
            # [ doc = "Counter stops counting at the next update event (clearing the CEN bit)" ]
            OnePulse,
        }
        impl OpmW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OpmW::Continuous => 0,
                    OpmW::OnePulse => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OpmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpmW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OpmW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Counter is not stopped at update event" ]
            # [ inline ( always ) ]
            pub fn continuous(self) -> &'a mut W {
                self.variant(OpmW::Continuous)
            }
            # [ doc = "Counter stops counting at the next update event (clearing the CEN bit)" ]
            # [ inline ( always ) ]
            pub fn one_pulse(self) -> &'a mut W {
                self.variant(OpmW::OnePulse)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CEN`" ]
        pub enum CenW {
            # [ doc = "Counter disabled" ]
            Disabled,
            # [ doc = "Counter enabled" ]
            Enabled,
        }
        impl CenW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CenW::Disabled => 0,
                    CenW::Enabled => 1,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Counter disabled" ]
            # [ inline ( always ) ]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CenW::Disabled)
            }
            # [ doc = "Counter enabled" ]
            # [ inline ( always ) ]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CenW::Enabled)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            # [ doc = "Bit 3 - One-pulse mode" ]
            # [ inline ( always ) ]
            pub fn opm(&self) -> OpmR {
                OpmR::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 3;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&self) -> CenR {
                CenR::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            # [ doc = "Bit 3 - One-pulse mode" ]
            # [ inline ( always ) ]
            pub fn opm(&mut self) -> _OpmW {
                _OpmW { w: self }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    # [ doc = "control register 2" ]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 2" ]
    pub mod cr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MmsR {
            bits: u8,
        }
        impl MmsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MmsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 4:6 - Master mode selection" ]
            # [ inline ( always ) ]
            pub fn mms(&self) -> MmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MmsR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 4:6 - Master mode selection" ]
            # [ inline ( always ) ]
            pub fn mms(&mut self) -> _MmsW {
                _MmsW { w: self }
            }
        }
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub mod dier {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UdeR {
            bits: u8,
        }
        impl UdeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 8 - Update DMA request enable" ]
            # [ inline ( always ) ]
            pub fn ude(&self) -> UdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdeR { bits }
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 8 - Update DMA request enable" ]
            # [ inline ( always ) ]
            pub fn ude(&mut self) -> _UdeW {
                _UdeW { w: self }
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
        }
    }
    # [ doc = "status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `UIF`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UifR {
            # [ doc = "No update occurred" ]
            NoUpdate,
            # [ doc = "Update interrupt pending" ]
            Pending,
        }
        impl UifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UifR::NoUpdate => 0,
                    UifR::Pending => 1,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UifR {
                match bits {
                    0 => UifR::NoUpdate,
                    1 => UifR::Pending,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `NoUpdate`" ]
            # [ inline ( always ) ]
            pub fn is_no_update(&self) -> bool {
                *self == UifR::NoUpdate
            }
            # [ doc = "Checks if the value of the field is `Pending`" ]
            # [ inline ( always ) ]
            pub fn is_pending(&self) -> bool {
                *self == UifR::Pending
            }
        }
        # [ doc = "Values that can be written to the field `UIF`" ]
        pub enum UifW {
            # [ doc = "Clears the update interrupt flag" ]
            Clear,
        }
        impl UifW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UifW::Clear => 0,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UifW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            # [ doc = "Clears the update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn clear(self) -> &'a mut W {
                self.variant(UifW::Clear)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&self) -> UifR {
                UifR::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    # [ doc = "event generation register" ]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    # [ doc = "event generation register" ]
    pub mod egr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Update generation" ]
            # [ inline ( always ) ]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    # [ doc = "counter" ]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    # [ doc = "counter" ]
    pub mod cnt {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Low counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Low counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&mut self) -> _CntW {
                _CntW { w: self }
            }
        }
    }
    # [ doc = "prescaler" ]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    # [ doc = "prescaler" ]
    pub mod psc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    # [ doc = "auto-reload register" ]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    # [ doc = "auto-reload register" ]
    pub mod arr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArrR {
            bits: u16,
        }
        impl ArrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Low Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&self) -> ArrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Low Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&mut self) -> _ArrW {
                _ArrW { w: self }
            }
        }
    }
}
# [ doc = "Basic timer" ]
pub struct Tim6 {
    register_block: tim6::RegisterBlock,
}
impl Deref for Tim6 {
    type Target = tim6::RegisterBlock;
    fn deref(&self) -> &tim6::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "TIM7" ]
pub const TIM7: Peripheral<Tim7> = unsafe { Peripheral::new(1073746944) };
# [ doc = r" Register block" ]
pub struct Tim7 {
    register_block: tim6::RegisterBlock,
}
impl Deref for Tim7 {
    type Target = tim6::RegisterBlock;
    fn deref(&self) -> &tim6::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Inter integrated circuit" ]
pub const I2C1: Peripheral<I2c1> = unsafe { Peripheral::new(1073763328) };
# [ doc = "Inter integrated circuit" ]
pub mod i2c1 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Control register 1" ]
        pub cr1: Cr1,
        # [ doc = "0x04 - Control register 2" ]
        pub cr2: Cr2,
        # [ doc = "0x08 - Own address register 1" ]
        pub oar1: Oar1,
        # [ doc = "0x0c - Own address register 2" ]
        pub oar2: Oar2,
        # [ doc = "0x10 - Data register" ]
        pub dr: Dr,
        # [ doc = "0x14 - Status register 1" ]
        pub sr1: Sr1,
        # [ doc = "0x18 - Status register 2" ]
        pub sr2: Sr2,
        # [ doc = "0x1c - Clock control register" ]
        pub ccr: Ccr,
        # [ doc = "0x20 - TRISE register" ]
        pub trise: Trise,
    }
    # [ doc = "Control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SwrstR {
            bits: u8,
        }
        impl SwrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AlertR {
            bits: u8,
        }
        impl AlertR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PecR {
            bits: u8,
        }
        impl PecR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PosR {
            bits: u8,
        }
        impl PosR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AckR {
            bits: u8,
        }
        impl AckR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct StopR {
            bits: u8,
        }
        impl StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct StartR {
            bits: u8,
        }
        impl StartR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NostretchR {
            bits: u8,
        }
        impl NostretchR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EngcR {
            bits: u8,
        }
        impl EngcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EnpecR {
            bits: u8,
        }
        impl EnpecR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EnarpR {
            bits: u8,
        }
        impl EnarpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SmbtypeR {
            bits: u8,
        }
        impl SmbtypeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SmbusR {
            bits: u8,
        }
        impl SmbusR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PeR {
            bits: u8,
        }
        impl PeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SwrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SwrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AlertW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AlertW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PecW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PecW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PosW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PosW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AckW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AckW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StartW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StartW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NostretchW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NostretchW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EngcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EngcW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnpecW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnpecW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnarpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnarpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SmbtypeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmbtypeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SmbusW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmbusW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - Software reset" ]
            # [ inline ( always ) ]
            pub fn swrst(&self) -> SwrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SwrstR { bits }
            }
            # [ doc = "Bit 13 - SMBus alert" ]
            # [ inline ( always ) ]
            pub fn alert(&self) -> AlertR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AlertR { bits }
            }
            # [ doc = "Bit 12 - Packet error checking" ]
            # [ inline ( always ) ]
            pub fn pec(&self) -> PecR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PecR { bits }
            }
            # [ doc = "Bit 11 - Acknowledge/PEC Position (for data reception)" ]
            # [ inline ( always ) ]
            pub fn pos(&self) -> PosR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PosR { bits }
            }
            # [ doc = "Bit 10 - Acknowledge enable" ]
            # [ inline ( always ) ]
            pub fn ack(&self) -> AckR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AckR { bits }
            }
            # [ doc = "Bit 9 - Stop generation" ]
            # [ inline ( always ) ]
            pub fn stop(&self) -> StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StopR { bits }
            }
            # [ doc = "Bit 8 - Start generation" ]
            # [ inline ( always ) ]
            pub fn start(&self) -> StartR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StartR { bits }
            }
            # [ doc = "Bit 7 - Clock stretching disable (Slave mode)" ]
            # [ inline ( always ) ]
            pub fn nostretch(&self) -> NostretchR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NostretchR { bits }
            }
            # [ doc = "Bit 6 - General call enable" ]
            # [ inline ( always ) ]
            pub fn engc(&self) -> EngcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EngcR { bits }
            }
            # [ doc = "Bit 5 - PEC enable" ]
            # [ inline ( always ) ]
            pub fn enpec(&self) -> EnpecR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnpecR { bits }
            }
            # [ doc = "Bit 4 - ARP enable" ]
            # [ inline ( always ) ]
            pub fn enarp(&self) -> EnarpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnarpR { bits }
            }
            # [ doc = "Bit 3 - SMBus type" ]
            # [ inline ( always ) ]
            pub fn smbtype(&self) -> SmbtypeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmbtypeR { bits }
            }
            # [ doc = "Bit 1 - SMBus mode" ]
            # [ inline ( always ) ]
            pub fn smbus(&self) -> SmbusR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmbusR { bits }
            }
            # [ doc = "Bit 0 - Peripheral enable" ]
            # [ inline ( always ) ]
            pub fn pe(&self) -> PeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - Software reset" ]
            # [ inline ( always ) ]
            pub fn swrst(&mut self) -> _SwrstW {
                _SwrstW { w: self }
            }
            # [ doc = "Bit 13 - SMBus alert" ]
            # [ inline ( always ) ]
            pub fn alert(&mut self) -> _AlertW {
                _AlertW { w: self }
            }
            # [ doc = "Bit 12 - Packet error checking" ]
            # [ inline ( always ) ]
            pub fn pec(&mut self) -> _PecW {
                _PecW { w: self }
            }
            # [ doc = "Bit 11 - Acknowledge/PEC Position (for data reception)" ]
            # [ inline ( always ) ]
            pub fn pos(&mut self) -> _PosW {
                _PosW { w: self }
            }
            # [ doc = "Bit 10 - Acknowledge enable" ]
            # [ inline ( always ) ]
            pub fn ack(&mut self) -> _AckW {
                _AckW { w: self }
            }
            # [ doc = "Bit 9 - Stop generation" ]
            # [ inline ( always ) ]
            pub fn stop(&mut self) -> _StopW {
                _StopW { w: self }
            }
            # [ doc = "Bit 8 - Start generation" ]
            # [ inline ( always ) ]
            pub fn start(&mut self) -> _StartW {
                _StartW { w: self }
            }
            # [ doc = "Bit 7 - Clock stretching disable (Slave mode)" ]
            # [ inline ( always ) ]
            pub fn nostretch(&mut self) -> _NostretchW {
                _NostretchW { w: self }
            }
            # [ doc = "Bit 6 - General call enable" ]
            # [ inline ( always ) ]
            pub fn engc(&mut self) -> _EngcW {
                _EngcW { w: self }
            }
            # [ doc = "Bit 5 - PEC enable" ]
            # [ inline ( always ) ]
            pub fn enpec(&mut self) -> _EnpecW {
                _EnpecW { w: self }
            }
            # [ doc = "Bit 4 - ARP enable" ]
            # [ inline ( always ) ]
            pub fn enarp(&mut self) -> _EnarpW {
                _EnarpW { w: self }
            }
            # [ doc = "Bit 3 - SMBus type" ]
            # [ inline ( always ) ]
            pub fn smbtype(&mut self) -> _SmbtypeW {
                _SmbtypeW { w: self }
            }
            # [ doc = "Bit 1 - SMBus mode" ]
            # [ inline ( always ) ]
            pub fn smbus(&mut self) -> _SmbusW {
                _SmbusW { w: self }
            }
            # [ doc = "Bit 0 - Peripheral enable" ]
            # [ inline ( always ) ]
            pub fn pe(&mut self) -> _PeW {
                _PeW { w: self }
            }
        }
    }
    # [ doc = "Control register 2" ]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register 2" ]
    pub mod cr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LastR {
            bits: u8,
        }
        impl LastR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaenR {
            bits: u8,
        }
        impl DmaenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ItbufenR {
            bits: u8,
        }
        impl ItbufenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ItevtenR {
            bits: u8,
        }
        impl ItevtenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IterrenR {
            bits: u8,
        }
        impl IterrenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FreqR {
            bits: u8,
        }
        impl FreqR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LastW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LastW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ItbufenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ItbufenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ItevtenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ItevtenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IterrenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IterrenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FreqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FreqW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 12 - DMA last transfer" ]
            # [ inline ( always ) ]
            pub fn last(&self) -> LastR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LastR { bits }
            }
            # [ doc = "Bit 11 - DMA requests enable" ]
            # [ inline ( always ) ]
            pub fn dmaen(&self) -> DmaenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DmaenR { bits }
            }
            # [ doc = "Bit 10 - Buffer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn itbufen(&self) -> ItbufenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ItbufenR { bits }
            }
            # [ doc = "Bit 9 - Event interrupt enable" ]
            # [ inline ( always ) ]
            pub fn itevten(&self) -> ItevtenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ItevtenR { bits }
            }
            # [ doc = "Bit 8 - Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn iterren(&self) -> IterrenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IterrenR { bits }
            }
            # [ doc = "Bits 0:5 - Peripheral clock frequency" ]
            # [ inline ( always ) ]
            pub fn freq(&self) -> FreqR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FreqR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 12 - DMA last transfer" ]
            # [ inline ( always ) ]
            pub fn last(&mut self) -> _LastW {
                _LastW { w: self }
            }
            # [ doc = "Bit 11 - DMA requests enable" ]
            # [ inline ( always ) ]
            pub fn dmaen(&mut self) -> _DmaenW {
                _DmaenW { w: self }
            }
            # [ doc = "Bit 10 - Buffer interrupt enable" ]
            # [ inline ( always ) ]
            pub fn itbufen(&mut self) -> _ItbufenW {
                _ItbufenW { w: self }
            }
            # [ doc = "Bit 9 - Event interrupt enable" ]
            # [ inline ( always ) ]
            pub fn itevten(&mut self) -> _ItevtenW {
                _ItevtenW { w: self }
            }
            # [ doc = "Bit 8 - Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn iterren(&mut self) -> _IterrenW {
                _IterrenW { w: self }
            }
            # [ doc = "Bits 0:5 - Peripheral clock frequency" ]
            # [ inline ( always ) ]
            pub fn freq(&mut self) -> _FreqW {
                _FreqW { w: self }
            }
        }
    }
    # [ doc = "Own address register 1" ]
    pub struct Oar1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Own address register 1" ]
    pub mod oar1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Oar1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddmodeR {
            bits: u8,
        }
        impl AddmodeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Add10R {
            bits: u8,
        }
        impl Add10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Add7R {
            bits: u8,
        }
        impl Add7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Add0R {
            bits: u8,
        }
        impl Add0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddmodeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddmodeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Add10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Add10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Add7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Add7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Add0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Add0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - Addressing mode (slave mode)" ]
            # [ inline ( always ) ]
            pub fn addmode(&self) -> AddmodeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddmodeR { bits }
            }
            # [ doc = "Bits 8:9 - Interface address" ]
            # [ inline ( always ) ]
            pub fn add10(&self) -> Add10R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Add10R { bits }
            }
            # [ doc = "Bits 1:7 - Interface address" ]
            # [ inline ( always ) ]
            pub fn add7(&self) -> Add7R {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Add7R { bits }
            }
            # [ doc = "Bit 0 - Interface address" ]
            # [ inline ( always ) ]
            pub fn add0(&self) -> Add0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Add0R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - Addressing mode (slave mode)" ]
            # [ inline ( always ) ]
            pub fn addmode(&mut self) -> _AddmodeW {
                _AddmodeW { w: self }
            }
            # [ doc = "Bits 8:9 - Interface address" ]
            # [ inline ( always ) ]
            pub fn add10(&mut self) -> _Add10W {
                _Add10W { w: self }
            }
            # [ doc = "Bits 1:7 - Interface address" ]
            # [ inline ( always ) ]
            pub fn add7(&mut self) -> _Add7W {
                _Add7W { w: self }
            }
            # [ doc = "Bit 0 - Interface address" ]
            # [ inline ( always ) ]
            pub fn add0(&mut self) -> _Add0W {
                _Add0W { w: self }
            }
        }
    }
    # [ doc = "Own address register 2" ]
    pub struct Oar2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Own address register 2" ]
    pub mod oar2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Oar2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Add2R {
            bits: u8,
        }
        impl Add2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EndualR {
            bits: u8,
        }
        impl EndualR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Add2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Add2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EndualW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EndualW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 1:7 - Interface address" ]
            # [ inline ( always ) ]
            pub fn add2(&self) -> Add2R {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Add2R { bits }
            }
            # [ doc = "Bit 0 - Dual addressing mode enable" ]
            # [ inline ( always ) ]
            pub fn endual(&self) -> EndualR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EndualR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 1:7 - Interface address" ]
            # [ inline ( always ) ]
            pub fn add2(&mut self) -> _Add2W {
                _Add2W { w: self }
            }
            # [ doc = "Bit 0 - Dual addressing mode enable" ]
            # [ inline ( always ) ]
            pub fn endual(&mut self) -> _EndualW {
                _EndualW { w: self }
            }
        }
    }
    # [ doc = "Data register" ]
    pub struct Dr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Data register" ]
    pub mod dr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DrR {
            bits: u8,
        }
        impl DrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - 8-bit data register" ]
            # [ inline ( always ) ]
            pub fn dr(&self) -> DrR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - 8-bit data register" ]
            # [ inline ( always ) ]
            pub fn dr(&mut self) -> _DrW {
                _DrW { w: self }
            }
        }
    }
    # [ doc = "Status register 1" ]
    pub struct Sr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Status register 1" ]
    pub mod sr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SmbalertR {
            bits: u8,
        }
        impl SmbalertR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TimeoutR {
            bits: u8,
        }
        impl TimeoutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PecerrR {
            bits: u8,
        }
        impl PecerrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OvrR {
            bits: u8,
        }
        impl OvrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AfR {
            bits: u8,
        }
        impl AfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArloR {
            bits: u8,
        }
        impl ArloR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BerrR {
            bits: u8,
        }
        impl BerrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxER {
            bits: u8,
        }
        impl TxER {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxNeR {
            bits: u8,
        }
        impl RxNeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct StopfR {
            bits: u8,
        }
        impl StopfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Add10R {
            bits: u8,
        }
        impl Add10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BtfR {
            bits: u8,
        }
        impl BtfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddrR {
            bits: u8,
        }
        impl AddrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SbR {
            bits: u8,
        }
        impl SbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SmbalertW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmbalertW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TimeoutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TimeoutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PecerrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PecerrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OvrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OvrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArloW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArloW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BerrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BerrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - SMBus alert" ]
            # [ inline ( always ) ]
            pub fn smbalert(&self) -> SmbalertR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmbalertR { bits }
            }
            # [ doc = "Bit 14 - Timeout or Tlow error" ]
            # [ inline ( always ) ]
            pub fn timeout(&self) -> TimeoutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TimeoutR { bits }
            }
            # [ doc = "Bit 12 - PEC Error in reception" ]
            # [ inline ( always ) ]
            pub fn pecerr(&self) -> PecerrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PecerrR { bits }
            }
            # [ doc = "Bit 11 - Overrun/Underrun" ]
            # [ inline ( always ) ]
            pub fn ovr(&self) -> OvrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OvrR { bits }
            }
            # [ doc = "Bit 10 - Acknowledge failure" ]
            # [ inline ( always ) ]
            pub fn af(&self) -> AfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AfR { bits }
            }
            # [ doc = "Bit 9 - Arbitration lost (master mode)" ]
            # [ inline ( always ) ]
            pub fn arlo(&self) -> ArloR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArloR { bits }
            }
            # [ doc = "Bit 8 - Bus error" ]
            # [ inline ( always ) ]
            pub fn berr(&self) -> BerrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BerrR { bits }
            }
            # [ doc = "Bit 7 - Data register empty (transmitters)" ]
            # [ inline ( always ) ]
            pub fn tx_e(&self) -> TxER {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxER { bits }
            }
            # [ doc = "Bit 6 - Data register not empty (receivers)" ]
            # [ inline ( always ) ]
            pub fn rx_ne(&self) -> RxNeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxNeR { bits }
            }
            # [ doc = "Bit 4 - Stop detection (slave mode)" ]
            # [ inline ( always ) ]
            pub fn stopf(&self) -> StopfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StopfR { bits }
            }
            # [ doc = "Bit 3 - 10-bit header sent (Master mode)" ]
            # [ inline ( always ) ]
            pub fn add10(&self) -> Add10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Add10R { bits }
            }
            # [ doc = "Bit 2 - Byte transfer finished" ]
            # [ inline ( always ) ]
            pub fn btf(&self) -> BtfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BtfR { bits }
            }
            # [ doc = "Bit 1 - Address sent (master mode)/matched (slave mode)" ]
            # [ inline ( always ) ]
            pub fn addr(&self) -> AddrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddrR { bits }
            }
            # [ doc = "Bit 0 - Start bit (Master mode)" ]
            # [ inline ( always ) ]
            pub fn sb(&self) -> SbR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SbR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - SMBus alert" ]
            # [ inline ( always ) ]
            pub fn smbalert(&mut self) -> _SmbalertW {
                _SmbalertW { w: self }
            }
            # [ doc = "Bit 14 - Timeout or Tlow error" ]
            # [ inline ( always ) ]
            pub fn timeout(&mut self) -> _TimeoutW {
                _TimeoutW { w: self }
            }
            # [ doc = "Bit 12 - PEC Error in reception" ]
            # [ inline ( always ) ]
            pub fn pecerr(&mut self) -> _PecerrW {
                _PecerrW { w: self }
            }
            # [ doc = "Bit 11 - Overrun/Underrun" ]
            # [ inline ( always ) ]
            pub fn ovr(&mut self) -> _OvrW {
                _OvrW { w: self }
            }
            # [ doc = "Bit 10 - Acknowledge failure" ]
            # [ inline ( always ) ]
            pub fn af(&mut self) -> _AfW {
                _AfW { w: self }
            }
            # [ doc = "Bit 9 - Arbitration lost (master mode)" ]
            # [ inline ( always ) ]
            pub fn arlo(&mut self) -> _ArloW {
                _ArloW { w: self }
            }
            # [ doc = "Bit 8 - Bus error" ]
            # [ inline ( always ) ]
            pub fn berr(&mut self) -> _BerrW {
                _BerrW { w: self }
            }
        }
    }
    # [ doc = "Status register 2" ]
    pub struct Sr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Status register 2" ]
    pub mod sr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Sr2 {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PecR {
            bits: u8,
        }
        impl PecR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DualfR {
            bits: u8,
        }
        impl DualfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SmbhostR {
            bits: u8,
        }
        impl SmbhostR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SmbdefaultR {
            bits: u8,
        }
        impl SmbdefaultR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct GencallR {
            bits: u8,
        }
        impl GencallR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TraR {
            bits: u8,
        }
        impl TraR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BusyR {
            bits: u8,
        }
        impl BusyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MslR {
            bits: u8,
        }
        impl MslR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 8:15 - acket error checking register" ]
            # [ inline ( always ) ]
            pub fn pec(&self) -> PecR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PecR { bits }
            }
            # [ doc = "Bit 7 - Dual flag (Slave mode)" ]
            # [ inline ( always ) ]
            pub fn dualf(&self) -> DualfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DualfR { bits }
            }
            # [ doc = "Bit 6 - SMBus host header (Slave mode)" ]
            # [ inline ( always ) ]
            pub fn smbhost(&self) -> SmbhostR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmbhostR { bits }
            }
            # [ doc = "Bit 5 - SMBus device default address (Slave mode)" ]
            # [ inline ( always ) ]
            pub fn smbdefault(&self) -> SmbdefaultR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmbdefaultR { bits }
            }
            # [ doc = "Bit 4 - General call address (Slave mode)" ]
            # [ inline ( always ) ]
            pub fn gencall(&self) -> GencallR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                GencallR { bits }
            }
            # [ doc = "Bit 2 - Transmitter/receiver" ]
            # [ inline ( always ) ]
            pub fn tra(&self) -> TraR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TraR { bits }
            }
            # [ doc = "Bit 1 - Bus busy" ]
            # [ inline ( always ) ]
            pub fn busy(&self) -> BusyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BusyR { bits }
            }
            # [ doc = "Bit 0 - Master/slave" ]
            # [ inline ( always ) ]
            pub fn msl(&self) -> MslR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MslR { bits }
            }
        }
    }
    # [ doc = "Clock control register" ]
    pub struct Ccr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Clock control register" ]
    pub mod ccr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FSR {
            bits: u8,
        }
        impl FSR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DutyR {
            bits: u8,
        }
        impl DutyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcrR {
            bits: u16,
        }
        impl CcrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FSW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DutyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DutyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - I2C master mode selection" ]
            # [ inline ( always ) ]
            pub fn f_s(&self) -> FSR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FSR { bits }
            }
            # [ doc = "Bit 14 - Fast mode duty cycle" ]
            # [ inline ( always ) ]
            pub fn duty(&self) -> DutyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DutyR { bits }
            }
            # [ doc = "Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)" ]
            # [ inline ( always ) ]
            pub fn ccr(&self) -> CcrR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CcrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - I2C master mode selection" ]
            # [ inline ( always ) ]
            pub fn f_s(&mut self) -> _FSW {
                _FSW { w: self }
            }
            # [ doc = "Bit 14 - Fast mode duty cycle" ]
            # [ inline ( always ) ]
            pub fn duty(&mut self) -> _DutyW {
                _DutyW { w: self }
            }
            # [ doc = "Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)" ]
            # [ inline ( always ) ]
            pub fn ccr(&mut self) -> _CcrW {
                _CcrW { w: self }
            }
        }
    }
    # [ doc = "TRISE register" ]
    pub struct Trise {
        register: VolatileCell<u32>,
    }
    # [ doc = "TRISE register" ]
    pub mod trise {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Trise {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TriseR {
            bits: u8,
        }
        impl TriseR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TriseW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TriseW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)" ]
            # [ inline ( always ) ]
            pub fn trise(&self) -> TriseR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TriseR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 2 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)" ]
            # [ inline ( always ) ]
            pub fn trise(&mut self) -> _TriseW {
                _TriseW { w: self }
            }
        }
    }
}
# [ doc = "Inter integrated circuit" ]
pub struct I2c1 {
    register_block: i2c1::RegisterBlock,
}
impl Deref for I2c1 {
    type Target = i2c1::RegisterBlock;
    fn deref(&self) -> &i2c1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "I2C2" ]
pub const I2C2: Peripheral<I2c2> = unsafe { Peripheral::new(1073764352) };
# [ doc = r" Register block" ]
pub struct I2c2 {
    register_block: i2c1::RegisterBlock,
}
impl Deref for I2c2 {
    type Target = i2c1::RegisterBlock;
    fn deref(&self) -> &i2c1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Serial peripheral interface" ]
pub const SPI1: Peripheral<Spi1> = unsafe { Peripheral::new(1073819648) };
# [ doc = "Serial peripheral interface" ]
pub mod spi1 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - control register 1" ]
        pub cr1: Cr1,
        # [ doc = "0x04 - control register 2" ]
        pub cr2: Cr2,
        # [ doc = "0x08 - status register" ]
        pub sr: Sr,
        # [ doc = "0x0c - data register" ]
        pub dr: Dr,
        # [ doc = "0x10 - CRC polynomial register" ]
        pub crcpr: Crcpr,
        # [ doc = "0x14 - RX CRC register" ]
        pub rxcrcr: Rxcrcr,
        # [ doc = "0x18 - TX CRC register" ]
        pub txcrcr: Txcrcr,
    }
    # [ doc = "control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BidimodeR {
            bits: u8,
        }
        impl BidimodeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BidioeR {
            bits: u8,
        }
        impl BidioeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CrcenR {
            bits: u8,
        }
        impl CrcenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CrcnextR {
            bits: u8,
        }
        impl CrcnextR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DffR {
            bits: u8,
        }
        impl DffR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxonlyR {
            bits: u8,
        }
        impl RxonlyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SsmR {
            bits: u8,
        }
        impl SsmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SsiR {
            bits: u8,
        }
        impl SsiR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LsbfirstR {
            bits: u8,
        }
        impl LsbfirstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SpeR {
            bits: u8,
        }
        impl SpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BrR {
            bits: u8,
        }
        impl BrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MstrR {
            bits: u8,
        }
        impl MstrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CpolR {
            bits: u8,
        }
        impl CpolR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CphaR {
            bits: u8,
        }
        impl CphaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BidimodeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BidimodeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BidioeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BidioeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CrcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrcenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CrcnextW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrcnextW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DffW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DffW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxonlyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxonlyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SsmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SsmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SsiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SsiW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LsbfirstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LsbfirstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MstrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MstrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CpolW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CphaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CphaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - Bidirectional data mode enable" ]
            # [ inline ( always ) ]
            pub fn bidimode(&self) -> BidimodeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BidimodeR { bits }
            }
            # [ doc = "Bit 14 - Output enable in bidirectional mode" ]
            # [ inline ( always ) ]
            pub fn bidioe(&self) -> BidioeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BidioeR { bits }
            }
            # [ doc = "Bit 13 - Hardware CRC calculation enable" ]
            # [ inline ( always ) ]
            pub fn crcen(&self) -> CrcenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CrcenR { bits }
            }
            # [ doc = "Bit 12 - CRC transfer next" ]
            # [ inline ( always ) ]
            pub fn crcnext(&self) -> CrcnextR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CrcnextR { bits }
            }
            # [ doc = "Bit 11 - Data frame format" ]
            # [ inline ( always ) ]
            pub fn dff(&self) -> DffR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DffR { bits }
            }
            # [ doc = "Bit 10 - Receive only" ]
            # [ inline ( always ) ]
            pub fn rxonly(&self) -> RxonlyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxonlyR { bits }
            }
            # [ doc = "Bit 9 - Software slave management" ]
            # [ inline ( always ) ]
            pub fn ssm(&self) -> SsmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SsmR { bits }
            }
            # [ doc = "Bit 8 - Internal slave select" ]
            # [ inline ( always ) ]
            pub fn ssi(&self) -> SsiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SsiR { bits }
            }
            # [ doc = "Bit 7 - Frame format" ]
            # [ inline ( always ) ]
            pub fn lsbfirst(&self) -> LsbfirstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LsbfirstR { bits }
            }
            # [ doc = "Bit 6 - SPI enable" ]
            # [ inline ( always ) ]
            pub fn spe(&self) -> SpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SpeR { bits }
            }
            # [ doc = "Bits 3:5 - Baud rate control" ]
            # [ inline ( always ) ]
            pub fn br(&self) -> BrR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BrR { bits }
            }
            # [ doc = "Bit 2 - Master selection" ]
            # [ inline ( always ) ]
            pub fn mstr(&self) -> MstrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MstrR { bits }
            }
            # [ doc = "Bit 1 - Clock polarity" ]
            # [ inline ( always ) ]
            pub fn cpol(&self) -> CpolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CpolR { bits }
            }
            # [ doc = "Bit 0 - Clock phase" ]
            # [ inline ( always ) ]
            pub fn cpha(&self) -> CphaR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CphaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - Bidirectional data mode enable" ]
            # [ inline ( always ) ]
            pub fn bidimode(&mut self) -> _BidimodeW {
                _BidimodeW { w: self }
            }
            # [ doc = "Bit 14 - Output enable in bidirectional mode" ]
            # [ inline ( always ) ]
            pub fn bidioe(&mut self) -> _BidioeW {
                _BidioeW { w: self }
            }
            # [ doc = "Bit 13 - Hardware CRC calculation enable" ]
            # [ inline ( always ) ]
            pub fn crcen(&mut self) -> _CrcenW {
                _CrcenW { w: self }
            }
            # [ doc = "Bit 12 - CRC transfer next" ]
            # [ inline ( always ) ]
            pub fn crcnext(&mut self) -> _CrcnextW {
                _CrcnextW { w: self }
            }
            # [ doc = "Bit 11 - Data frame format" ]
            # [ inline ( always ) ]
            pub fn dff(&mut self) -> _DffW {
                _DffW { w: self }
            }
            # [ doc = "Bit 10 - Receive only" ]
            # [ inline ( always ) ]
            pub fn rxonly(&mut self) -> _RxonlyW {
                _RxonlyW { w: self }
            }
            # [ doc = "Bit 9 - Software slave management" ]
            # [ inline ( always ) ]
            pub fn ssm(&mut self) -> _SsmW {
                _SsmW { w: self }
            }
            # [ doc = "Bit 8 - Internal slave select" ]
            # [ inline ( always ) ]
            pub fn ssi(&mut self) -> _SsiW {
                _SsiW { w: self }
            }
            # [ doc = "Bit 7 - Frame format" ]
            # [ inline ( always ) ]
            pub fn lsbfirst(&mut self) -> _LsbfirstW {
                _LsbfirstW { w: self }
            }
            # [ doc = "Bit 6 - SPI enable" ]
            # [ inline ( always ) ]
            pub fn spe(&mut self) -> _SpeW {
                _SpeW { w: self }
            }
            # [ doc = "Bits 3:5 - Baud rate control" ]
            # [ inline ( always ) ]
            pub fn br(&mut self) -> _BrW {
                _BrW { w: self }
            }
            # [ doc = "Bit 2 - Master selection" ]
            # [ inline ( always ) ]
            pub fn mstr(&mut self) -> _MstrW {
                _MstrW { w: self }
            }
            # [ doc = "Bit 1 - Clock polarity" ]
            # [ inline ( always ) ]
            pub fn cpol(&mut self) -> _CpolW {
                _CpolW { w: self }
            }
            # [ doc = "Bit 0 - Clock phase" ]
            # [ inline ( always ) ]
            pub fn cpha(&mut self) -> _CphaW {
                _CphaW { w: self }
            }
        }
    }
    # [ doc = "control register 2" ]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 2" ]
    pub mod cr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxeieR {
            bits: u8,
        }
        impl TxeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxneieR {
            bits: u8,
        }
        impl RxneieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ErrieR {
            bits: u8,
        }
        impl ErrieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SsoeR {
            bits: u8,
        }
        impl SsoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxdmaenR {
            bits: u8,
        }
        impl TxdmaenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxdmaenR {
            bits: u8,
        }
        impl RxdmaenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxneieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxneieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ErrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SsoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SsoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxdmaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdmaenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxdmaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxdmaenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 7 - Tx buffer empty interrupt enable" ]
            # [ inline ( always ) ]
            pub fn txeie(&self) -> TxeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeieR { bits }
            }
            # [ doc = "Bit 6 - RX buffer not empty interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rxneie(&self) -> RxneieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneieR { bits }
            }
            # [ doc = "Bit 5 - Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn errie(&self) -> ErrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ErrieR { bits }
            }
            # [ doc = "Bit 2 - SS output enable" ]
            # [ inline ( always ) ]
            pub fn ssoe(&self) -> SsoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SsoeR { bits }
            }
            # [ doc = "Bit 1 - Tx buffer DMA enable" ]
            # [ inline ( always ) ]
            pub fn txdmaen(&self) -> TxdmaenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxdmaenR { bits }
            }
            # [ doc = "Bit 0 - Rx buffer DMA enable" ]
            # [ inline ( always ) ]
            pub fn rxdmaen(&self) -> RxdmaenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxdmaenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 7 - Tx buffer empty interrupt enable" ]
            # [ inline ( always ) ]
            pub fn txeie(&mut self) -> _TxeieW {
                _TxeieW { w: self }
            }
            # [ doc = "Bit 6 - RX buffer not empty interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rxneie(&mut self) -> _RxneieW {
                _RxneieW { w: self }
            }
            # [ doc = "Bit 5 - Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn errie(&mut self) -> _ErrieW {
                _ErrieW { w: self }
            }
            # [ doc = "Bit 2 - SS output enable" ]
            # [ inline ( always ) ]
            pub fn ssoe(&mut self) -> _SsoeW {
                _SsoeW { w: self }
            }
            # [ doc = "Bit 1 - Tx buffer DMA enable" ]
            # [ inline ( always ) ]
            pub fn txdmaen(&mut self) -> _TxdmaenW {
                _TxdmaenW { w: self }
            }
            # [ doc = "Bit 0 - Rx buffer DMA enable" ]
            # [ inline ( always ) ]
            pub fn rxdmaen(&mut self) -> _RxdmaenW {
                _RxdmaenW { w: self }
            }
        }
    }
    # [ doc = "status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BsyR {
            bits: u8,
        }
        impl BsyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OvrR {
            bits: u8,
        }
        impl OvrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ModfR {
            bits: u8,
        }
        impl ModfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CrcerrR {
            bits: u8,
        }
        impl CrcerrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxeR {
            bits: u8,
        }
        impl TxeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxneR {
            bits: u8,
        }
        impl RxneR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CrcerrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrcerrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 7 - Busy flag" ]
            # [ inline ( always ) ]
            pub fn bsy(&self) -> BsyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BsyR { bits }
            }
            # [ doc = "Bit 6 - Overrun flag" ]
            # [ inline ( always ) ]
            pub fn ovr(&self) -> OvrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OvrR { bits }
            }
            # [ doc = "Bit 5 - Mode fault" ]
            # [ inline ( always ) ]
            pub fn modf(&self) -> ModfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ModfR { bits }
            }
            # [ doc = "Bit 4 - CRC error flag" ]
            # [ inline ( always ) ]
            pub fn crcerr(&self) -> CrcerrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CrcerrR { bits }
            }
            # [ doc = "Bit 1 - Transmit buffer empty" ]
            # [ inline ( always ) ]
            pub fn txe(&self) -> TxeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeR { bits }
            }
            # [ doc = "Bit 0 - Receive buffer not empty" ]
            # [ inline ( always ) ]
            pub fn rxne(&self) -> RxneR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 2 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 4 - CRC error flag" ]
            # [ inline ( always ) ]
            pub fn crcerr(&mut self) -> _CrcerrW {
                _CrcerrW { w: self }
            }
        }
    }
    # [ doc = "data register" ]
    pub struct Dr {
        register: VolatileCell<u32>,
    }
    # [ doc = "data register" ]
    pub mod dr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DrR {
            bits: u16,
        }
        impl DrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Data register" ]
            # [ inline ( always ) ]
            pub fn dr(&self) -> DrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Data register" ]
            # [ inline ( always ) ]
            pub fn dr(&mut self) -> _DrW {
                _DrW { w: self }
            }
        }
    }
    # [ doc = "CRC polynomial register" ]
    pub struct Crcpr {
        register: VolatileCell<u32>,
    }
    # [ doc = "CRC polynomial register" ]
    pub mod crcpr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Crcpr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CrcpolyR {
            bits: u16,
        }
        impl CrcpolyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CrcpolyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrcpolyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - CRC polynomial register" ]
            # [ inline ( always ) ]
            pub fn crcpoly(&self) -> CrcpolyR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CrcpolyR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 7 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - CRC polynomial register" ]
            # [ inline ( always ) ]
            pub fn crcpoly(&mut self) -> _CrcpolyW {
                _CrcpolyW { w: self }
            }
        }
    }
    # [ doc = "RX CRC register" ]
    pub struct Rxcrcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "RX CRC register" ]
    pub mod rxcrcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Rxcrcr {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxCrcR {
            bits: u16,
        }
        impl RxCrcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Rx CRC register" ]
            # [ inline ( always ) ]
            pub fn rx_crc(&self) -> RxCrcR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RxCrcR { bits }
            }
        }
    }
    # [ doc = "TX CRC register" ]
    pub struct Txcrcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "TX CRC register" ]
    pub mod txcrcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Txcrcr {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxCrcR {
            bits: u16,
        }
        impl TxCrcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Tx CRC register" ]
            # [ inline ( always ) ]
            pub fn tx_crc(&self) -> TxCrcR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TxCrcR { bits }
            }
        }
    }
}
# [ doc = "Serial peripheral interface" ]
pub struct Spi1 {
    register_block: spi1::RegisterBlock,
}
impl Deref for Spi1 {
    type Target = spi1::RegisterBlock;
    fn deref(&self) -> &spi1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "SPI2" ]
pub const SPI2: Peripheral<Spi2> = unsafe { Peripheral::new(1073756160) };
# [ doc = r" Register block" ]
pub struct Spi2 {
    register_block: spi1::RegisterBlock,
}
impl Deref for Spi2 {
    type Target = spi1::RegisterBlock;
    fn deref(&self) -> &spi1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "SPI3" ]
pub const SPI3: Peripheral<Spi3> = unsafe { Peripheral::new(1073757184) };
# [ doc = r" Register block" ]
pub struct Spi3 {
    register_block: spi1::RegisterBlock,
}
impl Deref for Spi3 {
    type Target = spi1::RegisterBlock;
    fn deref(&self) -> &spi1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Universal synchronous asynchronous receiver transmitter" ]
pub const USART1: Peripheral<Usart1> = unsafe { Peripheral::new(1073821696) };
# [ doc = "Universal synchronous asynchronous receiver transmitter" ]
pub mod usart1 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Status register" ]
        pub sr: Sr,
        # [ doc = "0x04 - Data register" ]
        pub dr: Dr,
        # [ doc = "0x08 - Baud rate register" ]
        pub brr: Brr,
        # [ doc = "0x0c - Control register 1" ]
        pub cr1: Cr1,
        # [ doc = "0x10 - Control register 2" ]
        pub cr2: Cr2,
        # [ doc = "0x14 - Control register 3" ]
        pub cr3: Cr3,
        # [ doc = "0x18 - Guard time and prescaler register" ]
        pub gtpr: Gtpr,
    }
    # [ doc = "Status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CtsR {
            bits: u8,
        }
        impl CtsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LbdR {
            bits: u8,
        }
        impl LbdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxeR {
            bits: u8,
        }
        impl TxeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcR {
            bits: u8,
        }
        impl TcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxneR {
            bits: u8,
        }
        impl RxneR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IdleR {
            bits: u8,
        }
        impl IdleR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OreR {
            bits: u8,
        }
        impl OreR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NeR {
            bits: u8,
        }
        impl NeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FeR {
            bits: u8,
        }
        impl FeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PeR {
            bits: u8,
        }
        impl PeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CtsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LbdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxneW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxneW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 9 - CTS flag" ]
            # [ inline ( always ) ]
            pub fn cts(&self) -> CtsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CtsR { bits }
            }
            # [ doc = "Bit 8 - LIN break detection flag" ]
            # [ inline ( always ) ]
            pub fn lbd(&self) -> LbdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdR { bits }
            }
            # [ doc = "Bit 7 - Transmit data register empty" ]
            # [ inline ( always ) ]
            pub fn txe(&self) -> TxeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeR { bits }
            }
            # [ doc = "Bit 6 - Transmission complete" ]
            # [ inline ( always ) ]
            pub fn tc(&self) -> TcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcR { bits }
            }
            # [ doc = "Bit 5 - Read data register not empty" ]
            # [ inline ( always ) ]
            pub fn rxne(&self) -> RxneR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneR { bits }
            }
            # [ doc = "Bit 4 - IDLE line detected" ]
            # [ inline ( always ) ]
            pub fn idle(&self) -> IdleR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IdleR { bits }
            }
            # [ doc = "Bit 3 - Overrun error" ]
            # [ inline ( always ) ]
            pub fn ore(&self) -> OreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OreR { bits }
            }
            # [ doc = "Bit 2 - Noise error flag" ]
            # [ inline ( always ) ]
            pub fn ne(&self) -> NeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NeR { bits }
            }
            # [ doc = "Bit 1 - Framing error" ]
            # [ inline ( always ) ]
            pub fn fe(&self) -> FeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FeR { bits }
            }
            # [ doc = "Bit 0 - Parity error" ]
            # [ inline ( always ) ]
            pub fn pe(&self) -> PeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 192 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 9 - CTS flag" ]
            # [ inline ( always ) ]
            pub fn cts(&mut self) -> _CtsW {
                _CtsW { w: self }
            }
            # [ doc = "Bit 8 - LIN break detection flag" ]
            # [ inline ( always ) ]
            pub fn lbd(&mut self) -> _LbdW {
                _LbdW { w: self }
            }
            # [ doc = "Bit 6 - Transmission complete" ]
            # [ inline ( always ) ]
            pub fn tc(&mut self) -> _TcW {
                _TcW { w: self }
            }
            # [ doc = "Bit 5 - Read data register not empty" ]
            # [ inline ( always ) ]
            pub fn rxne(&mut self) -> _RxneW {
                _RxneW { w: self }
            }
        }
    }
    # [ doc = "Data register" ]
    pub struct Dr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Data register" ]
    pub mod dr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DrR {
            bits: u16,
        }
        impl DrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 511;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:8 - Data value" ]
            # [ inline ( always ) ]
            pub fn dr(&self) -> DrR {
                let bits = {
                    const MASK: u16 = 511;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:8 - Data value" ]
            # [ inline ( always ) ]
            pub fn dr(&mut self) -> _DrW {
                _DrW { w: self }
            }
        }
    }
    # [ doc = "Baud rate register" ]
    pub struct Brr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Baud rate register" ]
    pub mod brr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Brr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DivMantissaR {
            bits: u16,
        }
        impl DivMantissaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DivFractionR {
            bits: u8,
        }
        impl DivFractionR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DivMantissaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DivMantissaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DivFractionW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DivFractionW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 4:15 - mantissa of USARTDIV" ]
            # [ inline ( always ) ]
            pub fn div_mantissa(&self) -> DivMantissaR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DivMantissaR { bits }
            }
            # [ doc = "Bits 0:3 - fraction of USARTDIV" ]
            # [ inline ( always ) ]
            pub fn div_fraction(&self) -> DivFractionR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DivFractionR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 4:15 - mantissa of USARTDIV" ]
            # [ inline ( always ) ]
            pub fn div_mantissa(&mut self) -> _DivMantissaW {
                _DivMantissaW { w: self }
            }
            # [ doc = "Bits 0:3 - fraction of USARTDIV" ]
            # [ inline ( always ) ]
            pub fn div_fraction(&mut self) -> _DivFractionW {
                _DivFractionW { w: self }
            }
        }
    }
    # [ doc = "Control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UeR {
            bits: u8,
        }
        impl UeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MR {
            bits: u8,
        }
        impl MR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WakeR {
            bits: u8,
        }
        impl WakeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PceR {
            bits: u8,
        }
        impl PceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PsR {
            bits: u8,
        }
        impl PsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PeieR {
            bits: u8,
        }
        impl PeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxeieR {
            bits: u8,
        }
        impl TxeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxneieR {
            bits: u8,
        }
        impl RxneieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IdleieR {
            bits: u8,
        }
        impl IdleieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TeR {
            bits: u8,
        }
        impl TeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ReR {
            bits: u8,
        }
        impl ReR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RwuR {
            bits: u8,
        }
        impl RwuR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SbkR {
            bits: u8,
        }
        impl SbkR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WakeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WakeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxneieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxneieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IdleieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IdleieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RwuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RwuW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SbkW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SbkW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 13 - USART enable" ]
            # [ inline ( always ) ]
            pub fn ue(&self) -> UeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UeR { bits }
            }
            # [ doc = "Bit 12 - Word length" ]
            # [ inline ( always ) ]
            pub fn m(&self) -> MR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MR { bits }
            }
            # [ doc = "Bit 11 - Wakeup method" ]
            # [ inline ( always ) ]
            pub fn wake(&self) -> WakeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WakeR { bits }
            }
            # [ doc = "Bit 10 - Parity control enable" ]
            # [ inline ( always ) ]
            pub fn pce(&self) -> PceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PceR { bits }
            }
            # [ doc = "Bit 9 - Parity selection" ]
            # [ inline ( always ) ]
            pub fn ps(&self) -> PsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsR { bits }
            }
            # [ doc = "Bit 8 - PE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn peie(&self) -> PeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PeieR { bits }
            }
            # [ doc = "Bit 7 - TXE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn txeie(&self) -> TxeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeieR { bits }
            }
            # [ doc = "Bit 6 - Transmission complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            # [ doc = "Bit 5 - RXNE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rxneie(&self) -> RxneieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneieR { bits }
            }
            # [ doc = "Bit 4 - IDLE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn idleie(&self) -> IdleieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IdleieR { bits }
            }
            # [ doc = "Bit 3 - Transmitter enable" ]
            # [ inline ( always ) ]
            pub fn te(&self) -> TeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeR { bits }
            }
            # [ doc = "Bit 2 - Receiver enable" ]
            # [ inline ( always ) ]
            pub fn re(&self) -> ReR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ReR { bits }
            }
            # [ doc = "Bit 1 - Receiver wakeup" ]
            # [ inline ( always ) ]
            pub fn rwu(&self) -> RwuR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RwuR { bits }
            }
            # [ doc = "Bit 0 - Send break" ]
            # [ inline ( always ) ]
            pub fn sbk(&self) -> SbkR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SbkR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 13 - USART enable" ]
            # [ inline ( always ) ]
            pub fn ue(&mut self) -> _UeW {
                _UeW { w: self }
            }
            # [ doc = "Bit 12 - Word length" ]
            # [ inline ( always ) ]
            pub fn m(&mut self) -> _MW {
                _MW { w: self }
            }
            # [ doc = "Bit 11 - Wakeup method" ]
            # [ inline ( always ) ]
            pub fn wake(&mut self) -> _WakeW {
                _WakeW { w: self }
            }
            # [ doc = "Bit 10 - Parity control enable" ]
            # [ inline ( always ) ]
            pub fn pce(&mut self) -> _PceW {
                _PceW { w: self }
            }
            # [ doc = "Bit 9 - Parity selection" ]
            # [ inline ( always ) ]
            pub fn ps(&mut self) -> _PsW {
                _PsW { w: self }
            }
            # [ doc = "Bit 8 - PE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn peie(&mut self) -> _PeieW {
                _PeieW { w: self }
            }
            # [ doc = "Bit 7 - TXE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn txeie(&mut self) -> _TxeieW {
                _TxeieW { w: self }
            }
            # [ doc = "Bit 6 - Transmission complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            # [ doc = "Bit 5 - RXNE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rxneie(&mut self) -> _RxneieW {
                _RxneieW { w: self }
            }
            # [ doc = "Bit 4 - IDLE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn idleie(&mut self) -> _IdleieW {
                _IdleieW { w: self }
            }
            # [ doc = "Bit 3 - Transmitter enable" ]
            # [ inline ( always ) ]
            pub fn te(&mut self) -> _TeW {
                _TeW { w: self }
            }
            # [ doc = "Bit 2 - Receiver enable" ]
            # [ inline ( always ) ]
            pub fn re(&mut self) -> _ReW {
                _ReW { w: self }
            }
            # [ doc = "Bit 1 - Receiver wakeup" ]
            # [ inline ( always ) ]
            pub fn rwu(&mut self) -> _RwuW {
                _RwuW { w: self }
            }
            # [ doc = "Bit 0 - Send break" ]
            # [ inline ( always ) ]
            pub fn sbk(&mut self) -> _SbkW {
                _SbkW { w: self }
            }
        }
    }
    # [ doc = "Control register 2" ]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register 2" ]
    pub mod cr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LinenR {
            bits: u8,
        }
        impl LinenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct StopR {
            bits: u8,
        }
        impl StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ClkenR {
            bits: u8,
        }
        impl ClkenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CpolR {
            bits: u8,
        }
        impl CpolR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CphaR {
            bits: u8,
        }
        impl CphaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LbclR {
            bits: u8,
        }
        impl LbclR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LbdieR {
            bits: u8,
        }
        impl LbdieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LbdlR {
            bits: u8,
        }
        impl LbdlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddR {
            bits: u8,
        }
        impl AddR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LinenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LinenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ClkenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ClkenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CpolW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CphaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CphaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LbclW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbclW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LbdieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbdieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LbdlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbdlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 14 - LIN mode enable" ]
            # [ inline ( always ) ]
            pub fn linen(&self) -> LinenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LinenR { bits }
            }
            # [ doc = "Bits 12:13 - STOP bits" ]
            # [ inline ( always ) ]
            pub fn stop(&self) -> StopR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StopR { bits }
            }
            # [ doc = "Bit 11 - Clock enable" ]
            # [ inline ( always ) ]
            pub fn clken(&self) -> ClkenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ClkenR { bits }
            }
            # [ doc = "Bit 10 - Clock polarity" ]
            # [ inline ( always ) ]
            pub fn cpol(&self) -> CpolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CpolR { bits }
            }
            # [ doc = "Bit 9 - Clock phase" ]
            # [ inline ( always ) ]
            pub fn cpha(&self) -> CphaR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CphaR { bits }
            }
            # [ doc = "Bit 8 - Last bit clock pulse" ]
            # [ inline ( always ) ]
            pub fn lbcl(&self) -> LbclR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbclR { bits }
            }
            # [ doc = "Bit 6 - LIN break detection interrupt enable" ]
            # [ inline ( always ) ]
            pub fn lbdie(&self) -> LbdieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdieR { bits }
            }
            # [ doc = "Bit 5 - lin break detection length" ]
            # [ inline ( always ) ]
            pub fn lbdl(&self) -> LbdlR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdlR { bits }
            }
            # [ doc = "Bits 0:3 - Address of the USART node" ]
            # [ inline ( always ) ]
            pub fn add(&self) -> AddR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 14 - LIN mode enable" ]
            # [ inline ( always ) ]
            pub fn linen(&mut self) -> _LinenW {
                _LinenW { w: self }
            }
            # [ doc = "Bits 12:13 - STOP bits" ]
            # [ inline ( always ) ]
            pub fn stop(&mut self) -> _StopW {
                _StopW { w: self }
            }
            # [ doc = "Bit 11 - Clock enable" ]
            # [ inline ( always ) ]
            pub fn clken(&mut self) -> _ClkenW {
                _ClkenW { w: self }
            }
            # [ doc = "Bit 10 - Clock polarity" ]
            # [ inline ( always ) ]
            pub fn cpol(&mut self) -> _CpolW {
                _CpolW { w: self }
            }
            # [ doc = "Bit 9 - Clock phase" ]
            # [ inline ( always ) ]
            pub fn cpha(&mut self) -> _CphaW {
                _CphaW { w: self }
            }
            # [ doc = "Bit 8 - Last bit clock pulse" ]
            # [ inline ( always ) ]
            pub fn lbcl(&mut self) -> _LbclW {
                _LbclW { w: self }
            }
            # [ doc = "Bit 6 - LIN break detection interrupt enable" ]
            # [ inline ( always ) ]
            pub fn lbdie(&mut self) -> _LbdieW {
                _LbdieW { w: self }
            }
            # [ doc = "Bit 5 - lin break detection length" ]
            # [ inline ( always ) ]
            pub fn lbdl(&mut self) -> _LbdlW {
                _LbdlW { w: self }
            }
            # [ doc = "Bits 0:3 - Address of the USART node" ]
            # [ inline ( always ) ]
            pub fn add(&mut self) -> _AddW {
                _AddW { w: self }
            }
        }
    }
    # [ doc = "Control register 3" ]
    pub struct Cr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register 3" ]
    pub mod cr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CtsieR {
            bits: u8,
        }
        impl CtsieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CtseR {
            bits: u8,
        }
        impl CtseR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtseR {
            bits: u8,
        }
        impl RtseR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmatR {
            bits: u8,
        }
        impl DmatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmarR {
            bits: u8,
        }
        impl DmarR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScenR {
            bits: u8,
        }
        impl ScenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NackR {
            bits: u8,
        }
        impl NackR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HdselR {
            bits: u8,
        }
        impl HdselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IrlpR {
            bits: u8,
        }
        impl IrlpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IrenR {
            bits: u8,
        }
        impl IrenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EieR {
            bits: u8,
        }
        impl EieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CtsieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtsieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CtseW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtseW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtseW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtseW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmatW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmarW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmarW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NackW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NackW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HdselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HdselW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IrlpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IrlpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IrenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IrenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 10 - CTS interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ctsie(&self) -> CtsieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CtsieR { bits }
            }
            # [ doc = "Bit 9 - CTS enable" ]
            # [ inline ( always ) ]
            pub fn ctse(&self) -> CtseR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CtseR { bits }
            }
            # [ doc = "Bit 8 - RTS enable" ]
            # [ inline ( always ) ]
            pub fn rtse(&self) -> RtseR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RtseR { bits }
            }
            # [ doc = "Bit 7 - DMA enable transmitter" ]
            # [ inline ( always ) ]
            pub fn dmat(&self) -> DmatR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DmatR { bits }
            }
            # [ doc = "Bit 6 - DMA enable receiver" ]
            # [ inline ( always ) ]
            pub fn dmar(&self) -> DmarR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DmarR { bits }
            }
            # [ doc = "Bit 5 - Smartcard mode enable" ]
            # [ inline ( always ) ]
            pub fn scen(&self) -> ScenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ScenR { bits }
            }
            # [ doc = "Bit 4 - Smartcard NACK enable" ]
            # [ inline ( always ) ]
            pub fn nack(&self) -> NackR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NackR { bits }
            }
            # [ doc = "Bit 3 - Half-duplex selection" ]
            # [ inline ( always ) ]
            pub fn hdsel(&self) -> HdselR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HdselR { bits }
            }
            # [ doc = "Bit 2 - IrDA low-power" ]
            # [ inline ( always ) ]
            pub fn irlp(&self) -> IrlpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IrlpR { bits }
            }
            # [ doc = "Bit 1 - IrDA mode enable" ]
            # [ inline ( always ) ]
            pub fn iren(&self) -> IrenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IrenR { bits }
            }
            # [ doc = "Bit 0 - Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn eie(&self) -> EieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 10 - CTS interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ctsie(&mut self) -> _CtsieW {
                _CtsieW { w: self }
            }
            # [ doc = "Bit 9 - CTS enable" ]
            # [ inline ( always ) ]
            pub fn ctse(&mut self) -> _CtseW {
                _CtseW { w: self }
            }
            # [ doc = "Bit 8 - RTS enable" ]
            # [ inline ( always ) ]
            pub fn rtse(&mut self) -> _RtseW {
                _RtseW { w: self }
            }
            # [ doc = "Bit 7 - DMA enable transmitter" ]
            # [ inline ( always ) ]
            pub fn dmat(&mut self) -> _DmatW {
                _DmatW { w: self }
            }
            # [ doc = "Bit 6 - DMA enable receiver" ]
            # [ inline ( always ) ]
            pub fn dmar(&mut self) -> _DmarW {
                _DmarW { w: self }
            }
            # [ doc = "Bit 5 - Smartcard mode enable" ]
            # [ inline ( always ) ]
            pub fn scen(&mut self) -> _ScenW {
                _ScenW { w: self }
            }
            # [ doc = "Bit 4 - Smartcard NACK enable" ]
            # [ inline ( always ) ]
            pub fn nack(&mut self) -> _NackW {
                _NackW { w: self }
            }
            # [ doc = "Bit 3 - Half-duplex selection" ]
            # [ inline ( always ) ]
            pub fn hdsel(&mut self) -> _HdselW {
                _HdselW { w: self }
            }
            # [ doc = "Bit 2 - IrDA low-power" ]
            # [ inline ( always ) ]
            pub fn irlp(&mut self) -> _IrlpW {
                _IrlpW { w: self }
            }
            # [ doc = "Bit 1 - IrDA mode enable" ]
            # [ inline ( always ) ]
            pub fn iren(&mut self) -> _IrenW {
                _IrenW { w: self }
            }
            # [ doc = "Bit 0 - Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn eie(&mut self) -> _EieW {
                _EieW { w: self }
            }
        }
    }
    # [ doc = "Guard time and prescaler register" ]
    pub struct Gtpr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Guard time and prescaler register" ]
    pub mod gtpr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Gtpr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct GtR {
            bits: u8,
        }
        impl GtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PscR {
            bits: u8,
        }
        impl PscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _GtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 8:15 - Guard time value" ]
            # [ inline ( always ) ]
            pub fn gt(&self) -> GtR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                GtR { bits }
            }
            # [ doc = "Bits 0:7 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PscR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 8:15 - Guard time value" ]
            # [ inline ( always ) ]
            pub fn gt(&mut self) -> _GtW {
                _GtW { w: self }
            }
            # [ doc = "Bits 0:7 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
}
# [ doc = "Universal synchronous asynchronous receiver transmitter" ]
pub struct Usart1 {
    register_block: usart1::RegisterBlock,
}
impl Deref for Usart1 {
    type Target = usart1::RegisterBlock;
    fn deref(&self) -> &usart1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "USART2" ]
pub const USART2: Peripheral<Usart2> = unsafe { Peripheral::new(1073759232) };
# [ doc = r" Register block" ]
pub struct Usart2 {
    register_block: usart1::RegisterBlock,
}
impl Deref for Usart2 {
    type Target = usart1::RegisterBlock;
    fn deref(&self) -> &usart1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "USART3" ]
pub const USART3: Peripheral<Usart3> = unsafe { Peripheral::new(1073760256) };
# [ doc = r" Register block" ]
pub struct Usart3 {
    register_block: usart1::RegisterBlock,
}
impl Deref for Usart3 {
    type Target = usart1::RegisterBlock;
    fn deref(&self) -> &usart1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Analog to digital converter" ]
pub const ADC1: Peripheral<Adc1> = unsafe { Peripheral::new(1073816576) };
# [ doc = "Analog to digital converter" ]
pub mod adc1 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - status register" ]
        pub sr: Sr,
        # [ doc = "0x04 - control register 1" ]
        pub cr1: Cr1,
        # [ doc = "0x08 - control register 2" ]
        pub cr2: Cr2,
        # [ doc = "0x0c - sample time register 1" ]
        pub smpr1: Smpr1,
        # [ doc = "0x10 - sample time register 2" ]
        pub smpr2: Smpr2,
        # [ doc = "0x14 - injected channel data offset register x" ]
        pub jofr1: Jofr1,
        # [ doc = "0x18 - injected channel data offset register x" ]
        pub jofr2: Jofr2,
        # [ doc = "0x1c - injected channel data offset register x" ]
        pub jofr3: Jofr3,
        # [ doc = "0x20 - injected channel data offset register x" ]
        pub jofr4: Jofr4,
        # [ doc = "0x24 - watchdog higher threshold register" ]
        pub htr: Htr,
        # [ doc = "0x28 - watchdog lower threshold register" ]
        pub ltr: Ltr,
        # [ doc = "0x2c - regular sequence register 1" ]
        pub sqr1: Sqr1,
        # [ doc = "0x30 - regular sequence register 2" ]
        pub sqr2: Sqr2,
        # [ doc = "0x34 - regular sequence register 3" ]
        pub sqr3: Sqr3,
        # [ doc = "0x38 - injected sequence register" ]
        pub jsqr: Jsqr,
        # [ doc = "0x3c - injected data register x" ]
        pub jdr1: Jdr1,
        # [ doc = "0x40 - injected data register x" ]
        pub jdr2: Jdr2,
        # [ doc = "0x44 - injected data register x" ]
        pub jdr3: Jdr3,
        # [ doc = "0x48 - injected data register x" ]
        pub jdr4: Jdr4,
        # [ doc = "0x4c - regular data register" ]
        pub dr: Dr,
    }
    # [ doc = "status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct StrtR {
            bits: u8,
        }
        impl StrtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JstrtR {
            bits: u8,
        }
        impl JstrtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JeocR {
            bits: u8,
        }
        impl JeocR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EocR {
            bits: u8,
        }
        impl EocR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AwdR {
            bits: u8,
        }
        impl AwdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StrtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StrtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JstrtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JstrtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JeocW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JeocW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EocW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EocW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AwdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AwdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 4 - Regular channel start flag" ]
            # [ inline ( always ) ]
            pub fn strt(&self) -> StrtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StrtR { bits }
            }
            # [ doc = "Bit 3 - Injected channel start flag" ]
            # [ inline ( always ) ]
            pub fn jstrt(&self) -> JstrtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JstrtR { bits }
            }
            # [ doc = "Bit 2 - Injected channel end of conversion" ]
            # [ inline ( always ) ]
            pub fn jeoc(&self) -> JeocR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JeocR { bits }
            }
            # [ doc = "Bit 1 - Regular channel end of conversion" ]
            # [ inline ( always ) ]
            pub fn eoc(&self) -> EocR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EocR { bits }
            }
            # [ doc = "Bit 0 - Analog watchdog flag" ]
            # [ inline ( always ) ]
            pub fn awd(&self) -> AwdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AwdR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 4 - Regular channel start flag" ]
            # [ inline ( always ) ]
            pub fn strt(&mut self) -> _StrtW {
                _StrtW { w: self }
            }
            # [ doc = "Bit 3 - Injected channel start flag" ]
            # [ inline ( always ) ]
            pub fn jstrt(&mut self) -> _JstrtW {
                _JstrtW { w: self }
            }
            # [ doc = "Bit 2 - Injected channel end of conversion" ]
            # [ inline ( always ) ]
            pub fn jeoc(&mut self) -> _JeocW {
                _JeocW { w: self }
            }
            # [ doc = "Bit 1 - Regular channel end of conversion" ]
            # [ inline ( always ) ]
            pub fn eoc(&mut self) -> _EocW {
                _EocW { w: self }
            }
            # [ doc = "Bit 0 - Analog watchdog flag" ]
            # [ inline ( always ) ]
            pub fn awd(&mut self) -> _AwdW {
                _AwdW { w: self }
            }
        }
    }
    # [ doc = "control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AwdenR {
            bits: u8,
        }
        impl AwdenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JawdenR {
            bits: u8,
        }
        impl JawdenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DiscnumR {
            bits: u8,
        }
        impl DiscnumR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JdiscenR {
            bits: u8,
        }
        impl JdiscenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DiscenR {
            bits: u8,
        }
        impl DiscenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JautoR {
            bits: u8,
        }
        impl JautoR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AwdsglR {
            bits: u8,
        }
        impl AwdsglR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScanR {
            bits: u8,
        }
        impl ScanR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JeocieR {
            bits: u8,
        }
        impl JeocieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AwdieR {
            bits: u8,
        }
        impl AwdieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EocieR {
            bits: u8,
        }
        impl EocieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AwdchR {
            bits: u8,
        }
        impl AwdchR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AwdenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AwdenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JawdenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JawdenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DiscnumW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DiscnumW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JdiscenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JdiscenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DiscenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DiscenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JautoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JautoW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AwdsglW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AwdsglW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScanW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScanW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JeocieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JeocieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AwdieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AwdieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EocieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EocieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AwdchW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AwdchW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 23 - Analog watchdog enable on regular channels" ]
            # [ inline ( always ) ]
            pub fn awden(&self) -> AwdenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AwdenR { bits }
            }
            # [ doc = "Bit 22 - Analog watchdog enable on injected channels" ]
            # [ inline ( always ) ]
            pub fn jawden(&self) -> JawdenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JawdenR { bits }
            }
            # [ doc = "Bits 13:15 - Discontinuous mode channel count" ]
            # [ inline ( always ) ]
            pub fn discnum(&self) -> DiscnumR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DiscnumR { bits }
            }
            # [ doc = "Bit 12 - Discontinuous mode on injected channels" ]
            # [ inline ( always ) ]
            pub fn jdiscen(&self) -> JdiscenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JdiscenR { bits }
            }
            # [ doc = "Bit 11 - Discontinuous mode on regular channels" ]
            # [ inline ( always ) ]
            pub fn discen(&self) -> DiscenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DiscenR { bits }
            }
            # [ doc = "Bit 10 - Automatic injected group conversion" ]
            # [ inline ( always ) ]
            pub fn jauto(&self) -> JautoR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JautoR { bits }
            }
            # [ doc = "Bit 9 - Enable the watchdog on a single channel in scan mode" ]
            # [ inline ( always ) ]
            pub fn awdsgl(&self) -> AwdsglR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AwdsglR { bits }
            }
            # [ doc = "Bit 8 - Scan mode" ]
            # [ inline ( always ) ]
            pub fn scan(&self) -> ScanR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ScanR { bits }
            }
            # [ doc = "Bit 7 - Interrupt enable for injected channels" ]
            # [ inline ( always ) ]
            pub fn jeocie(&self) -> JeocieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JeocieR { bits }
            }
            # [ doc = "Bit 6 - Analog watchdog interrupt enable" ]
            # [ inline ( always ) ]
            pub fn awdie(&self) -> AwdieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AwdieR { bits }
            }
            # [ doc = "Bit 5 - Interrupt enable for EOC" ]
            # [ inline ( always ) ]
            pub fn eocie(&self) -> EocieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EocieR { bits }
            }
            # [ doc = "Bits 0:4 - Analog watchdog channel select bits" ]
            # [ inline ( always ) ]
            pub fn awdch(&self) -> AwdchR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AwdchR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 23 - Analog watchdog enable on regular channels" ]
            # [ inline ( always ) ]
            pub fn awden(&mut self) -> _AwdenW {
                _AwdenW { w: self }
            }
            # [ doc = "Bit 22 - Analog watchdog enable on injected channels" ]
            # [ inline ( always ) ]
            pub fn jawden(&mut self) -> _JawdenW {
                _JawdenW { w: self }
            }
            # [ doc = "Bits 13:15 - Discontinuous mode channel count" ]
            # [ inline ( always ) ]
            pub fn discnum(&mut self) -> _DiscnumW {
                _DiscnumW { w: self }
            }
            # [ doc = "Bit 12 - Discontinuous mode on injected channels" ]
            # [ inline ( always ) ]
            pub fn jdiscen(&mut self) -> _JdiscenW {
                _JdiscenW { w: self }
            }
            # [ doc = "Bit 11 - Discontinuous mode on regular channels" ]
            # [ inline ( always ) ]
            pub fn discen(&mut self) -> _DiscenW {
                _DiscenW { w: self }
            }
            # [ doc = "Bit 10 - Automatic injected group conversion" ]
            # [ inline ( always ) ]
            pub fn jauto(&mut self) -> _JautoW {
                _JautoW { w: self }
            }
            # [ doc = "Bit 9 - Enable the watchdog on a single channel in scan mode" ]
            # [ inline ( always ) ]
            pub fn awdsgl(&mut self) -> _AwdsglW {
                _AwdsglW { w: self }
            }
            # [ doc = "Bit 8 - Scan mode" ]
            # [ inline ( always ) ]
            pub fn scan(&mut self) -> _ScanW {
                _ScanW { w: self }
            }
            # [ doc = "Bit 7 - Interrupt enable for injected channels" ]
            # [ inline ( always ) ]
            pub fn jeocie(&mut self) -> _JeocieW {
                _JeocieW { w: self }
            }
            # [ doc = "Bit 6 - Analog watchdog interrupt enable" ]
            # [ inline ( always ) ]
            pub fn awdie(&mut self) -> _AwdieW {
                _AwdieW { w: self }
            }
            # [ doc = "Bit 5 - Interrupt enable for EOC" ]
            # [ inline ( always ) ]
            pub fn eocie(&mut self) -> _EocieW {
                _EocieW { w: self }
            }
            # [ doc = "Bits 0:4 - Analog watchdog channel select bits" ]
            # [ inline ( always ) ]
            pub fn awdch(&mut self) -> _AwdchW {
                _AwdchW { w: self }
            }
        }
    }
    # [ doc = "control register 2" ]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 2" ]
    pub mod cr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TsvrefeR {
            bits: u8,
        }
        impl TsvrefeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SwstartR {
            bits: u8,
        }
        impl SwstartR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JswstartR {
            bits: u8,
        }
        impl JswstartR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ExttrigR {
            bits: u8,
        }
        impl ExttrigR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ExtselR {
            bits: u8,
        }
        impl ExtselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JexttrigR {
            bits: u8,
        }
        impl JexttrigR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JextselR {
            bits: u8,
        }
        impl JextselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AlignR {
            bits: u8,
        }
        impl AlignR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaR {
            bits: u8,
        }
        impl DmaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RstcalR {
            bits: u8,
        }
        impl RstcalR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CalR {
            bits: u8,
        }
        impl CalR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ContR {
            bits: u8,
        }
        impl ContR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AdonR {
            bits: u8,
        }
        impl AdonR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TsvrefeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsvrefeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SwstartW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SwstartW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JswstartW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JswstartW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ExttrigW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ExttrigW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ExtselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ExtselW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JexttrigW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JexttrigW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JextselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JextselW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AlignW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AlignW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RstcalW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RstcalW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CalW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CalW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ContW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ContW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AdonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdonW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 23 - Temperature sensor and VREFINT enable" ]
            # [ inline ( always ) ]
            pub fn tsvrefe(&self) -> TsvrefeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsvrefeR { bits }
            }
            # [ doc = "Bit 22 - Start conversion of regular channels" ]
            # [ inline ( always ) ]
            pub fn swstart(&self) -> SwstartR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SwstartR { bits }
            }
            # [ doc = "Bit 21 - Start conversion of injected channels" ]
            # [ inline ( always ) ]
            pub fn jswstart(&self) -> JswstartR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JswstartR { bits }
            }
            # [ doc = "Bit 20 - External trigger conversion mode for regular channels" ]
            # [ inline ( always ) ]
            pub fn exttrig(&self) -> ExttrigR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ExttrigR { bits }
            }
            # [ doc = "Bits 17:19 - External event select for regular group" ]
            # [ inline ( always ) ]
            pub fn extsel(&self) -> ExtselR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ExtselR { bits }
            }
            # [ doc = "Bit 15 - External trigger conversion mode for injected channels" ]
            # [ inline ( always ) ]
            pub fn jexttrig(&self) -> JexttrigR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JexttrigR { bits }
            }
            # [ doc = "Bits 12:14 - External event select for injected group" ]
            # [ inline ( always ) ]
            pub fn jextsel(&self) -> JextselR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JextselR { bits }
            }
            # [ doc = "Bit 11 - Data alignment" ]
            # [ inline ( always ) ]
            pub fn align(&self) -> AlignR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AlignR { bits }
            }
            # [ doc = "Bit 8 - Direct memory access mode" ]
            # [ inline ( always ) ]
            pub fn dma(&self) -> DmaR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DmaR { bits }
            }
            # [ doc = "Bit 3 - Reset calibration" ]
            # [ inline ( always ) ]
            pub fn rstcal(&self) -> RstcalR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RstcalR { bits }
            }
            # [ doc = "Bit 2 - A/D calibration" ]
            # [ inline ( always ) ]
            pub fn cal(&self) -> CalR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CalR { bits }
            }
            # [ doc = "Bit 1 - Continuous conversion" ]
            # [ inline ( always ) ]
            pub fn cont(&self) -> ContR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ContR { bits }
            }
            # [ doc = "Bit 0 - A/D converter ON / OFF" ]
            # [ inline ( always ) ]
            pub fn adon(&self) -> AdonR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AdonR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 23 - Temperature sensor and VREFINT enable" ]
            # [ inline ( always ) ]
            pub fn tsvrefe(&mut self) -> _TsvrefeW {
                _TsvrefeW { w: self }
            }
            # [ doc = "Bit 22 - Start conversion of regular channels" ]
            # [ inline ( always ) ]
            pub fn swstart(&mut self) -> _SwstartW {
                _SwstartW { w: self }
            }
            # [ doc = "Bit 21 - Start conversion of injected channels" ]
            # [ inline ( always ) ]
            pub fn jswstart(&mut self) -> _JswstartW {
                _JswstartW { w: self }
            }
            # [ doc = "Bit 20 - External trigger conversion mode for regular channels" ]
            # [ inline ( always ) ]
            pub fn exttrig(&mut self) -> _ExttrigW {
                _ExttrigW { w: self }
            }
            # [ doc = "Bits 17:19 - External event select for regular group" ]
            # [ inline ( always ) ]
            pub fn extsel(&mut self) -> _ExtselW {
                _ExtselW { w: self }
            }
            # [ doc = "Bit 15 - External trigger conversion mode for injected channels" ]
            # [ inline ( always ) ]
            pub fn jexttrig(&mut self) -> _JexttrigW {
                _JexttrigW { w: self }
            }
            # [ doc = "Bits 12:14 - External event select for injected group" ]
            # [ inline ( always ) ]
            pub fn jextsel(&mut self) -> _JextselW {
                _JextselW { w: self }
            }
            # [ doc = "Bit 11 - Data alignment" ]
            # [ inline ( always ) ]
            pub fn align(&mut self) -> _AlignW {
                _AlignW { w: self }
            }
            # [ doc = "Bit 8 - Direct memory access mode" ]
            # [ inline ( always ) ]
            pub fn dma(&mut self) -> _DmaW {
                _DmaW { w: self }
            }
            # [ doc = "Bit 3 - Reset calibration" ]
            # [ inline ( always ) ]
            pub fn rstcal(&mut self) -> _RstcalW {
                _RstcalW { w: self }
            }
            # [ doc = "Bit 2 - A/D calibration" ]
            # [ inline ( always ) ]
            pub fn cal(&mut self) -> _CalW {
                _CalW { w: self }
            }
            # [ doc = "Bit 1 - Continuous conversion" ]
            # [ inline ( always ) ]
            pub fn cont(&mut self) -> _ContW {
                _ContW { w: self }
            }
            # [ doc = "Bit 0 - A/D converter ON / OFF" ]
            # [ inline ( always ) ]
            pub fn adon(&mut self) -> _AdonW {
                _AdonW { w: self }
            }
        }
    }
    # [ doc = "sample time register 1" ]
    pub struct Smpr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "sample time register 1" ]
    pub mod smpr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Smpr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp10R {
            bits: u8,
        }
        impl Smp10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp11R {
            bits: u8,
        }
        impl Smp11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp12R {
            bits: u8,
        }
        impl Smp12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp13R {
            bits: u8,
        }
        impl Smp13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp14R {
            bits: u8,
        }
        impl Smp14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp15R {
            bits: u8,
        }
        impl Smp15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp16R {
            bits: u8,
        }
        impl Smp16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp17R {
            bits: u8,
        }
        impl Smp17R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp16W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp17W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Channel 10 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp10(&self) -> Smp10R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp10R { bits }
            }
            # [ doc = "Bits 3:5 - Channel 11 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp11(&self) -> Smp11R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp11R { bits }
            }
            # [ doc = "Bits 6:8 - Channel 12 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp12(&self) -> Smp12R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp12R { bits }
            }
            # [ doc = "Bits 9:11 - Channel 13 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp13(&self) -> Smp13R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp13R { bits }
            }
            # [ doc = "Bits 12:14 - Channel 14 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp14(&self) -> Smp14R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp14R { bits }
            }
            # [ doc = "Bits 15:17 - Channel 15 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp15(&self) -> Smp15R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp15R { bits }
            }
            # [ doc = "Bits 18:20 - Channel 16 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp16(&self) -> Smp16R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp16R { bits }
            }
            # [ doc = "Bits 21:23 - Channel 17 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp17(&self) -> Smp17R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp17R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:2 - Channel 10 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp10(&mut self) -> _Smp10W {
                _Smp10W { w: self }
            }
            # [ doc = "Bits 3:5 - Channel 11 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp11(&mut self) -> _Smp11W {
                _Smp11W { w: self }
            }
            # [ doc = "Bits 6:8 - Channel 12 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp12(&mut self) -> _Smp12W {
                _Smp12W { w: self }
            }
            # [ doc = "Bits 9:11 - Channel 13 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp13(&mut self) -> _Smp13W {
                _Smp13W { w: self }
            }
            # [ doc = "Bits 12:14 - Channel 14 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp14(&mut self) -> _Smp14W {
                _Smp14W { w: self }
            }
            # [ doc = "Bits 15:17 - Channel 15 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp15(&mut self) -> _Smp15W {
                _Smp15W { w: self }
            }
            # [ doc = "Bits 18:20 - Channel 16 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp16(&mut self) -> _Smp16W {
                _Smp16W { w: self }
            }
            # [ doc = "Bits 21:23 - Channel 17 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp17(&mut self) -> _Smp17W {
                _Smp17W { w: self }
            }
        }
    }
    # [ doc = "sample time register 2" ]
    pub struct Smpr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "sample time register 2" ]
    pub mod smpr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Smpr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp0R {
            bits: u8,
        }
        impl Smp0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp1R {
            bits: u8,
        }
        impl Smp1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp2R {
            bits: u8,
        }
        impl Smp2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp3R {
            bits: u8,
        }
        impl Smp3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp4R {
            bits: u8,
        }
        impl Smp4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp5R {
            bits: u8,
        }
        impl Smp5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp6R {
            bits: u8,
        }
        impl Smp6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp7R {
            bits: u8,
        }
        impl Smp7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp8R {
            bits: u8,
        }
        impl Smp8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Smp9R {
            bits: u8,
        }
        impl Smp9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Smp9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Smp9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:2 - Channel 0 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp0(&self) -> Smp0R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp0R { bits }
            }
            # [ doc = "Bits 3:5 - Channel 1 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp1(&self) -> Smp1R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp1R { bits }
            }
            # [ doc = "Bits 6:8 - Channel 2 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp2(&self) -> Smp2R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp2R { bits }
            }
            # [ doc = "Bits 9:11 - Channel 3 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp3(&self) -> Smp3R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp3R { bits }
            }
            # [ doc = "Bits 12:14 - Channel 4 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp4(&self) -> Smp4R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp4R { bits }
            }
            # [ doc = "Bits 15:17 - Channel 5 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp5(&self) -> Smp5R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp5R { bits }
            }
            # [ doc = "Bits 18:20 - Channel 6 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp6(&self) -> Smp6R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp6R { bits }
            }
            # [ doc = "Bits 21:23 - Channel 7 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp7(&self) -> Smp7R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp7R { bits }
            }
            # [ doc = "Bits 24:26 - Channel 8 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp8(&self) -> Smp8R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp8R { bits }
            }
            # [ doc = "Bits 27:29 - Channel 9 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp9(&self) -> Smp9R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Smp9R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:2 - Channel 0 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp0(&mut self) -> _Smp0W {
                _Smp0W { w: self }
            }
            # [ doc = "Bits 3:5 - Channel 1 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp1(&mut self) -> _Smp1W {
                _Smp1W { w: self }
            }
            # [ doc = "Bits 6:8 - Channel 2 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp2(&mut self) -> _Smp2W {
                _Smp2W { w: self }
            }
            # [ doc = "Bits 9:11 - Channel 3 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp3(&mut self) -> _Smp3W {
                _Smp3W { w: self }
            }
            # [ doc = "Bits 12:14 - Channel 4 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp4(&mut self) -> _Smp4W {
                _Smp4W { w: self }
            }
            # [ doc = "Bits 15:17 - Channel 5 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp5(&mut self) -> _Smp5W {
                _Smp5W { w: self }
            }
            # [ doc = "Bits 18:20 - Channel 6 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp6(&mut self) -> _Smp6W {
                _Smp6W { w: self }
            }
            # [ doc = "Bits 21:23 - Channel 7 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp7(&mut self) -> _Smp7W {
                _Smp7W { w: self }
            }
            # [ doc = "Bits 24:26 - Channel 8 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp8(&mut self) -> _Smp8W {
                _Smp8W { w: self }
            }
            # [ doc = "Bits 27:29 - Channel 9 sample time selection" ]
            # [ inline ( always ) ]
            pub fn smp9(&mut self) -> _Smp9W {
                _Smp9W { w: self }
            }
        }
    }
    # [ doc = "injected channel data offset register x" ]
    pub struct Jofr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "injected channel data offset register x" ]
    pub mod jofr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Jofr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Joffset1R {
            bits: u16,
        }
        impl Joffset1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Joffset1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Joffset1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - Data offset for injected channel 1" ]
            # [ inline ( always ) ]
            pub fn joffset1(&self) -> Joffset1R {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Joffset1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:11 - Data offset for injected channel 1" ]
            # [ inline ( always ) ]
            pub fn joffset1(&mut self) -> _Joffset1W {
                _Joffset1W { w: self }
            }
        }
    }
    # [ doc = "injected channel data offset register x" ]
    pub struct Jofr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "injected channel data offset register x" ]
    pub mod jofr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Jofr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Joffset2R {
            bits: u16,
        }
        impl Joffset2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Joffset2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Joffset2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - Data offset for injected channel 2" ]
            # [ inline ( always ) ]
            pub fn joffset2(&self) -> Joffset2R {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Joffset2R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:11 - Data offset for injected channel 2" ]
            # [ inline ( always ) ]
            pub fn joffset2(&mut self) -> _Joffset2W {
                _Joffset2W { w: self }
            }
        }
    }
    # [ doc = "injected channel data offset register x" ]
    pub struct Jofr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "injected channel data offset register x" ]
    pub mod jofr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Jofr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Joffset3R {
            bits: u16,
        }
        impl Joffset3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Joffset3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Joffset3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - Data offset for injected channel 3" ]
            # [ inline ( always ) ]
            pub fn joffset3(&self) -> Joffset3R {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Joffset3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:11 - Data offset for injected channel 3" ]
            # [ inline ( always ) ]
            pub fn joffset3(&mut self) -> _Joffset3W {
                _Joffset3W { w: self }
            }
        }
    }
    # [ doc = "injected channel data offset register x" ]
    pub struct Jofr4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "injected channel data offset register x" ]
    pub mod jofr4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Jofr4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Joffset4R {
            bits: u16,
        }
        impl Joffset4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Joffset4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Joffset4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - Data offset for injected channel 4" ]
            # [ inline ( always ) ]
            pub fn joffset4(&self) -> Joffset4R {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Joffset4R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:11 - Data offset for injected channel 4" ]
            # [ inline ( always ) ]
            pub fn joffset4(&mut self) -> _Joffset4W {
                _Joffset4W { w: self }
            }
        }
    }
    # [ doc = "watchdog higher threshold register" ]
    pub struct Htr {
        register: VolatileCell<u32>,
    }
    # [ doc = "watchdog higher threshold register" ]
    pub mod htr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Htr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HtR {
            bits: u16,
        }
        impl HtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - Analog watchdog higher threshold" ]
            # [ inline ( always ) ]
            pub fn ht(&self) -> HtR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                HtR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4095 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:11 - Analog watchdog higher threshold" ]
            # [ inline ( always ) ]
            pub fn ht(&mut self) -> _HtW {
                _HtW { w: self }
            }
        }
    }
    # [ doc = "watchdog lower threshold register" ]
    pub struct Ltr {
        register: VolatileCell<u32>,
    }
    # [ doc = "watchdog lower threshold register" ]
    pub mod ltr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ltr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LtR {
            bits: u16,
        }
        impl LtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - Analog watchdog lower threshold" ]
            # [ inline ( always ) ]
            pub fn lt(&self) -> LtR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                LtR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:11 - Analog watchdog lower threshold" ]
            # [ inline ( always ) ]
            pub fn lt(&mut self) -> _LtW {
                _LtW { w: self }
            }
        }
    }
    # [ doc = "regular sequence register 1" ]
    pub struct Sqr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "regular sequence register 1" ]
    pub mod sqr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sqr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LR {
            bits: u8,
        }
        impl LR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq16R {
            bits: u8,
        }
        impl Sq16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq15R {
            bits: u8,
        }
        impl Sq15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq14R {
            bits: u8,
        }
        impl Sq14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq13R {
            bits: u8,
        }
        impl Sq13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq16W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 20:23 - Regular channel sequence length" ]
            # [ inline ( always ) ]
            pub fn l(&self) -> LR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LR { bits }
            }
            # [ doc = "Bits 15:19 - 16th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq16(&self) -> Sq16R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq16R { bits }
            }
            # [ doc = "Bits 10:14 - 15th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq15(&self) -> Sq15R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq15R { bits }
            }
            # [ doc = "Bits 5:9 - 14th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq14(&self) -> Sq14R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq14R { bits }
            }
            # [ doc = "Bits 0:4 - 13th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq13(&self) -> Sq13R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq13R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 20:23 - Regular channel sequence length" ]
            # [ inline ( always ) ]
            pub fn l(&mut self) -> _LW {
                _LW { w: self }
            }
            # [ doc = "Bits 15:19 - 16th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq16(&mut self) -> _Sq16W {
                _Sq16W { w: self }
            }
            # [ doc = "Bits 10:14 - 15th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq15(&mut self) -> _Sq15W {
                _Sq15W { w: self }
            }
            # [ doc = "Bits 5:9 - 14th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq14(&mut self) -> _Sq14W {
                _Sq14W { w: self }
            }
            # [ doc = "Bits 0:4 - 13th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq13(&mut self) -> _Sq13W {
                _Sq13W { w: self }
            }
        }
    }
    # [ doc = "regular sequence register 2" ]
    pub struct Sqr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "regular sequence register 2" ]
    pub mod sqr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sqr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq12R {
            bits: u8,
        }
        impl Sq12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq11R {
            bits: u8,
        }
        impl Sq11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq10R {
            bits: u8,
        }
        impl Sq10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq9R {
            bits: u8,
        }
        impl Sq9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq8R {
            bits: u8,
        }
        impl Sq8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq7R {
            bits: u8,
        }
        impl Sq7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 25:29 - 12th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq12(&self) -> Sq12R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq12R { bits }
            }
            # [ doc = "Bits 20:24 - 11th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq11(&self) -> Sq11R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq11R { bits }
            }
            # [ doc = "Bits 15:19 - 10th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq10(&self) -> Sq10R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq10R { bits }
            }
            # [ doc = "Bits 10:14 - 9th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq9(&self) -> Sq9R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq9R { bits }
            }
            # [ doc = "Bits 5:9 - 8th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq8(&self) -> Sq8R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq8R { bits }
            }
            # [ doc = "Bits 0:4 - 7th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq7(&self) -> Sq7R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 25:29 - 12th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq12(&mut self) -> _Sq12W {
                _Sq12W { w: self }
            }
            # [ doc = "Bits 20:24 - 11th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq11(&mut self) -> _Sq11W {
                _Sq11W { w: self }
            }
            # [ doc = "Bits 15:19 - 10th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq10(&mut self) -> _Sq10W {
                _Sq10W { w: self }
            }
            # [ doc = "Bits 10:14 - 9th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq9(&mut self) -> _Sq9W {
                _Sq9W { w: self }
            }
            # [ doc = "Bits 5:9 - 8th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq8(&mut self) -> _Sq8W {
                _Sq8W { w: self }
            }
            # [ doc = "Bits 0:4 - 7th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq7(&mut self) -> _Sq7W {
                _Sq7W { w: self }
            }
        }
    }
    # [ doc = "regular sequence register 3" ]
    pub struct Sqr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "regular sequence register 3" ]
    pub mod sqr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sqr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq6R {
            bits: u8,
        }
        impl Sq6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq5R {
            bits: u8,
        }
        impl Sq5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq4R {
            bits: u8,
        }
        impl Sq4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq3R {
            bits: u8,
        }
        impl Sq3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq2R {
            bits: u8,
        }
        impl Sq2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sq1R {
            bits: u8,
        }
        impl Sq1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sq1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sq1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 25:29 - 6th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq6(&self) -> Sq6R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq6R { bits }
            }
            # [ doc = "Bits 20:24 - 5th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq5(&self) -> Sq5R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq5R { bits }
            }
            # [ doc = "Bits 15:19 - 4th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq4(&self) -> Sq4R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq4R { bits }
            }
            # [ doc = "Bits 10:14 - 3rd conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq3(&self) -> Sq3R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq3R { bits }
            }
            # [ doc = "Bits 5:9 - 2nd conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq2(&self) -> Sq2R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq2R { bits }
            }
            # [ doc = "Bits 0:4 - 1st conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq1(&self) -> Sq1R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sq1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 25:29 - 6th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq6(&mut self) -> _Sq6W {
                _Sq6W { w: self }
            }
            # [ doc = "Bits 20:24 - 5th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq5(&mut self) -> _Sq5W {
                _Sq5W { w: self }
            }
            # [ doc = "Bits 15:19 - 4th conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq4(&mut self) -> _Sq4W {
                _Sq4W { w: self }
            }
            # [ doc = "Bits 10:14 - 3rd conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq3(&mut self) -> _Sq3W {
                _Sq3W { w: self }
            }
            # [ doc = "Bits 5:9 - 2nd conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq2(&mut self) -> _Sq2W {
                _Sq2W { w: self }
            }
            # [ doc = "Bits 0:4 - 1st conversion in regular sequence" ]
            # [ inline ( always ) ]
            pub fn sq1(&mut self) -> _Sq1W {
                _Sq1W { w: self }
            }
        }
    }
    # [ doc = "injected sequence register" ]
    pub struct Jsqr {
        register: VolatileCell<u32>,
    }
    # [ doc = "injected sequence register" ]
    pub mod jsqr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Jsqr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JlR {
            bits: u8,
        }
        impl JlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Jsq4R {
            bits: u8,
        }
        impl Jsq4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Jsq3R {
            bits: u8,
        }
        impl Jsq3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Jsq2R {
            bits: u8,
        }
        impl Jsq2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Jsq1R {
            bits: u8,
        }
        impl Jsq1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Jsq4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Jsq4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Jsq3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Jsq3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Jsq2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Jsq2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Jsq1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Jsq1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 20:21 - Injected sequence length" ]
            # [ inline ( always ) ]
            pub fn jl(&self) -> JlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JlR { bits }
            }
            # [ doc = "Bits 15:19 - 4th conversion in injected sequence" ]
            # [ inline ( always ) ]
            pub fn jsq4(&self) -> Jsq4R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Jsq4R { bits }
            }
            # [ doc = "Bits 10:14 - 3rd conversion in injected sequence" ]
            # [ inline ( always ) ]
            pub fn jsq3(&self) -> Jsq3R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Jsq3R { bits }
            }
            # [ doc = "Bits 5:9 - 2nd conversion in injected sequence" ]
            # [ inline ( always ) ]
            pub fn jsq2(&self) -> Jsq2R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Jsq2R { bits }
            }
            # [ doc = "Bits 0:4 - 1st conversion in injected sequence" ]
            # [ inline ( always ) ]
            pub fn jsq1(&self) -> Jsq1R {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Jsq1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 20:21 - Injected sequence length" ]
            # [ inline ( always ) ]
            pub fn jl(&mut self) -> _JlW {
                _JlW { w: self }
            }
            # [ doc = "Bits 15:19 - 4th conversion in injected sequence" ]
            # [ inline ( always ) ]
            pub fn jsq4(&mut self) -> _Jsq4W {
                _Jsq4W { w: self }
            }
            # [ doc = "Bits 10:14 - 3rd conversion in injected sequence" ]
            # [ inline ( always ) ]
            pub fn jsq3(&mut self) -> _Jsq3W {
                _Jsq3W { w: self }
            }
            # [ doc = "Bits 5:9 - 2nd conversion in injected sequence" ]
            # [ inline ( always ) ]
            pub fn jsq2(&mut self) -> _Jsq2W {
                _Jsq2W { w: self }
            }
            # [ doc = "Bits 0:4 - 1st conversion in injected sequence" ]
            # [ inline ( always ) ]
            pub fn jsq1(&mut self) -> _Jsq1W {
                _Jsq1W { w: self }
            }
        }
    }
    # [ doc = "injected data register x" ]
    pub struct Jdr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "injected data register x" ]
    pub mod jdr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Jdr1 {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JdataR {
            bits: u16,
        }
        impl JdataR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Injected data" ]
            # [ inline ( always ) ]
            pub fn jdata(&self) -> JdataR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                JdataR { bits }
            }
        }
    }
    # [ doc = "injected data register x" ]
    pub struct Jdr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "injected data register x" ]
    pub mod jdr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Jdr2 {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JdataR {
            bits: u16,
        }
        impl JdataR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Injected data" ]
            # [ inline ( always ) ]
            pub fn jdata(&self) -> JdataR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                JdataR { bits }
            }
        }
    }
    # [ doc = "injected data register x" ]
    pub struct Jdr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "injected data register x" ]
    pub mod jdr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Jdr3 {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JdataR {
            bits: u16,
        }
        impl JdataR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Injected data" ]
            # [ inline ( always ) ]
            pub fn jdata(&self) -> JdataR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                JdataR { bits }
            }
        }
    }
    # [ doc = "injected data register x" ]
    pub struct Jdr4 {
        register: VolatileCell<u32>,
    }
    # [ doc = "injected data register x" ]
    pub mod jdr4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Jdr4 {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JdataR {
            bits: u16,
        }
        impl JdataR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Injected data" ]
            # [ inline ( always ) ]
            pub fn jdata(&self) -> JdataR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                JdataR { bits }
            }
        }
    }
    # [ doc = "regular data register" ]
    pub struct Dr {
        register: VolatileCell<u32>,
    }
    # [ doc = "regular data register" ]
    pub mod dr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Dr {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DataR {
            bits: u16,
        }
        impl DataR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Regular data" ]
            # [ inline ( always ) ]
            pub fn data(&self) -> DataR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DataR { bits }
            }
        }
    }
}
# [ doc = "Analog to digital converter" ]
pub struct Adc1 {
    register_block: adc1::RegisterBlock,
}
impl Deref for Adc1 {
    type Target = adc1::RegisterBlock;
    fn deref(&self) -> &adc1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Digital to analog converter" ]
pub const DAC: Peripheral<Dac> = unsafe { Peripheral::new(1073771520) };
# [ doc = "Digital to analog converter" ]
pub mod dac {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Control register (DAC_CR)" ]
        pub cr: Cr,
        # [ doc = "0x04 - DAC software trigger register (DAC_SWTRIGR)" ]
        pub swtrigr: Swtrigr,
        # [ doc = "0x08 - DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)" ]
        pub dhr12r1: Dhr12r1,
        # [ doc = "0x0c - DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)" ]
        pub dhr12l1: Dhr12l1,
        # [ doc = "0x10 - DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)" ]
        pub dhr8r1: Dhr8r1,
        # [ doc = "0x14 - DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)" ]
        pub dhr12r2: Dhr12r2,
        # [ doc = "0x18 - DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)" ]
        pub dhr12l2: Dhr12l2,
        # [ doc = "0x1c - DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)" ]
        pub dhr8r2: Dhr8r2,
        # [ doc = "0x20 - Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved" ]
        pub dhr12rd: Dhr12rd,
        # [ doc = "0x24 - DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved" ]
        pub dhr12ld: Dhr12ld,
        # [ doc = "0x28 - DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved" ]
        pub dhr8rd: Dhr8rd,
        # [ doc = "0x2c - DAC channel1 data output register (DAC_DOR1)" ]
        pub dor1: Dor1,
        # [ doc = "0x30 - DAC channel2 data output register (DAC_DOR2)" ]
        pub dor2: Dor2,
        # [ doc = "0x34 - DAC status register" ]
        pub sr: Sr,
    }
    # [ doc = "Control register (DAC_CR)" ]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register (DAC_CR)" ]
    pub mod cr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct En1R {
            bits: u8,
        }
        impl En1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Boff1R {
            bits: u8,
        }
        impl Boff1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ten1R {
            bits: u8,
        }
        impl Ten1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tsel1R {
            bits: u8,
        }
        impl Tsel1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Wave1R {
            bits: u8,
        }
        impl Wave1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mamp1R {
            bits: u8,
        }
        impl Mamp1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dmaen1R {
            bits: u8,
        }
        impl Dmaen1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct En2R {
            bits: u8,
        }
        impl En2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Boff2R {
            bits: u8,
        }
        impl Boff2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ten2R {
            bits: u8,
        }
        impl Ten2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Tsel2R {
            bits: u8,
        }
        impl Tsel2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Wave2R {
            bits: u8,
        }
        impl Wave2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mamp2R {
            bits: u8,
        }
        impl Mamp2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dmaen2R {
            bits: u8,
        }
        impl Dmaen2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dmaudrie1R {
            bits: u8,
        }
        impl Dmaudrie1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dmaudrie2R {
            bits: u8,
        }
        impl Dmaudrie2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _En1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _En1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Boff1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Boff1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ten1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ten1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tsel1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tsel1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Wave1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Wave1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mamp1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mamp1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dmaen1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dmaen1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _En2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _En2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Boff2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Boff2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ten2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ten2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Tsel2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tsel2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Wave2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Wave2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mamp2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mamp2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dmaen2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dmaen2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dmaudrie1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dmaudrie1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dmaudrie2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dmaudrie2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - DAC channel1 enable" ]
            # [ inline ( always ) ]
            pub fn en1(&self) -> En1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                En1R { bits }
            }
            # [ doc = "Bit 1 - DAC channel1 output buffer disable" ]
            # [ inline ( always ) ]
            pub fn boff1(&self) -> Boff1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Boff1R { bits }
            }
            # [ doc = "Bit 2 - DAC channel1 trigger enable" ]
            # [ inline ( always ) ]
            pub fn ten1(&self) -> Ten1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ten1R { bits }
            }
            # [ doc = "Bits 3:5 - DAC channel1 trigger selection" ]
            # [ inline ( always ) ]
            pub fn tsel1(&self) -> Tsel1R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tsel1R { bits }
            }
            # [ doc = "Bits 6:7 - DAC channel1 noise/triangle wave generation enable" ]
            # [ inline ( always ) ]
            pub fn wave1(&self) -> Wave1R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Wave1R { bits }
            }
            # [ doc = "Bits 8:11 - DAC channel1 mask/amplitude selector" ]
            # [ inline ( always ) ]
            pub fn mamp1(&self) -> Mamp1R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mamp1R { bits }
            }
            # [ doc = "Bit 12 - DAC channel1 DMA enable" ]
            # [ inline ( always ) ]
            pub fn dmaen1(&self) -> Dmaen1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dmaen1R { bits }
            }
            # [ doc = "Bit 16 - DAC channel2 enable" ]
            # [ inline ( always ) ]
            pub fn en2(&self) -> En2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                En2R { bits }
            }
            # [ doc = "Bit 17 - DAC channel2 output buffer disable" ]
            # [ inline ( always ) ]
            pub fn boff2(&self) -> Boff2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Boff2R { bits }
            }
            # [ doc = "Bit 18 - DAC channel2 trigger enable" ]
            # [ inline ( always ) ]
            pub fn ten2(&self) -> Ten2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ten2R { bits }
            }
            # [ doc = "Bits 19:21 - DAC channel2 trigger selection" ]
            # [ inline ( always ) ]
            pub fn tsel2(&self) -> Tsel2R {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tsel2R { bits }
            }
            # [ doc = "Bits 22:23 - DAC channel2 noise/triangle wave generation enable" ]
            # [ inline ( always ) ]
            pub fn wave2(&self) -> Wave2R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Wave2R { bits }
            }
            # [ doc = "Bits 24:27 - DAC channel2 mask/amplitude selector" ]
            # [ inline ( always ) ]
            pub fn mamp2(&self) -> Mamp2R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mamp2R { bits }
            }
            # [ doc = "Bit 28 - DAC channel2 DMA enable" ]
            # [ inline ( always ) ]
            pub fn dmaen2(&self) -> Dmaen2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dmaen2R { bits }
            }
            # [ doc = "Bit 13 - DAC channel1 DMA underrun interrupt enable" ]
            # [ inline ( always ) ]
            pub fn dmaudrie1(&self) -> Dmaudrie1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dmaudrie1R { bits }
            }
            # [ doc = "Bit 29 - DAC channel2 DMA underrun interrupt enable" ]
            # [ inline ( always ) ]
            pub fn dmaudrie2(&self) -> Dmaudrie2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dmaudrie2R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - DAC channel1 enable" ]
            # [ inline ( always ) ]
            pub fn en1(&mut self) -> _En1W {
                _En1W { w: self }
            }
            # [ doc = "Bit 1 - DAC channel1 output buffer disable" ]
            # [ inline ( always ) ]
            pub fn boff1(&mut self) -> _Boff1W {
                _Boff1W { w: self }
            }
            # [ doc = "Bit 2 - DAC channel1 trigger enable" ]
            # [ inline ( always ) ]
            pub fn ten1(&mut self) -> _Ten1W {
                _Ten1W { w: self }
            }
            # [ doc = "Bits 3:5 - DAC channel1 trigger selection" ]
            # [ inline ( always ) ]
            pub fn tsel1(&mut self) -> _Tsel1W {
                _Tsel1W { w: self }
            }
            # [ doc = "Bits 6:7 - DAC channel1 noise/triangle wave generation enable" ]
            # [ inline ( always ) ]
            pub fn wave1(&mut self) -> _Wave1W {
                _Wave1W { w: self }
            }
            # [ doc = "Bits 8:11 - DAC channel1 mask/amplitude selector" ]
            # [ inline ( always ) ]
            pub fn mamp1(&mut self) -> _Mamp1W {
                _Mamp1W { w: self }
            }
            # [ doc = "Bit 12 - DAC channel1 DMA enable" ]
            # [ inline ( always ) ]
            pub fn dmaen1(&mut self) -> _Dmaen1W {
                _Dmaen1W { w: self }
            }
            # [ doc = "Bit 16 - DAC channel2 enable" ]
            # [ inline ( always ) ]
            pub fn en2(&mut self) -> _En2W {
                _En2W { w: self }
            }
            # [ doc = "Bit 17 - DAC channel2 output buffer disable" ]
            # [ inline ( always ) ]
            pub fn boff2(&mut self) -> _Boff2W {
                _Boff2W { w: self }
            }
            # [ doc = "Bit 18 - DAC channel2 trigger enable" ]
            # [ inline ( always ) ]
            pub fn ten2(&mut self) -> _Ten2W {
                _Ten2W { w: self }
            }
            # [ doc = "Bits 19:21 - DAC channel2 trigger selection" ]
            # [ inline ( always ) ]
            pub fn tsel2(&mut self) -> _Tsel2W {
                _Tsel2W { w: self }
            }
            # [ doc = "Bits 22:23 - DAC channel2 noise/triangle wave generation enable" ]
            # [ inline ( always ) ]
            pub fn wave2(&mut self) -> _Wave2W {
                _Wave2W { w: self }
            }
            # [ doc = "Bits 24:27 - DAC channel2 mask/amplitude selector" ]
            # [ inline ( always ) ]
            pub fn mamp2(&mut self) -> _Mamp2W {
                _Mamp2W { w: self }
            }
            # [ doc = "Bit 28 - DAC channel2 DMA enable" ]
            # [ inline ( always ) ]
            pub fn dmaen2(&mut self) -> _Dmaen2W {
                _Dmaen2W { w: self }
            }
            # [ doc = "Bit 13 - DAC channel1 DMA underrun interrupt enable" ]
            # [ inline ( always ) ]
            pub fn dmaudrie1(&mut self) -> _Dmaudrie1W {
                _Dmaudrie1W { w: self }
            }
            # [ doc = "Bit 29 - DAC channel2 DMA underrun interrupt enable" ]
            # [ inline ( always ) ]
            pub fn dmaudrie2(&mut self) -> _Dmaudrie2W {
                _Dmaudrie2W { w: self }
            }
        }
    }
    # [ doc = "DAC software trigger register (DAC_SWTRIGR)" ]
    pub struct Swtrigr {
        register: VolatileCell<u32>,
    }
    # [ doc = "DAC software trigger register (DAC_SWTRIGR)" ]
    pub mod swtrigr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Swtrigr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swtrig1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swtrig1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Swtrig2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swtrig2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - DAC channel1 software trigger" ]
            # [ inline ( always ) ]
            pub fn swtrig1(&mut self) -> _Swtrig1W {
                _Swtrig1W { w: self }
            }
            # [ doc = "Bit 1 - DAC channel2 software trigger" ]
            # [ inline ( always ) ]
            pub fn swtrig2(&mut self) -> _Swtrig2W {
                _Swtrig2W { w: self }
            }
        }
    }
    # [ doc = "DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)" ]
    pub struct Dhr12r1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)" ]
    pub mod dhr12r1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dhr12r1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc1dhrR {
            bits: u16,
        }
        impl Dacc1dhrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dacc1dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc1dhrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc1dhr(&self) -> Dacc1dhrR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc1dhrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc1dhr(&mut self) -> _Dacc1dhrW {
                _Dacc1dhrW { w: self }
            }
        }
    }
    # [ doc = "DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)" ]
    pub struct Dhr12l1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)" ]
    pub mod dhr12l1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dhr12l1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc1dhrR {
            bits: u16,
        }
        impl Dacc1dhrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dacc1dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc1dhrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc1dhr(&self) -> Dacc1dhrR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc1dhrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc1dhr(&mut self) -> _Dacc1dhrW {
                _Dacc1dhrW { w: self }
            }
        }
    }
    # [ doc = "DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)" ]
    pub struct Dhr8r1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)" ]
    pub mod dhr8r1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dhr8r1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc1dhrR {
            bits: u8,
        }
        impl Dacc1dhrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dacc1dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc1dhrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc1dhr(&self) -> Dacc1dhrR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dacc1dhrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc1dhr(&mut self) -> _Dacc1dhrW {
                _Dacc1dhrW { w: self }
            }
        }
    }
    # [ doc = "DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)" ]
    pub struct Dhr12r2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)" ]
    pub mod dhr12r2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dhr12r2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc2dhrR {
            bits: u16,
        }
        impl Dacc2dhrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dacc2dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc2dhrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - DAC channel2 12-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc2dhr(&self) -> Dacc2dhrR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc2dhrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:11 - DAC channel2 12-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc2dhr(&mut self) -> _Dacc2dhrW {
                _Dacc2dhrW { w: self }
            }
        }
    }
    # [ doc = "DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)" ]
    pub struct Dhr12l2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)" ]
    pub mod dhr12l2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dhr12l2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc2dhrR {
            bits: u16,
        }
        impl Dacc2dhrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dacc2dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc2dhrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 4:15 - DAC channel2 12-bit left-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc2dhr(&self) -> Dacc2dhrR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc2dhrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 4:15 - DAC channel2 12-bit left-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc2dhr(&mut self) -> _Dacc2dhrW {
                _Dacc2dhrW { w: self }
            }
        }
    }
    # [ doc = "DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)" ]
    pub struct Dhr8r2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)" ]
    pub mod dhr8r2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dhr8r2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc2dhrR {
            bits: u8,
        }
        impl Dacc2dhrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dacc2dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc2dhrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - DAC channel2 8-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc2dhr(&self) -> Dacc2dhrR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dacc2dhrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - DAC channel2 8-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc2dhr(&mut self) -> _Dacc2dhrW {
                _Dacc2dhrW { w: self }
            }
        }
    }
    # [ doc = "Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved" ]
    pub struct Dhr12rd {
        register: VolatileCell<u32>,
    }
    # [ doc = "Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved" ]
    pub mod dhr12rd {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dhr12rd {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc1dhrR {
            bits: u16,
        }
        impl Dacc1dhrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc2dhrR {
            bits: u16,
        }
        impl Dacc2dhrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dacc1dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc1dhrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dacc2dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc2dhrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc1dhr(&self) -> Dacc1dhrR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc1dhrR { bits }
            }
            # [ doc = "Bits 16:27 - DAC channel2 12-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc2dhr(&self) -> Dacc2dhrR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc2dhrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc1dhr(&mut self) -> _Dacc1dhrW {
                _Dacc1dhrW { w: self }
            }
            # [ doc = "Bits 16:27 - DAC channel2 12-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc2dhr(&mut self) -> _Dacc2dhrW {
                _Dacc2dhrW { w: self }
            }
        }
    }
    # [ doc = "DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved" ]
    pub struct Dhr12ld {
        register: VolatileCell<u32>,
    }
    # [ doc = "DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved" ]
    pub mod dhr12ld {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dhr12ld {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc1dhrR {
            bits: u16,
        }
        impl Dacc1dhrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc2dhrR {
            bits: u16,
        }
        impl Dacc2dhrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dacc1dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc1dhrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dacc2dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc2dhrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc1dhr(&self) -> Dacc1dhrR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc1dhrR { bits }
            }
            # [ doc = "Bits 20:31 - DAC channel2 12-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc2dhr(&self) -> Dacc2dhrR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc2dhrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc1dhr(&mut self) -> _Dacc1dhrW {
                _Dacc1dhrW { w: self }
            }
            # [ doc = "Bits 20:31 - DAC channel2 12-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc2dhr(&mut self) -> _Dacc2dhrW {
                _Dacc2dhrW { w: self }
            }
        }
    }
    # [ doc = "DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved" ]
    pub struct Dhr8rd {
        register: VolatileCell<u32>,
    }
    # [ doc = "DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved" ]
    pub mod dhr8rd {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dhr8rd {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc1dhrR {
            bits: u8,
        }
        impl Dacc1dhrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc2dhrR {
            bits: u8,
        }
        impl Dacc2dhrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dacc1dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc1dhrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dacc2dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc2dhrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc1dhr(&self) -> Dacc1dhrR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dacc1dhrR { bits }
            }
            # [ doc = "Bits 8:15 - DAC channel2 8-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc2dhr(&self) -> Dacc2dhrR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dacc2dhrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc1dhr(&mut self) -> _Dacc1dhrW {
                _Dacc1dhrW { w: self }
            }
            # [ doc = "Bits 8:15 - DAC channel2 8-bit right-aligned data" ]
            # [ inline ( always ) ]
            pub fn dacc2dhr(&mut self) -> _Dacc2dhrW {
                _Dacc2dhrW { w: self }
            }
        }
    }
    # [ doc = "DAC channel1 data output register (DAC_DOR1)" ]
    pub struct Dor1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DAC channel1 data output register (DAC_DOR1)" ]
    pub mod dor1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Dor1 {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc1dorR {
            bits: u16,
        }
        impl Dacc1dorR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - DAC channel1 data output" ]
            # [ inline ( always ) ]
            pub fn dacc1dor(&self) -> Dacc1dorR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc1dorR { bits }
            }
        }
    }
    # [ doc = "DAC channel2 data output register (DAC_DOR2)" ]
    pub struct Dor2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "DAC channel2 data output register (DAC_DOR2)" ]
    pub mod dor2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Dor2 {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dacc2dorR {
            bits: u16,
        }
        impl Dacc2dorR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - DAC channel2 data output" ]
            # [ inline ( always ) ]
            pub fn dacc2dor(&self) -> Dacc2dorR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc2dorR { bits }
            }
        }
    }
    # [ doc = "DAC status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "DAC status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dmaudr1R {
            bits: u8,
        }
        impl Dmaudr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dmaudr2R {
            bits: u8,
        }
        impl Dmaudr2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dmaudr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dmaudr1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dmaudr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dmaudr2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 13 - DAC channel1 DMA underrun flag" ]
            # [ inline ( always ) ]
            pub fn dmaudr1(&self) -> Dmaudr1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dmaudr1R { bits }
            }
            # [ doc = "Bit 29 - DAC channel2 DMA underrun flag" ]
            # [ inline ( always ) ]
            pub fn dmaudr2(&self) -> Dmaudr2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dmaudr2R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 13 - DAC channel1 DMA underrun flag" ]
            # [ inline ( always ) ]
            pub fn dmaudr1(&mut self) -> _Dmaudr1W {
                _Dmaudr1W { w: self }
            }
            # [ doc = "Bit 29 - DAC channel2 DMA underrun flag" ]
            # [ inline ( always ) ]
            pub fn dmaudr2(&mut self) -> _Dmaudr2W {
                _Dmaudr2W { w: self }
            }
        }
    }
}
# [ doc = "Digital to analog converter" ]
pub struct Dac {
    register_block: dac::RegisterBlock,
}
impl Deref for Dac {
    type Target = dac::RegisterBlock;
    fn deref(&self) -> &dac::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Debug support" ]
pub const DBG: Peripheral<Dbg> = unsafe { Peripheral::new(3758366720) };
# [ doc = "Debug support" ]
pub mod dbg {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - DBGMCU_IDCODE" ]
        pub idcode: Idcode,
        # [ doc = "0x04 - DBGMCU_CR" ]
        pub cr: Cr,
    }
    # [ doc = "DBGMCU_IDCODE" ]
    pub struct Idcode {
        register: VolatileCell<u32>,
    }
    # [ doc = "DBGMCU_IDCODE" ]
    pub mod idcode {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Idcode {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DevIdR {
            bits: u16,
        }
        impl DevIdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RevIdR {
            bits: u16,
        }
        impl RevIdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:11 - DEV_ID" ]
            # [ inline ( always ) ]
            pub fn dev_id(&self) -> DevIdR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DevIdR { bits }
            }
            # [ doc = "Bits 16:31 - REV_ID" ]
            # [ inline ( always ) ]
            pub fn rev_id(&self) -> RevIdR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RevIdR { bits }
            }
        }
    }
    # [ doc = "DBGMCU_CR" ]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    # [ doc = "DBGMCU_CR" ]
    pub mod cr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgSleepR {
            bits: u8,
        }
        impl DbgSleepR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgStopR {
            bits: u8,
        }
        impl DbgStopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgStandbyR {
            bits: u8,
        }
        impl DbgStandbyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TraceIoenR {
            bits: u8,
        }
        impl TraceIoenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TraceModeR {
            bits: u8,
        }
        impl TraceModeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgIwdgStopR {
            bits: u8,
        }
        impl DbgIwdgStopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgWwdgStopR {
            bits: u8,
        }
        impl DbgWwdgStopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim1StopR {
            bits: u8,
        }
        impl DbgTim1StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim2StopR {
            bits: u8,
        }
        impl DbgTim2StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim3StopR {
            bits: u8,
        }
        impl DbgTim3StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim4StopR {
            bits: u8,
        }
        impl DbgTim4StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgI2c1SmbusTimeoutR {
            bits: u8,
        }
        impl DbgI2c1SmbusTimeoutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgI2c2SmbusTimeoutR {
            bits: u8,
        }
        impl DbgI2c2SmbusTimeoutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim5StopR {
            bits: u8,
        }
        impl DbgTim5StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim6StopR {
            bits: u8,
        }
        impl DbgTim6StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim7StopR {
            bits: u8,
        }
        impl DbgTim7StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim15StopR {
            bits: u8,
        }
        impl DbgTim15StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim16StopR {
            bits: u8,
        }
        impl DbgTim16StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim17StopR {
            bits: u8,
        }
        impl DbgTim17StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim12StopR {
            bits: u8,
        }
        impl DbgTim12StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim13StopR {
            bits: u8,
        }
        impl DbgTim13StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbgTim14StopR {
            bits: u8,
        }
        impl DbgTim14StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgSleepW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgSleepW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgStopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgStandbyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgStandbyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TraceIoenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TraceIoenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TraceModeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TraceModeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgIwdgStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgIwdgStopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgWwdgStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgWwdgStopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim1StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim1StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim2StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim2StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim3StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim3StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim4StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim4StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgI2c1SmbusTimeoutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgI2c1SmbusTimeoutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgI2c2SmbusTimeoutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgI2c2SmbusTimeoutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim5StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim5StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim6StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim6StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim7StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim7StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim15StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim15StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim16StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim16StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim17StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim17StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim12StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim12StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim13StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim13StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbgTim14StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTim14StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - DBG_SLEEP" ]
            # [ inline ( always ) ]
            pub fn dbg_sleep(&self) -> DbgSleepR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgSleepR { bits }
            }
            # [ doc = "Bit 1 - DBG_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_stop(&self) -> DbgStopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgStopR { bits }
            }
            # [ doc = "Bit 2 - DBG_STANDBY" ]
            # [ inline ( always ) ]
            pub fn dbg_standby(&self) -> DbgStandbyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgStandbyR { bits }
            }
            # [ doc = "Bit 5 - TRACE_IOEN" ]
            # [ inline ( always ) ]
            pub fn trace_ioen(&self) -> TraceIoenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TraceIoenR { bits }
            }
            # [ doc = "Bits 6:7 - TRACE_MODE" ]
            # [ inline ( always ) ]
            pub fn trace_mode(&self) -> TraceModeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TraceModeR { bits }
            }
            # [ doc = "Bit 8 - DBG_IWDG_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_iwdg_stop(&self) -> DbgIwdgStopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgIwdgStopR { bits }
            }
            # [ doc = "Bit 9 - DBG_WWDG_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_wwdg_stop(&self) -> DbgWwdgStopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgWwdgStopR { bits }
            }
            # [ doc = "Bit 10 - DBG_TIM1_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim1_stop(&self) -> DbgTim1StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim1StopR { bits }
            }
            # [ doc = "Bit 11 - DBG_TIM2_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim2_stop(&self) -> DbgTim2StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim2StopR { bits }
            }
            # [ doc = "Bit 12 - DBG_TIM3_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim3_stop(&self) -> DbgTim3StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim3StopR { bits }
            }
            # [ doc = "Bit 13 - DBG_TIM4_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim4_stop(&self) -> DbgTim4StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim4StopR { bits }
            }
            # [ doc = "Bit 15 - DBG_I2C1_SMBUS_TIMEOUT" ]
            # [ inline ( always ) ]
            pub fn dbg_i2c1_smbus_timeout(&self) -> DbgI2c1SmbusTimeoutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgI2c1SmbusTimeoutR { bits }
            }
            # [ doc = "Bit 16 - DBG_I2C2_SMBUS_TIMEOUT" ]
            # [ inline ( always ) ]
            pub fn dbg_i2c2_smbus_timeout(&self) -> DbgI2c2SmbusTimeoutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgI2c2SmbusTimeoutR { bits }
            }
            # [ doc = "Bit 18 - DBG_TIM5_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim5_stop(&self) -> DbgTim5StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim5StopR { bits }
            }
            # [ doc = "Bit 19 - DBG_TIM6_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim6_stop(&self) -> DbgTim6StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim6StopR { bits }
            }
            # [ doc = "Bit 20 - DBG_TIM7_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim7_stop(&self) -> DbgTim7StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim7StopR { bits }
            }
            # [ doc = "Bit 22 - DBG_TIM15_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim15_stop(&self) -> DbgTim15StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim15StopR { bits }
            }
            # [ doc = "Bit 23 - DBG_TIM16_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim16_stop(&self) -> DbgTim16StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim16StopR { bits }
            }
            # [ doc = "Bit 24 - DBG_TIM17_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim17_stop(&self) -> DbgTim17StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim17StopR { bits }
            }
            # [ doc = "Bit 25 - DBG_TIM12_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim12_stop(&self) -> DbgTim12StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim12StopR { bits }
            }
            # [ doc = "Bit 26 - DBG_TIM13_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim13_stop(&self) -> DbgTim13StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim13StopR { bits }
            }
            # [ doc = "Bit 27 - DBG_TIM14_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim14_stop(&self) -> DbgTim14StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTim14StopR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - DBG_SLEEP" ]
            # [ inline ( always ) ]
            pub fn dbg_sleep(&mut self) -> _DbgSleepW {
                _DbgSleepW { w: self }
            }
            # [ doc = "Bit 1 - DBG_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_stop(&mut self) -> _DbgStopW {
                _DbgStopW { w: self }
            }
            # [ doc = "Bit 2 - DBG_STANDBY" ]
            # [ inline ( always ) ]
            pub fn dbg_standby(&mut self) -> _DbgStandbyW {
                _DbgStandbyW { w: self }
            }
            # [ doc = "Bit 5 - TRACE_IOEN" ]
            # [ inline ( always ) ]
            pub fn trace_ioen(&mut self) -> _TraceIoenW {
                _TraceIoenW { w: self }
            }
            # [ doc = "Bits 6:7 - TRACE_MODE" ]
            # [ inline ( always ) ]
            pub fn trace_mode(&mut self) -> _TraceModeW {
                _TraceModeW { w: self }
            }
            # [ doc = "Bit 8 - DBG_IWDG_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_iwdg_stop(&mut self) -> _DbgIwdgStopW {
                _DbgIwdgStopW { w: self }
            }
            # [ doc = "Bit 9 - DBG_WWDG_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_wwdg_stop(&mut self) -> _DbgWwdgStopW {
                _DbgWwdgStopW { w: self }
            }
            # [ doc = "Bit 10 - DBG_TIM1_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim1_stop(&mut self) -> _DbgTim1StopW {
                _DbgTim1StopW { w: self }
            }
            # [ doc = "Bit 11 - DBG_TIM2_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim2_stop(&mut self) -> _DbgTim2StopW {
                _DbgTim2StopW { w: self }
            }
            # [ doc = "Bit 12 - DBG_TIM3_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim3_stop(&mut self) -> _DbgTim3StopW {
                _DbgTim3StopW { w: self }
            }
            # [ doc = "Bit 13 - DBG_TIM4_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim4_stop(&mut self) -> _DbgTim4StopW {
                _DbgTim4StopW { w: self }
            }
            # [ doc = "Bit 15 - DBG_I2C1_SMBUS_TIMEOUT" ]
            # [ inline ( always ) ]
            pub fn dbg_i2c1_smbus_timeout(&mut self) -> _DbgI2c1SmbusTimeoutW {
                _DbgI2c1SmbusTimeoutW { w: self }
            }
            # [ doc = "Bit 16 - DBG_I2C2_SMBUS_TIMEOUT" ]
            # [ inline ( always ) ]
            pub fn dbg_i2c2_smbus_timeout(&mut self) -> _DbgI2c2SmbusTimeoutW {
                _DbgI2c2SmbusTimeoutW { w: self }
            }
            # [ doc = "Bit 18 - DBG_TIM5_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim5_stop(&mut self) -> _DbgTim5StopW {
                _DbgTim5StopW { w: self }
            }
            # [ doc = "Bit 19 - DBG_TIM6_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim6_stop(&mut self) -> _DbgTim6StopW {
                _DbgTim6StopW { w: self }
            }
            # [ doc = "Bit 20 - DBG_TIM7_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim7_stop(&mut self) -> _DbgTim7StopW {
                _DbgTim7StopW { w: self }
            }
            # [ doc = "Bit 22 - DBG_TIM15_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim15_stop(&mut self) -> _DbgTim15StopW {
                _DbgTim15StopW { w: self }
            }
            # [ doc = "Bit 23 - DBG_TIM16_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim16_stop(&mut self) -> _DbgTim16StopW {
                _DbgTim16StopW { w: self }
            }
            # [ doc = "Bit 24 - DBG_TIM17_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim17_stop(&mut self) -> _DbgTim17StopW {
                _DbgTim17StopW { w: self }
            }
            # [ doc = "Bit 25 - DBG_TIM12_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim12_stop(&mut self) -> _DbgTim12StopW {
                _DbgTim12StopW { w: self }
            }
            # [ doc = "Bit 26 - DBG_TIM13_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim13_stop(&mut self) -> _DbgTim13StopW {
                _DbgTim13StopW { w: self }
            }
            # [ doc = "Bit 27 - DBG_TIM14_STOP" ]
            # [ inline ( always ) ]
            pub fn dbg_tim14_stop(&mut self) -> _DbgTim14StopW {
                _DbgTim14StopW { w: self }
            }
        }
    }
}
# [ doc = "Debug support" ]
pub struct Dbg {
    register_block: dbg::RegisterBlock,
}
impl Deref for Dbg {
    type Target = dbg::RegisterBlock;
    fn deref(&self) -> &dbg::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Universal asynchronous receiver transmitter" ]
pub const UART4: Peripheral<Uart4> = unsafe { Peripheral::new(1073761280) };
# [ doc = "Universal asynchronous receiver transmitter" ]
pub mod uart4 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Status register" ]
        pub sr: Sr,
        # [ doc = "0x04 - Data register" ]
        pub dr: Dr,
        # [ doc = "0x08 - Baud rate register" ]
        pub brr: Brr,
        # [ doc = "0x0c - Control register 1" ]
        pub cr1: Cr1,
        # [ doc = "0x10 - Control register 2" ]
        pub cr2: Cr2,
        # [ doc = "0x14 - Control register 3" ]
        pub cr3: Cr3,
    }
    # [ doc = "Status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PeR {
            bits: u8,
        }
        impl PeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FeR {
            bits: u8,
        }
        impl FeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NeR {
            bits: u8,
        }
        impl NeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OreR {
            bits: u8,
        }
        impl OreR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IdleR {
            bits: u8,
        }
        impl IdleR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxneR {
            bits: u8,
        }
        impl RxneR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcR {
            bits: u8,
        }
        impl TcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxeR {
            bits: u8,
        }
        impl TxeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LbdR {
            bits: u8,
        }
        impl LbdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxneW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxneW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LbdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Parity error" ]
            # [ inline ( always ) ]
            pub fn pe(&self) -> PeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PeR { bits }
            }
            # [ doc = "Bit 1 - Framing error" ]
            # [ inline ( always ) ]
            pub fn fe(&self) -> FeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FeR { bits }
            }
            # [ doc = "Bit 2 - Noise error flag" ]
            # [ inline ( always ) ]
            pub fn ne(&self) -> NeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NeR { bits }
            }
            # [ doc = "Bit 3 - Overrun error" ]
            # [ inline ( always ) ]
            pub fn ore(&self) -> OreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OreR { bits }
            }
            # [ doc = "Bit 4 - IDLE line detected" ]
            # [ inline ( always ) ]
            pub fn idle(&self) -> IdleR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IdleR { bits }
            }
            # [ doc = "Bit 5 - Read data register not empty" ]
            # [ inline ( always ) ]
            pub fn rxne(&self) -> RxneR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneR { bits }
            }
            # [ doc = "Bit 6 - Transmission complete" ]
            # [ inline ( always ) ]
            pub fn tc(&self) -> TcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcR { bits }
            }
            # [ doc = "Bit 7 - Transmit data register empty" ]
            # [ inline ( always ) ]
            pub fn txe(&self) -> TxeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeR { bits }
            }
            # [ doc = "Bit 8 - LIN break detection flag" ]
            # [ inline ( always ) ]
            pub fn lbd(&self) -> LbdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 5 - Read data register not empty" ]
            # [ inline ( always ) ]
            pub fn rxne(&mut self) -> _RxneW {
                _RxneW { w: self }
            }
            # [ doc = "Bit 6 - Transmission complete" ]
            # [ inline ( always ) ]
            pub fn tc(&mut self) -> _TcW {
                _TcW { w: self }
            }
            # [ doc = "Bit 8 - LIN break detection flag" ]
            # [ inline ( always ) ]
            pub fn lbd(&mut self) -> _LbdW {
                _LbdW { w: self }
            }
        }
    }
    # [ doc = "Data register" ]
    pub struct Dr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Data register" ]
    pub mod dr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DrR {
            bits: u16,
        }
        impl DrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 511;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:8 - DR" ]
            # [ inline ( always ) ]
            pub fn dr(&self) -> DrR {
                let bits = {
                    const MASK: u16 = 511;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:8 - DR" ]
            # [ inline ( always ) ]
            pub fn dr(&mut self) -> _DrW {
                _DrW { w: self }
            }
        }
    }
    # [ doc = "Baud rate register" ]
    pub struct Brr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Baud rate register" ]
    pub mod brr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Brr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DivFractionR {
            bits: u8,
        }
        impl DivFractionR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DivMantissaR {
            bits: u16,
        }
        impl DivMantissaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DivFractionW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DivFractionW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DivMantissaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DivMantissaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - DIV_Fraction" ]
            # [ inline ( always ) ]
            pub fn div_fraction(&self) -> DivFractionR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DivFractionR { bits }
            }
            # [ doc = "Bits 4:15 - DIV_Mantissa" ]
            # [ inline ( always ) ]
            pub fn div_mantissa(&self) -> DivMantissaR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DivMantissaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - DIV_Fraction" ]
            # [ inline ( always ) ]
            pub fn div_fraction(&mut self) -> _DivFractionW {
                _DivFractionW { w: self }
            }
            # [ doc = "Bits 4:15 - DIV_Mantissa" ]
            # [ inline ( always ) ]
            pub fn div_mantissa(&mut self) -> _DivMantissaW {
                _DivMantissaW { w: self }
            }
        }
    }
    # [ doc = "Control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SbkR {
            bits: u8,
        }
        impl SbkR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RwuR {
            bits: u8,
        }
        impl RwuR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ReR {
            bits: u8,
        }
        impl ReR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TeR {
            bits: u8,
        }
        impl TeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IdleieR {
            bits: u8,
        }
        impl IdleieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxneieR {
            bits: u8,
        }
        impl RxneieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxeieR {
            bits: u8,
        }
        impl TxeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PeieR {
            bits: u8,
        }
        impl PeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PsR {
            bits: u8,
        }
        impl PsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PceR {
            bits: u8,
        }
        impl PceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WakeR {
            bits: u8,
        }
        impl WakeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MR {
            bits: u8,
        }
        impl MR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UeR {
            bits: u8,
        }
        impl UeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SbkW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SbkW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RwuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RwuW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IdleieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IdleieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxneieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxneieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WakeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WakeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Send break" ]
            # [ inline ( always ) ]
            pub fn sbk(&self) -> SbkR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SbkR { bits }
            }
            # [ doc = "Bit 1 - Receiver wakeup" ]
            # [ inline ( always ) ]
            pub fn rwu(&self) -> RwuR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RwuR { bits }
            }
            # [ doc = "Bit 2 - Receiver enable" ]
            # [ inline ( always ) ]
            pub fn re(&self) -> ReR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ReR { bits }
            }
            # [ doc = "Bit 3 - Transmitter enable" ]
            # [ inline ( always ) ]
            pub fn te(&self) -> TeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeR { bits }
            }
            # [ doc = "Bit 4 - IDLE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn idleie(&self) -> IdleieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IdleieR { bits }
            }
            # [ doc = "Bit 5 - RXNE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rxneie(&self) -> RxneieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneieR { bits }
            }
            # [ doc = "Bit 6 - Transmission complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            # [ doc = "Bit 7 - TXE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn txeie(&self) -> TxeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeieR { bits }
            }
            # [ doc = "Bit 8 - PE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn peie(&self) -> PeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PeieR { bits }
            }
            # [ doc = "Bit 9 - Parity selection" ]
            # [ inline ( always ) ]
            pub fn ps(&self) -> PsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsR { bits }
            }
            # [ doc = "Bit 10 - Parity control enable" ]
            # [ inline ( always ) ]
            pub fn pce(&self) -> PceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PceR { bits }
            }
            # [ doc = "Bit 11 - Wakeup method" ]
            # [ inline ( always ) ]
            pub fn wake(&self) -> WakeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WakeR { bits }
            }
            # [ doc = "Bit 12 - Word length" ]
            # [ inline ( always ) ]
            pub fn m(&self) -> MR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MR { bits }
            }
            # [ doc = "Bit 13 - USART enable" ]
            # [ inline ( always ) ]
            pub fn ue(&self) -> UeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Send break" ]
            # [ inline ( always ) ]
            pub fn sbk(&mut self) -> _SbkW {
                _SbkW { w: self }
            }
            # [ doc = "Bit 1 - Receiver wakeup" ]
            # [ inline ( always ) ]
            pub fn rwu(&mut self) -> _RwuW {
                _RwuW { w: self }
            }
            # [ doc = "Bit 2 - Receiver enable" ]
            # [ inline ( always ) ]
            pub fn re(&mut self) -> _ReW {
                _ReW { w: self }
            }
            # [ doc = "Bit 3 - Transmitter enable" ]
            # [ inline ( always ) ]
            pub fn te(&mut self) -> _TeW {
                _TeW { w: self }
            }
            # [ doc = "Bit 4 - IDLE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn idleie(&mut self) -> _IdleieW {
                _IdleieW { w: self }
            }
            # [ doc = "Bit 5 - RXNE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rxneie(&mut self) -> _RxneieW {
                _RxneieW { w: self }
            }
            # [ doc = "Bit 6 - Transmission complete interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            # [ doc = "Bit 7 - TXE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn txeie(&mut self) -> _TxeieW {
                _TxeieW { w: self }
            }
            # [ doc = "Bit 8 - PE interrupt enable" ]
            # [ inline ( always ) ]
            pub fn peie(&mut self) -> _PeieW {
                _PeieW { w: self }
            }
            # [ doc = "Bit 9 - Parity selection" ]
            # [ inline ( always ) ]
            pub fn ps(&mut self) -> _PsW {
                _PsW { w: self }
            }
            # [ doc = "Bit 10 - Parity control enable" ]
            # [ inline ( always ) ]
            pub fn pce(&mut self) -> _PceW {
                _PceW { w: self }
            }
            # [ doc = "Bit 11 - Wakeup method" ]
            # [ inline ( always ) ]
            pub fn wake(&mut self) -> _WakeW {
                _WakeW { w: self }
            }
            # [ doc = "Bit 12 - Word length" ]
            # [ inline ( always ) ]
            pub fn m(&mut self) -> _MW {
                _MW { w: self }
            }
            # [ doc = "Bit 13 - USART enable" ]
            # [ inline ( always ) ]
            pub fn ue(&mut self) -> _UeW {
                _UeW { w: self }
            }
        }
    }
    # [ doc = "Control register 2" ]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register 2" ]
    pub mod cr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddR {
            bits: u8,
        }
        impl AddR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LbdlR {
            bits: u8,
        }
        impl LbdlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LbdieR {
            bits: u8,
        }
        impl LbdieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct StopR {
            bits: u8,
        }
        impl StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LinenR {
            bits: u8,
        }
        impl LinenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LbdlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbdlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LbdieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbdieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LinenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LinenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - Address of the USART node" ]
            # [ inline ( always ) ]
            pub fn add(&self) -> AddR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddR { bits }
            }
            # [ doc = "Bit 5 - lin break detection length" ]
            # [ inline ( always ) ]
            pub fn lbdl(&self) -> LbdlR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdlR { bits }
            }
            # [ doc = "Bit 6 - LIN break detection interrupt enable" ]
            # [ inline ( always ) ]
            pub fn lbdie(&self) -> LbdieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdieR { bits }
            }
            # [ doc = "Bits 12:13 - STOP bits" ]
            # [ inline ( always ) ]
            pub fn stop(&self) -> StopR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StopR { bits }
            }
            # [ doc = "Bit 14 - LIN mode enable" ]
            # [ inline ( always ) ]
            pub fn linen(&self) -> LinenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LinenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - Address of the USART node" ]
            # [ inline ( always ) ]
            pub fn add(&mut self) -> _AddW {
                _AddW { w: self }
            }
            # [ doc = "Bit 5 - lin break detection length" ]
            # [ inline ( always ) ]
            pub fn lbdl(&mut self) -> _LbdlW {
                _LbdlW { w: self }
            }
            # [ doc = "Bit 6 - LIN break detection interrupt enable" ]
            # [ inline ( always ) ]
            pub fn lbdie(&mut self) -> _LbdieW {
                _LbdieW { w: self }
            }
            # [ doc = "Bits 12:13 - STOP bits" ]
            # [ inline ( always ) ]
            pub fn stop(&mut self) -> _StopW {
                _StopW { w: self }
            }
            # [ doc = "Bit 14 - LIN mode enable" ]
            # [ inline ( always ) ]
            pub fn linen(&mut self) -> _LinenW {
                _LinenW { w: self }
            }
        }
    }
    # [ doc = "Control register 3" ]
    pub struct Cr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register 3" ]
    pub mod cr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EieR {
            bits: u8,
        }
        impl EieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IrenR {
            bits: u8,
        }
        impl IrenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IrlpR {
            bits: u8,
        }
        impl IrlpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HdselR {
            bits: u8,
        }
        impl HdselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmarR {
            bits: u8,
        }
        impl DmarR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmatR {
            bits: u8,
        }
        impl DmatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IrenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IrenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IrlpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IrlpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HdselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HdselW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmarW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmarW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmatW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn eie(&self) -> EieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EieR { bits }
            }
            # [ doc = "Bit 1 - IrDA mode enable" ]
            # [ inline ( always ) ]
            pub fn iren(&self) -> IrenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IrenR { bits }
            }
            # [ doc = "Bit 2 - IrDA low-power" ]
            # [ inline ( always ) ]
            pub fn irlp(&self) -> IrlpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IrlpR { bits }
            }
            # [ doc = "Bit 3 - Half-duplex selection" ]
            # [ inline ( always ) ]
            pub fn hdsel(&self) -> HdselR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HdselR { bits }
            }
            # [ doc = "Bit 6 - DMA enable receiver" ]
            # [ inline ( always ) ]
            pub fn dmar(&self) -> DmarR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DmarR { bits }
            }
            # [ doc = "Bit 7 - DMA enable transmitter" ]
            # [ inline ( always ) ]
            pub fn dmat(&self) -> DmatR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DmatR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn eie(&mut self) -> _EieW {
                _EieW { w: self }
            }
            # [ doc = "Bit 1 - IrDA mode enable" ]
            # [ inline ( always ) ]
            pub fn iren(&mut self) -> _IrenW {
                _IrenW { w: self }
            }
            # [ doc = "Bit 2 - IrDA low-power" ]
            # [ inline ( always ) ]
            pub fn irlp(&mut self) -> _IrlpW {
                _IrlpW { w: self }
            }
            # [ doc = "Bit 3 - Half-duplex selection" ]
            # [ inline ( always ) ]
            pub fn hdsel(&mut self) -> _HdselW {
                _HdselW { w: self }
            }
            # [ doc = "Bit 6 - DMA enable receiver" ]
            # [ inline ( always ) ]
            pub fn dmar(&mut self) -> _DmarW {
                _DmarW { w: self }
            }
            # [ doc = "Bit 7 - DMA enable transmitter" ]
            # [ inline ( always ) ]
            pub fn dmat(&mut self) -> _DmatW {
                _DmatW { w: self }
            }
        }
    }
}
# [ doc = "Universal asynchronous receiver transmitter" ]
pub struct Uart4 {
    register_block: uart4::RegisterBlock,
}
impl Deref for Uart4 {
    type Target = uart4::RegisterBlock;
    fn deref(&self) -> &uart4::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Universal asynchronous receiver transmitter" ]
pub const UART5: Peripheral<Uart5> = unsafe { Peripheral::new(1073762304) };
# [ doc = "Universal asynchronous receiver transmitter" ]
pub mod uart5 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Status register" ]
        pub sr: Sr,
        # [ doc = "0x04 - Data register" ]
        pub dr: Dr,
        # [ doc = "0x08 - Baud rate register" ]
        pub brr: Brr,
        # [ doc = "0x0c - Control register 1" ]
        pub cr1: Cr1,
        # [ doc = "0x10 - Control register 2" ]
        pub cr2: Cr2,
        # [ doc = "0x14 - Control register 3" ]
        pub cr3: Cr3,
    }
    # [ doc = "Status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PeR {
            bits: u8,
        }
        impl PeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct FeR {
            bits: u8,
        }
        impl FeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NeR {
            bits: u8,
        }
        impl NeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OreR {
            bits: u8,
        }
        impl OreR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IdleR {
            bits: u8,
        }
        impl IdleR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxneR {
            bits: u8,
        }
        impl RxneR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcR {
            bits: u8,
        }
        impl TcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxeR {
            bits: u8,
        }
        impl TxeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LbdR {
            bits: u8,
        }
        impl LbdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxneW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxneW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LbdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - PE" ]
            # [ inline ( always ) ]
            pub fn pe(&self) -> PeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PeR { bits }
            }
            # [ doc = "Bit 1 - FE" ]
            # [ inline ( always ) ]
            pub fn fe(&self) -> FeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FeR { bits }
            }
            # [ doc = "Bit 2 - NE" ]
            # [ inline ( always ) ]
            pub fn ne(&self) -> NeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NeR { bits }
            }
            # [ doc = "Bit 3 - ORE" ]
            # [ inline ( always ) ]
            pub fn ore(&self) -> OreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OreR { bits }
            }
            # [ doc = "Bit 4 - IDLE" ]
            # [ inline ( always ) ]
            pub fn idle(&self) -> IdleR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IdleR { bits }
            }
            # [ doc = "Bit 5 - RXNE" ]
            # [ inline ( always ) ]
            pub fn rxne(&self) -> RxneR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneR { bits }
            }
            # [ doc = "Bit 6 - TC" ]
            # [ inline ( always ) ]
            pub fn tc(&self) -> TcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcR { bits }
            }
            # [ doc = "Bit 7 - TXE" ]
            # [ inline ( always ) ]
            pub fn txe(&self) -> TxeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeR { bits }
            }
            # [ doc = "Bit 8 - LBD" ]
            # [ inline ( always ) ]
            pub fn lbd(&self) -> LbdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 5 - RXNE" ]
            # [ inline ( always ) ]
            pub fn rxne(&mut self) -> _RxneW {
                _RxneW { w: self }
            }
            # [ doc = "Bit 6 - TC" ]
            # [ inline ( always ) ]
            pub fn tc(&mut self) -> _TcW {
                _TcW { w: self }
            }
            # [ doc = "Bit 8 - LBD" ]
            # [ inline ( always ) ]
            pub fn lbd(&mut self) -> _LbdW {
                _LbdW { w: self }
            }
        }
    }
    # [ doc = "Data register" ]
    pub struct Dr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Data register" ]
    pub mod dr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DrR {
            bits: u16,
        }
        impl DrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 511;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:8 - DR" ]
            # [ inline ( always ) ]
            pub fn dr(&self) -> DrR {
                let bits = {
                    const MASK: u16 = 511;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:8 - DR" ]
            # [ inline ( always ) ]
            pub fn dr(&mut self) -> _DrW {
                _DrW { w: self }
            }
        }
    }
    # [ doc = "Baud rate register" ]
    pub struct Brr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Baud rate register" ]
    pub mod brr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Brr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DivFractionR {
            bits: u8,
        }
        impl DivFractionR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DivMantissaR {
            bits: u16,
        }
        impl DivMantissaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DivFractionW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DivFractionW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DivMantissaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DivMantissaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - DIV_Fraction" ]
            # [ inline ( always ) ]
            pub fn div_fraction(&self) -> DivFractionR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DivFractionR { bits }
            }
            # [ doc = "Bits 4:15 - DIV_Mantissa" ]
            # [ inline ( always ) ]
            pub fn div_mantissa(&self) -> DivMantissaR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DivMantissaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - DIV_Fraction" ]
            # [ inline ( always ) ]
            pub fn div_fraction(&mut self) -> _DivFractionW {
                _DivFractionW { w: self }
            }
            # [ doc = "Bits 4:15 - DIV_Mantissa" ]
            # [ inline ( always ) ]
            pub fn div_mantissa(&mut self) -> _DivMantissaW {
                _DivMantissaW { w: self }
            }
        }
    }
    # [ doc = "Control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SbkR {
            bits: u8,
        }
        impl SbkR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RwuR {
            bits: u8,
        }
        impl RwuR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ReR {
            bits: u8,
        }
        impl ReR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TeR {
            bits: u8,
        }
        impl TeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IdleieR {
            bits: u8,
        }
        impl IdleieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxneieR {
            bits: u8,
        }
        impl RxneieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxeieR {
            bits: u8,
        }
        impl TxeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PeieR {
            bits: u8,
        }
        impl PeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PsR {
            bits: u8,
        }
        impl PsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PceR {
            bits: u8,
        }
        impl PceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WakeR {
            bits: u8,
        }
        impl WakeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MR {
            bits: u8,
        }
        impl MR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UeR {
            bits: u8,
        }
        impl UeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SbkW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SbkW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RwuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RwuW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IdleieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IdleieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RxneieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxneieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WakeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WakeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - SBK" ]
            # [ inline ( always ) ]
            pub fn sbk(&self) -> SbkR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SbkR { bits }
            }
            # [ doc = "Bit 1 - RWU" ]
            # [ inline ( always ) ]
            pub fn rwu(&self) -> RwuR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RwuR { bits }
            }
            # [ doc = "Bit 2 - RE" ]
            # [ inline ( always ) ]
            pub fn re(&self) -> ReR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ReR { bits }
            }
            # [ doc = "Bit 3 - TE" ]
            # [ inline ( always ) ]
            pub fn te(&self) -> TeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeR { bits }
            }
            # [ doc = "Bit 4 - IDLEIE" ]
            # [ inline ( always ) ]
            pub fn idleie(&self) -> IdleieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IdleieR { bits }
            }
            # [ doc = "Bit 5 - RXNEIE" ]
            # [ inline ( always ) ]
            pub fn rxneie(&self) -> RxneieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneieR { bits }
            }
            # [ doc = "Bit 6 - TCIE" ]
            # [ inline ( always ) ]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            # [ doc = "Bit 7 - TXEIE" ]
            # [ inline ( always ) ]
            pub fn txeie(&self) -> TxeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeieR { bits }
            }
            # [ doc = "Bit 8 - PEIE" ]
            # [ inline ( always ) ]
            pub fn peie(&self) -> PeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PeieR { bits }
            }
            # [ doc = "Bit 9 - PS" ]
            # [ inline ( always ) ]
            pub fn ps(&self) -> PsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsR { bits }
            }
            # [ doc = "Bit 10 - PCE" ]
            # [ inline ( always ) ]
            pub fn pce(&self) -> PceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PceR { bits }
            }
            # [ doc = "Bit 11 - WAKE" ]
            # [ inline ( always ) ]
            pub fn wake(&self) -> WakeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WakeR { bits }
            }
            # [ doc = "Bit 12 - M" ]
            # [ inline ( always ) ]
            pub fn m(&self) -> MR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MR { bits }
            }
            # [ doc = "Bit 13 - UE" ]
            # [ inline ( always ) ]
            pub fn ue(&self) -> UeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - SBK" ]
            # [ inline ( always ) ]
            pub fn sbk(&mut self) -> _SbkW {
                _SbkW { w: self }
            }
            # [ doc = "Bit 1 - RWU" ]
            # [ inline ( always ) ]
            pub fn rwu(&mut self) -> _RwuW {
                _RwuW { w: self }
            }
            # [ doc = "Bit 2 - RE" ]
            # [ inline ( always ) ]
            pub fn re(&mut self) -> _ReW {
                _ReW { w: self }
            }
            # [ doc = "Bit 3 - TE" ]
            # [ inline ( always ) ]
            pub fn te(&mut self) -> _TeW {
                _TeW { w: self }
            }
            # [ doc = "Bit 4 - IDLEIE" ]
            # [ inline ( always ) ]
            pub fn idleie(&mut self) -> _IdleieW {
                _IdleieW { w: self }
            }
            # [ doc = "Bit 5 - RXNEIE" ]
            # [ inline ( always ) ]
            pub fn rxneie(&mut self) -> _RxneieW {
                _RxneieW { w: self }
            }
            # [ doc = "Bit 6 - TCIE" ]
            # [ inline ( always ) ]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            # [ doc = "Bit 7 - TXEIE" ]
            # [ inline ( always ) ]
            pub fn txeie(&mut self) -> _TxeieW {
                _TxeieW { w: self }
            }
            # [ doc = "Bit 8 - PEIE" ]
            # [ inline ( always ) ]
            pub fn peie(&mut self) -> _PeieW {
                _PeieW { w: self }
            }
            # [ doc = "Bit 9 - PS" ]
            # [ inline ( always ) ]
            pub fn ps(&mut self) -> _PsW {
                _PsW { w: self }
            }
            # [ doc = "Bit 10 - PCE" ]
            # [ inline ( always ) ]
            pub fn pce(&mut self) -> _PceW {
                _PceW { w: self }
            }
            # [ doc = "Bit 11 - WAKE" ]
            # [ inline ( always ) ]
            pub fn wake(&mut self) -> _WakeW {
                _WakeW { w: self }
            }
            # [ doc = "Bit 12 - M" ]
            # [ inline ( always ) ]
            pub fn m(&mut self) -> _MW {
                _MW { w: self }
            }
            # [ doc = "Bit 13 - UE" ]
            # [ inline ( always ) ]
            pub fn ue(&mut self) -> _UeW {
                _UeW { w: self }
            }
        }
    }
    # [ doc = "Control register 2" ]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register 2" ]
    pub mod cr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AddR {
            bits: u8,
        }
        impl AddR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LbdlR {
            bits: u8,
        }
        impl LbdlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LbdieR {
            bits: u8,
        }
        impl LbdieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct StopR {
            bits: u8,
        }
        impl StopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LinenR {
            bits: u8,
        }
        impl LinenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AddW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LbdlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbdlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LbdieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbdieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LinenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LinenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - ADD" ]
            # [ inline ( always ) ]
            pub fn add(&self) -> AddR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddR { bits }
            }
            # [ doc = "Bit 5 - LBDL" ]
            # [ inline ( always ) ]
            pub fn lbdl(&self) -> LbdlR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdlR { bits }
            }
            # [ doc = "Bit 6 - LBDIE" ]
            # [ inline ( always ) ]
            pub fn lbdie(&self) -> LbdieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdieR { bits }
            }
            # [ doc = "Bits 12:13 - STOP" ]
            # [ inline ( always ) ]
            pub fn stop(&self) -> StopR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StopR { bits }
            }
            # [ doc = "Bit 14 - LINEN" ]
            # [ inline ( always ) ]
            pub fn linen(&self) -> LinenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LinenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - ADD" ]
            # [ inline ( always ) ]
            pub fn add(&mut self) -> _AddW {
                _AddW { w: self }
            }
            # [ doc = "Bit 5 - LBDL" ]
            # [ inline ( always ) ]
            pub fn lbdl(&mut self) -> _LbdlW {
                _LbdlW { w: self }
            }
            # [ doc = "Bit 6 - LBDIE" ]
            # [ inline ( always ) ]
            pub fn lbdie(&mut self) -> _LbdieW {
                _LbdieW { w: self }
            }
            # [ doc = "Bits 12:13 - STOP" ]
            # [ inline ( always ) ]
            pub fn stop(&mut self) -> _StopW {
                _StopW { w: self }
            }
            # [ doc = "Bit 14 - LINEN" ]
            # [ inline ( always ) ]
            pub fn linen(&mut self) -> _LinenW {
                _LinenW { w: self }
            }
        }
    }
    # [ doc = "Control register 3" ]
    pub struct Cr3 {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register 3" ]
    pub mod cr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EieR {
            bits: u8,
        }
        impl EieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IrenR {
            bits: u8,
        }
        impl IrenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IrlpR {
            bits: u8,
        }
        impl IrlpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HdselR {
            bits: u8,
        }
        impl HdselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmatR {
            bits: u8,
        }
        impl DmatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IrenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IrenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IrlpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IrlpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HdselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HdselW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmatW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn eie(&self) -> EieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EieR { bits }
            }
            # [ doc = "Bit 1 - IrDA mode enable" ]
            # [ inline ( always ) ]
            pub fn iren(&self) -> IrenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IrenR { bits }
            }
            # [ doc = "Bit 2 - IrDA low-power" ]
            # [ inline ( always ) ]
            pub fn irlp(&self) -> IrlpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IrlpR { bits }
            }
            # [ doc = "Bit 3 - Half-duplex selection" ]
            # [ inline ( always ) ]
            pub fn hdsel(&self) -> HdselR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HdselR { bits }
            }
            # [ doc = "Bit 7 - DMA enable transmitter" ]
            # [ inline ( always ) ]
            pub fn dmat(&self) -> DmatR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DmatR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn eie(&mut self) -> _EieW {
                _EieW { w: self }
            }
            # [ doc = "Bit 1 - IrDA mode enable" ]
            # [ inline ( always ) ]
            pub fn iren(&mut self) -> _IrenW {
                _IrenW { w: self }
            }
            # [ doc = "Bit 2 - IrDA low-power" ]
            # [ inline ( always ) ]
            pub fn irlp(&mut self) -> _IrlpW {
                _IrlpW { w: self }
            }
            # [ doc = "Bit 3 - Half-duplex selection" ]
            # [ inline ( always ) ]
            pub fn hdsel(&mut self) -> _HdselW {
                _HdselW { w: self }
            }
            # [ doc = "Bit 7 - DMA enable transmitter" ]
            # [ inline ( always ) ]
            pub fn dmat(&mut self) -> _DmatW {
                _DmatW { w: self }
            }
        }
    }
}
# [ doc = "Universal asynchronous receiver transmitter" ]
pub struct Uart5 {
    register_block: uart5::RegisterBlock,
}
impl Deref for Uart5 {
    type Target = uart5::RegisterBlock;
    fn deref(&self) -> &uart5::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "CRC calculation unit" ]
pub const CRC: Peripheral<Crc> = unsafe { Peripheral::new(1073885184) };
# [ doc = "CRC calculation unit" ]
pub mod crc {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Data register" ]
        pub dr: Dr,
        # [ doc = "0x04 - Independent Data register" ]
        pub idr: Idr,
        # [ doc = "0x08 - Control register" ]
        pub cr: Cr,
    }
    # [ doc = "Data register" ]
    pub struct Dr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Data register" ]
    pub mod dr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DrR {
            bits: u32,
        }
        impl DrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Data Register" ]
            # [ inline ( always ) ]
            pub fn dr(&self) -> DrR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Data Register" ]
            # [ inline ( always ) ]
            pub fn dr(&mut self) -> _DrW {
                _DrW { w: self }
            }
        }
    }
    # [ doc = "Independent Data register" ]
    pub struct Idr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Independent Data register" ]
    pub mod idr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Idr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IdrR {
            bits: u8,
        }
        impl IdrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IdrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IdrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Independent Data register" ]
            # [ inline ( always ) ]
            pub fn idr(&self) -> IdrR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IdrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Independent Data register" ]
            # [ inline ( always ) ]
            pub fn idr(&mut self) -> _IdrW {
                _IdrW { w: self }
            }
        }
    }
    # [ doc = "Control register" ]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register" ]
    pub mod cr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ResetW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ResetW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Reset bit" ]
            # [ inline ( always ) ]
            pub fn reset(&mut self) -> _ResetW {
                _ResetW { w: self }
            }
        }
    }
}
# [ doc = "CRC calculation unit" ]
pub struct Crc {
    register_block: crc::RegisterBlock,
}
impl Deref for Crc {
    type Target = crc::RegisterBlock;
    fn deref(&self) -> &crc::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "FLASH" ]
pub const FLASH: Peripheral<Flash> = unsafe { Peripheral::new(1073881088) };
# [ doc = "FLASH" ]
pub mod flash {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - Flash access control register" ]
        pub acr: Acr,
        # [ doc = "0x04 - Flash key register" ]
        pub keyr: Keyr,
        # [ doc = "0x08 - Flash option key register" ]
        pub optkeyr: Optkeyr,
        # [ doc = "0x0c - Status register" ]
        pub sr: Sr,
        # [ doc = "0x10 - Control register" ]
        pub cr: Cr,
        # [ doc = "0x14 - Flash address register" ]
        pub ar: Ar,
        _reserved0: [u8; 4usize],
        # [ doc = "0x1c - Option byte register" ]
        pub obr: Obr,
        # [ doc = "0x20 - Write protection register" ]
        pub wrpr: Wrpr,
    }
    # [ doc = "Flash access control register" ]
    pub struct Acr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Flash access control register" ]
    pub mod acr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Acr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct HlfcyaR {
            bits: u8,
        }
        impl HlfcyaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _HlfcyaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HlfcyaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 3 - Flash half cycle access enable" ]
            # [ inline ( always ) ]
            pub fn hlfcya(&self) -> HlfcyaR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HlfcyaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 3 - Flash half cycle access enable" ]
            # [ inline ( always ) ]
            pub fn hlfcya(&mut self) -> _HlfcyaW {
                _HlfcyaW { w: self }
            }
        }
    }
    # [ doc = "Flash key register" ]
    pub struct Keyr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Flash key register" ]
    pub mod keyr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Keyr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _KeyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _KeyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - FPEC key" ]
            # [ inline ( always ) ]
            pub fn key(&mut self) -> _KeyW {
                _KeyW { w: self }
            }
        }
    }
    # [ doc = "Flash option key register" ]
    pub struct Optkeyr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Flash option key register" ]
    pub mod optkeyr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Optkeyr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OptkeyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OptkeyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Option byte key" ]
            # [ inline ( always ) ]
            pub fn optkey(&mut self) -> _OptkeyW {
                _OptkeyW { w: self }
            }
        }
    }
    # [ doc = "Status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EopR {
            bits: u8,
        }
        impl EopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WrprterrR {
            bits: u8,
        }
        impl WrprterrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PgerrR {
            bits: u8,
        }
        impl PgerrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BsyR {
            bits: u8,
        }
        impl BsyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EopW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WrprterrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WrprterrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PgerrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PgerrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 5 - End of operation" ]
            # [ inline ( always ) ]
            pub fn eop(&self) -> EopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EopR { bits }
            }
            # [ doc = "Bit 4 - Write protection error" ]
            # [ inline ( always ) ]
            pub fn wrprterr(&self) -> WrprterrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WrprterrR { bits }
            }
            # [ doc = "Bit 2 - Programming error" ]
            # [ inline ( always ) ]
            pub fn pgerr(&self) -> PgerrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PgerrR { bits }
            }
            # [ doc = "Bit 0 - Busy" ]
            # [ inline ( always ) ]
            pub fn bsy(&self) -> BsyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BsyR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 5 - End of operation" ]
            # [ inline ( always ) ]
            pub fn eop(&mut self) -> _EopW {
                _EopW { w: self }
            }
            # [ doc = "Bit 4 - Write protection error" ]
            # [ inline ( always ) ]
            pub fn wrprterr(&mut self) -> _WrprterrW {
                _WrprterrW { w: self }
            }
            # [ doc = "Bit 2 - Programming error" ]
            # [ inline ( always ) ]
            pub fn pgerr(&mut self) -> _PgerrW {
                _PgerrW { w: self }
            }
        }
    }
    # [ doc = "Control register" ]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Control register" ]
    pub mod cr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PgR {
            bits: u8,
        }
        impl PgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PerR {
            bits: u8,
        }
        impl PerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MerR {
            bits: u8,
        }
        impl MerR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OptpgR {
            bits: u8,
        }
        impl OptpgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OpterR {
            bits: u8,
        }
        impl OpterR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct StrtR {
            bits: u8,
        }
        impl StrtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LockR {
            bits: u8,
        }
        impl LockR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OptwreR {
            bits: u8,
        }
        impl OptwreR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ErrieR {
            bits: u8,
        }
        impl ErrieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EopieR {
            bits: u8,
        }
        impl EopieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PerW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MerW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OptpgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OptpgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OpterW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpterW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _StrtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StrtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LockW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OptwreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OptwreW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ErrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EopieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EopieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Programming" ]
            # [ inline ( always ) ]
            pub fn pg(&self) -> PgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PgR { bits }
            }
            # [ doc = "Bit 1 - Page Erase" ]
            # [ inline ( always ) ]
            pub fn per(&self) -> PerR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PerR { bits }
            }
            # [ doc = "Bit 2 - Mass Erase" ]
            # [ inline ( always ) ]
            pub fn mer(&self) -> MerR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MerR { bits }
            }
            # [ doc = "Bit 4 - Option byte programming" ]
            # [ inline ( always ) ]
            pub fn optpg(&self) -> OptpgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OptpgR { bits }
            }
            # [ doc = "Bit 5 - Option byte erase" ]
            # [ inline ( always ) ]
            pub fn opter(&self) -> OpterR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpterR { bits }
            }
            # [ doc = "Bit 6 - Start" ]
            # [ inline ( always ) ]
            pub fn strt(&self) -> StrtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StrtR { bits }
            }
            # [ doc = "Bit 7 - Lock" ]
            # [ inline ( always ) ]
            pub fn lock(&self) -> LockR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LockR { bits }
            }
            # [ doc = "Bit 9 - Option bytes write enable" ]
            # [ inline ( always ) ]
            pub fn optwre(&self) -> OptwreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OptwreR { bits }
            }
            # [ doc = "Bit 10 - Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn errie(&self) -> ErrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ErrieR { bits }
            }
            # [ doc = "Bit 12 - End of operation interrupt enable" ]
            # [ inline ( always ) ]
            pub fn eopie(&self) -> EopieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EopieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 128 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Programming" ]
            # [ inline ( always ) ]
            pub fn pg(&mut self) -> _PgW {
                _PgW { w: self }
            }
            # [ doc = "Bit 1 - Page Erase" ]
            # [ inline ( always ) ]
            pub fn per(&mut self) -> _PerW {
                _PerW { w: self }
            }
            # [ doc = "Bit 2 - Mass Erase" ]
            # [ inline ( always ) ]
            pub fn mer(&mut self) -> _MerW {
                _MerW { w: self }
            }
            # [ doc = "Bit 4 - Option byte programming" ]
            # [ inline ( always ) ]
            pub fn optpg(&mut self) -> _OptpgW {
                _OptpgW { w: self }
            }
            # [ doc = "Bit 5 - Option byte erase" ]
            # [ inline ( always ) ]
            pub fn opter(&mut self) -> _OpterW {
                _OpterW { w: self }
            }
            # [ doc = "Bit 6 - Start" ]
            # [ inline ( always ) ]
            pub fn strt(&mut self) -> _StrtW {
                _StrtW { w: self }
            }
            # [ doc = "Bit 7 - Lock" ]
            # [ inline ( always ) ]
            pub fn lock(&mut self) -> _LockW {
                _LockW { w: self }
            }
            # [ doc = "Bit 9 - Option bytes write enable" ]
            # [ inline ( always ) ]
            pub fn optwre(&mut self) -> _OptwreW {
                _OptwreW { w: self }
            }
            # [ doc = "Bit 10 - Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn errie(&mut self) -> _ErrieW {
                _ErrieW { w: self }
            }
            # [ doc = "Bit 12 - End of operation interrupt enable" ]
            # [ inline ( always ) ]
            pub fn eopie(&mut self) -> _EopieW {
                _EopieW { w: self }
            }
        }
    }
    # [ doc = "Flash address register" ]
    pub struct Ar {
        register: VolatileCell<u32>,
    }
    # [ doc = "Flash address register" ]
    pub mod ar {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ar {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FarW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FarW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:31 - Flash Address" ]
            # [ inline ( always ) ]
            pub fn far(&mut self) -> _FarW {
                _FarW { w: self }
            }
        }
    }
    # [ doc = "Option byte register" ]
    pub struct Obr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Option byte register" ]
    pub mod obr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Obr {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OpterrR {
            bits: u8,
        }
        impl OpterrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RdprtR {
            bits: u8,
        }
        impl RdprtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WdgSwR {
            bits: u8,
        }
        impl WdgSwR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NRstStopR {
            bits: u8,
        }
        impl NRstStopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NRstStdbyR {
            bits: u8,
        }
        impl NRstStdbyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Data0R {
            bits: u8,
        }
        impl Data0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Data1R {
            bits: u8,
        }
        impl Data1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Option byte error" ]
            # [ inline ( always ) ]
            pub fn opterr(&self) -> OpterrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpterrR { bits }
            }
            # [ doc = "Bit 1 - Read protection" ]
            # [ inline ( always ) ]
            pub fn rdprt(&self) -> RdprtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RdprtR { bits }
            }
            # [ doc = "Bit 2 - WDG_SW" ]
            # [ inline ( always ) ]
            pub fn wdg_sw(&self) -> WdgSwR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WdgSwR { bits }
            }
            # [ doc = "Bit 3 - nRST_STOP" ]
            # [ inline ( always ) ]
            pub fn n_rst_stop(&self) -> NRstStopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NRstStopR { bits }
            }
            # [ doc = "Bit 4 - nRST_STDBY" ]
            # [ inline ( always ) ]
            pub fn n_rst_stdby(&self) -> NRstStdbyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NRstStdbyR { bits }
            }
            # [ doc = "Bits 10:17 - Data0" ]
            # [ inline ( always ) ]
            pub fn data0(&self) -> Data0R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Data0R { bits }
            }
            # [ doc = "Bits 18:25 - Data1" ]
            # [ inline ( always ) ]
            pub fn data1(&self) -> Data1R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Data1R { bits }
            }
        }
    }
    # [ doc = "Write protection register" ]
    pub struct Wrpr {
        register: VolatileCell<u32>,
    }
    # [ doc = "Write protection register" ]
    pub mod wrpr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Wrpr {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WrpR {
            bits: u32,
        }
        impl WrpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:31 - Write protect" ]
            # [ inline ( always ) ]
            pub fn wrp(&self) -> WrpR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                WrpR { bits }
            }
        }
    }
}
# [ doc = "FLASH" ]
pub struct Flash {
    register_block: flash::RegisterBlock,
}
impl Deref for Flash {
    type Target = flash::RegisterBlock;
    fn deref(&self) -> &flash::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "General purpose timers" ]
pub const TIM15: Peripheral<Tim15> = unsafe { Peripheral::new(1073823744) };
# [ doc = "General purpose timers" ]
pub mod tim15 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - control register 1" ]
        pub cr1: Cr1,
        # [ doc = "0x04 - control register 2" ]
        pub cr2: Cr2,
        # [ doc = "0x08 - slave mode control register" ]
        pub smcr: Smcr,
        # [ doc = "0x0c - DMA/Interrupt enable register" ]
        pub dier: Dier,
        # [ doc = "0x10 - status register" ]
        pub sr: Sr,
        # [ doc = "0x14 - event generation register" ]
        pub egr: Egr,
        # [ doc = "0x18 - capture/compare mode register (output mode)" ]
        pub ccmr1_output: Ccmr1Output,
        _reserved0: [u8; 4usize],
        # [ doc = "0x20 - capture/compare enable register" ]
        pub ccer: Ccer,
        # [ doc = "0x24 - counter" ]
        pub cnt: Cnt,
        # [ doc = "0x28 - prescaler" ]
        pub psc: Psc,
        # [ doc = "0x2c - auto-reload register" ]
        pub arr: Arr,
        # [ doc = "0x30 - repetition counter register" ]
        pub rcr: Rcr,
        # [ doc = "0x34 - capture/compare register 1" ]
        pub ccr1: Ccr1,
        # [ doc = "0x38 - capture/compare register 2" ]
        pub ccr2: Ccr2,
        _reserved1: [u8; 8usize],
        # [ doc = "0x44 - break and dead-time register" ]
        pub bdtr: Bdtr,
        # [ doc = "0x48 - DMA control register" ]
        pub dcr: Dcr,
        # [ doc = "0x4c - DMA address for full transfer" ]
        pub dmar: Dmar,
    }
    # [ doc = "control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CkdR {
            bits: u8,
        }
        impl CkdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OpmR {
            bits: u8,
        }
        impl OpmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CenR {
            bits: u8,
        }
        impl CenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CkdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CkdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OpmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 8:9 - Clock division" ]
            # [ inline ( always ) ]
            pub fn ckd(&self) -> CkdR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CkdR { bits }
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            # [ doc = "Bit 3 - One-pulse mode" ]
            # [ inline ( always ) ]
            pub fn opm(&self) -> OpmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpmR { bits }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&self) -> CenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 8:9 - Clock division" ]
            # [ inline ( always ) ]
            pub fn ckd(&mut self) -> _CkdW {
                _CkdW { w: self }
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            # [ doc = "Bit 3 - One-pulse mode" ]
            # [ inline ( always ) ]
            pub fn opm(&mut self) -> _OpmW {
                _OpmW { w: self }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    # [ doc = "control register 2" ]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 2" ]
    pub mod cr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ois2R {
            bits: u8,
        }
        impl Ois2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ois1nR {
            bits: u8,
        }
        impl Ois1nR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ois1R {
            bits: u8,
        }
        impl Ois1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MmsR {
            bits: u8,
        }
        impl MmsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcdsR {
            bits: u8,
        }
        impl CcdsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcusR {
            bits: u8,
        }
        impl CcusR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcpcR {
            bits: u8,
        }
        impl CcpcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ois2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ois1nW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois1nW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ois1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MmsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcdsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcdsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcusW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcusW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcpcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcpcW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 10 - Output Idle state 2" ]
            # [ inline ( always ) ]
            pub fn ois2(&self) -> Ois2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois2R { bits }
            }
            # [ doc = "Bit 9 - Output Idle state 1" ]
            # [ inline ( always ) ]
            pub fn ois1n(&self) -> Ois1nR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois1nR { bits }
            }
            # [ doc = "Bit 8 - Output Idle state 1" ]
            # [ inline ( always ) ]
            pub fn ois1(&self) -> Ois1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois1R { bits }
            }
            # [ doc = "Bits 4:6 - Master mode selection" ]
            # [ inline ( always ) ]
            pub fn mms(&self) -> MmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MmsR { bits }
            }
            # [ doc = "Bit 3 - Capture/compare DMA selection" ]
            # [ inline ( always ) ]
            pub fn ccds(&self) -> CcdsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcdsR { bits }
            }
            # [ doc = "Bit 2 - Capture/compare control update selection" ]
            # [ inline ( always ) ]
            pub fn ccus(&self) -> CcusR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcusR { bits }
            }
            # [ doc = "Bit 0 - Capture/compare preloaded control" ]
            # [ inline ( always ) ]
            pub fn ccpc(&self) -> CcpcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcpcR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 10 - Output Idle state 2" ]
            # [ inline ( always ) ]
            pub fn ois2(&mut self) -> _Ois2W {
                _Ois2W { w: self }
            }
            # [ doc = "Bit 9 - Output Idle state 1" ]
            # [ inline ( always ) ]
            pub fn ois1n(&mut self) -> _Ois1nW {
                _Ois1nW { w: self }
            }
            # [ doc = "Bit 8 - Output Idle state 1" ]
            # [ inline ( always ) ]
            pub fn ois1(&mut self) -> _Ois1W {
                _Ois1W { w: self }
            }
            # [ doc = "Bits 4:6 - Master mode selection" ]
            # [ inline ( always ) ]
            pub fn mms(&mut self) -> _MmsW {
                _MmsW { w: self }
            }
            # [ doc = "Bit 3 - Capture/compare DMA selection" ]
            # [ inline ( always ) ]
            pub fn ccds(&mut self) -> _CcdsW {
                _CcdsW { w: self }
            }
            # [ doc = "Bit 2 - Capture/compare control update selection" ]
            # [ inline ( always ) ]
            pub fn ccus(&mut self) -> _CcusW {
                _CcusW { w: self }
            }
            # [ doc = "Bit 0 - Capture/compare preloaded control" ]
            # [ inline ( always ) ]
            pub fn ccpc(&mut self) -> _CcpcW {
                _CcpcW { w: self }
            }
        }
    }
    # [ doc = "slave mode control register" ]
    pub struct Smcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "slave mode control register" ]
    pub mod smcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Smcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MsmR {
            bits: u8,
        }
        impl MsmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TsR {
            bits: u8,
        }
        impl TsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SmsR {
            bits: u8,
        }
        impl SmsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MsmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 7 - Master/Slave mode" ]
            # [ inline ( always ) ]
            pub fn msm(&self) -> MsmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsmR { bits }
            }
            # [ doc = "Bits 4:6 - Trigger selection" ]
            # [ inline ( always ) ]
            pub fn ts(&self) -> TsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsR { bits }
            }
            # [ doc = "Bits 0:2 - Slave mode selection" ]
            # [ inline ( always ) ]
            pub fn sms(&self) -> SmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmsR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 7 - Master/Slave mode" ]
            # [ inline ( always ) ]
            pub fn msm(&mut self) -> _MsmW {
                _MsmW { w: self }
            }
            # [ doc = "Bits 4:6 - Trigger selection" ]
            # [ inline ( always ) ]
            pub fn ts(&mut self) -> _TsW {
                _TsW { w: self }
            }
            # [ doc = "Bits 0:2 - Slave mode selection" ]
            # [ inline ( always ) ]
            pub fn sms(&mut self) -> _SmsW {
                _SmsW { w: self }
            }
        }
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub mod dier {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TdeR {
            bits: u8,
        }
        impl TdeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2deR {
            bits: u8,
        }
        impl Cc2deR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1deR {
            bits: u8,
        }
        impl Cc1deR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UdeR {
            bits: u8,
        }
        impl UdeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BieR {
            bits: u8,
        }
        impl BieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TieR {
            bits: u8,
        }
        impl TieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ComieR {
            bits: u8,
        }
        impl ComieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2ieR {
            bits: u8,
        }
        impl Cc2ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ieR {
            bits: u8,
        }
        impl Cc1ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TdeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2deW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1deW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ComieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 14 - Trigger DMA request enable" ]
            # [ inline ( always ) ]
            pub fn tde(&self) -> TdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TdeR { bits }
            }
            # [ doc = "Bit 10 - Capture/Compare 2 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc2de(&self) -> Cc2deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2deR { bits }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc1de(&self) -> Cc1deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1deR { bits }
            }
            # [ doc = "Bit 8 - Update DMA request enable" ]
            # [ inline ( always ) ]
            pub fn ude(&self) -> UdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdeR { bits }
            }
            # [ doc = "Bit 7 - Break interrupt enable" ]
            # [ inline ( always ) ]
            pub fn bie(&self) -> BieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BieR { bits }
            }
            # [ doc = "Bit 6 - Trigger interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tie(&self) -> TieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TieR { bits }
            }
            # [ doc = "Bit 5 - COM interrupt enable" ]
            # [ inline ( always ) ]
            pub fn comie(&self) -> ComieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComieR { bits }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc2ie(&self) -> Cc2ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ieR { bits }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc1ie(&self) -> Cc1ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ieR { bits }
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 14 - Trigger DMA request enable" ]
            # [ inline ( always ) ]
            pub fn tde(&mut self) -> _TdeW {
                _TdeW { w: self }
            }
            # [ doc = "Bit 10 - Capture/Compare 2 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc2de(&mut self) -> _Cc2deW {
                _Cc2deW { w: self }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc1de(&mut self) -> _Cc1deW {
                _Cc1deW { w: self }
            }
            # [ doc = "Bit 8 - Update DMA request enable" ]
            # [ inline ( always ) ]
            pub fn ude(&mut self) -> _UdeW {
                _UdeW { w: self }
            }
            # [ doc = "Bit 7 - Break interrupt enable" ]
            # [ inline ( always ) ]
            pub fn bie(&mut self) -> _BieW {
                _BieW { w: self }
            }
            # [ doc = "Bit 6 - Trigger interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tie(&mut self) -> _TieW {
                _TieW { w: self }
            }
            # [ doc = "Bit 5 - COM interrupt enable" ]
            # [ inline ( always ) ]
            pub fn comie(&mut self) -> _ComieW {
                _ComieW { w: self }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc2ie(&mut self) -> _Cc2ieW {
                _Cc2ieW { w: self }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc1ie(&mut self) -> _Cc1ieW {
                _Cc1ieW { w: self }
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
        }
    }
    # [ doc = "status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2ofR {
            bits: u8,
        }
        impl Cc2ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ofR {
            bits: u8,
        }
        impl Cc1ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BifR {
            bits: u8,
        }
        impl BifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TifR {
            bits: u8,
        }
        impl TifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ComifR {
            bits: u8,
        }
        impl ComifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2ifR {
            bits: u8,
        }
        impl Cc2ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ifR {
            bits: u8,
        }
        impl Cc1ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UifR {
            bits: u8,
        }
        impl UifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ComifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 10 - Capture/compare 2 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc2of(&self) -> Cc2ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ofR { bits }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc1of(&self) -> Cc1ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ofR { bits }
            }
            # [ doc = "Bit 7 - Break interrupt flag" ]
            # [ inline ( always ) ]
            pub fn bif(&self) -> BifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BifR { bits }
            }
            # [ doc = "Bit 6 - Trigger interrupt flag" ]
            # [ inline ( always ) ]
            pub fn tif(&self) -> TifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TifR { bits }
            }
            # [ doc = "Bit 5 - COM interrupt flag" ]
            # [ inline ( always ) ]
            pub fn comif(&self) -> ComifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComifR { bits }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc2if(&self) -> Cc2ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ifR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc1if(&self) -> Cc1ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ifR { bits }
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&self) -> UifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UifR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 10 - Capture/compare 2 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc2of(&mut self) -> _Cc2ofW {
                _Cc2ofW { w: self }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc1of(&mut self) -> _Cc1ofW {
                _Cc1ofW { w: self }
            }
            # [ doc = "Bit 7 - Break interrupt flag" ]
            # [ inline ( always ) ]
            pub fn bif(&mut self) -> _BifW {
                _BifW { w: self }
            }
            # [ doc = "Bit 6 - Trigger interrupt flag" ]
            # [ inline ( always ) ]
            pub fn tif(&mut self) -> _TifW {
                _TifW { w: self }
            }
            # [ doc = "Bit 5 - COM interrupt flag" ]
            # [ inline ( always ) ]
            pub fn comif(&mut self) -> _ComifW {
                _ComifW { w: self }
            }
            # [ doc = "Bit 2 - Capture/Compare 2 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc2if(&mut self) -> _Cc2ifW {
                _Cc2ifW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc1if(&mut self) -> _Cc1ifW {
                _Cc1ifW { w: self }
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    # [ doc = "event generation register" ]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    # [ doc = "event generation register" ]
    pub mod egr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ComgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 7 - Break generation" ]
            # [ inline ( always ) ]
            pub fn bg(&mut self) -> _BgW {
                _BgW { w: self }
            }
            # [ doc = "Bit 6 - Trigger generation" ]
            # [ inline ( always ) ]
            pub fn tg(&mut self) -> _TgW {
                _TgW { w: self }
            }
            # [ doc = "Bit 5 - Capture/Compare control update generation" ]
            # [ inline ( always ) ]
            pub fn comg(&mut self) -> _ComgW {
                _ComgW { w: self }
            }
            # [ doc = "Bit 2 - Capture/compare 2 generation" ]
            # [ inline ( always ) ]
            pub fn cc2g(&mut self) -> _Cc2gW {
                _Cc2gW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare 1 generation" ]
            # [ inline ( always ) ]
            pub fn cc1g(&mut self) -> _Cc1gW {
                _Cc1gW { w: self }
            }
            # [ doc = "Bit 0 - Update generation" ]
            # [ inline ( always ) ]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register (output mode)" ]
    pub struct Ccmr1Output {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register (output mode)" ]
    pub mod ccmr1_output {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Output {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2mR {
            bits: u8,
        }
        impl Oc2mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2peR {
            bits: u8,
        }
        impl Oc2peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc2feR {
            bits: u8,
        }
        impl Oc2feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1mR {
            bits: u8,
        }
        impl Oc1mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1peR {
            bits: u8,
        }
        impl Oc1peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1feR {
            bits: u8,
        }
        impl Oc1feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc2feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 12:14 - Output Compare 2 mode" ]
            # [ inline ( always ) ]
            pub fn oc2m(&self) -> Oc2mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2mR { bits }
            }
            # [ doc = "Bit 11 - Output Compare 2 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc2pe(&self) -> Oc2peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2peR { bits }
            }
            # [ doc = "Bit 10 - Output Compare 2 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc2fe(&self) -> Oc2feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2feR { bits }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            # [ doc = "Bits 4:6 - Output Compare 1 mode" ]
            # [ inline ( always ) ]
            pub fn oc1m(&self) -> Oc1mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1mR { bits }
            }
            # [ doc = "Bit 3 - Output Compare 1 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc1pe(&self) -> Oc1peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1peR { bits }
            }
            # [ doc = "Bit 2 - Output Compare 1 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc1fe(&self) -> Oc1feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1feR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 12:14 - Output Compare 2 mode" ]
            # [ inline ( always ) ]
            pub fn oc2m(&mut self) -> _Oc2mW {
                _Oc2mW { w: self }
            }
            # [ doc = "Bit 11 - Output Compare 2 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc2pe(&mut self) -> _Oc2peW {
                _Oc2peW { w: self }
            }
            # [ doc = "Bit 10 - Output Compare 2 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc2fe(&mut self) -> _Oc2feW {
                _Oc2feW { w: self }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            # [ doc = "Bits 4:6 - Output Compare 1 mode" ]
            # [ inline ( always ) ]
            pub fn oc1m(&mut self) -> _Oc1mW {
                _Oc1mW { w: self }
            }
            # [ doc = "Bit 3 - Output Compare 1 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc1pe(&mut self) -> _Oc1peW {
                _Oc1peW { w: self }
            }
            # [ doc = "Bit 2 - Output Compare 1 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc1fe(&mut self) -> _Oc1feW {
                _Oc1feW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register 1 (input mode)" ]
    pub struct Ccmr1Input {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register 1 (input mode)" ]
    pub mod ccmr1_input {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Input {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic2fR {
            bits: u8,
        }
        impl Ic2fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic2pscR {
            bits: u8,
        }
        impl Ic2pscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic1fR {
            bits: u8,
        }
        impl Ic1fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic1pscR {
            bits: u8,
        }
        impl Ic1pscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic2fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic2pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2pscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic1fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic1pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1pscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 12:15 - Input capture 2 filter" ]
            # [ inline ( always ) ]
            pub fn ic2f(&self) -> Ic2fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2fR { bits }
            }
            # [ doc = "Bits 10:11 - Input capture 2 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic2psc(&self) -> Ic2pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2pscR { bits }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            # [ doc = "Bits 4:7 - Input capture 1 filter" ]
            # [ inline ( always ) ]
            pub fn ic1f(&self) -> Ic1fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1fR { bits }
            }
            # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic1psc(&self) -> Ic1pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1pscR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 12:15 - Input capture 2 filter" ]
            # [ inline ( always ) ]
            pub fn ic2f(&mut self) -> _Ic2fW {
                _Ic2fW { w: self }
            }
            # [ doc = "Bits 10:11 - Input capture 2 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic2psc(&mut self) -> _Ic2pscW {
                _Ic2pscW { w: self }
            }
            # [ doc = "Bits 8:9 - Capture/Compare 2 selection" ]
            # [ inline ( always ) ]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            # [ doc = "Bits 4:7 - Input capture 1 filter" ]
            # [ inline ( always ) ]
            pub fn ic1f(&mut self) -> _Ic1fW {
                _Ic1fW { w: self }
            }
            # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic1psc(&mut self) -> _Ic1pscW {
                _Ic1pscW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare enable register" ]
    pub struct Ccer {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare enable register" ]
    pub mod ccer {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccer {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2npR {
            bits: u8,
        }
        impl Cc2npR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2pR {
            bits: u8,
        }
        impl Cc2pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc2eR {
            bits: u8,
        }
        impl Cc2eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1npR {
            bits: u8,
        }
        impl Cc1npR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1neR {
            bits: u8,
        }
        impl Cc1neR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1pR {
            bits: u8,
        }
        impl Cc1pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1eR {
            bits: u8,
        }
        impl Cc1eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2npW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc2eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1npW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1neW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1neW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 7 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2np(&self) -> Cc2npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2npR { bits }
            }
            # [ doc = "Bit 5 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2p(&self) -> Cc2pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2pR { bits }
            }
            # [ doc = "Bit 4 - Capture/Compare 2 output enable" ]
            # [ inline ( always ) ]
            pub fn cc2e(&self) -> Cc2eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2eR { bits }
            }
            # [ doc = "Bit 3 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1np(&self) -> Cc1npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1npR { bits }
            }
            # [ doc = "Bit 2 - Capture/Compare 1 complementary output enable" ]
            # [ inline ( always ) ]
            pub fn cc1ne(&self) -> Cc1neR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1neR { bits }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1p(&self) -> Cc1pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1pR { bits }
            }
            # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
            # [ inline ( always ) ]
            pub fn cc1e(&self) -> Cc1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1eR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 7 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2np(&mut self) -> _Cc2npW {
                _Cc2npW { w: self }
            }
            # [ doc = "Bit 5 - Capture/Compare 2 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc2p(&mut self) -> _Cc2pW {
                _Cc2pW { w: self }
            }
            # [ doc = "Bit 4 - Capture/Compare 2 output enable" ]
            # [ inline ( always ) ]
            pub fn cc2e(&mut self) -> _Cc2eW {
                _Cc2eW { w: self }
            }
            # [ doc = "Bit 3 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1np(&mut self) -> _Cc1npW {
                _Cc1npW { w: self }
            }
            # [ doc = "Bit 2 - Capture/Compare 1 complementary output enable" ]
            # [ inline ( always ) ]
            pub fn cc1ne(&mut self) -> _Cc1neW {
                _Cc1neW { w: self }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1p(&mut self) -> _Cc1pW {
                _Cc1pW { w: self }
            }
            # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
            # [ inline ( always ) ]
            pub fn cc1e(&mut self) -> _Cc1eW {
                _Cc1eW { w: self }
            }
        }
    }
    # [ doc = "counter" ]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    # [ doc = "counter" ]
    pub mod cnt {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&mut self) -> _CntW {
                _CntW { w: self }
            }
        }
    }
    # [ doc = "prescaler" ]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    # [ doc = "prescaler" ]
    pub mod psc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    # [ doc = "auto-reload register" ]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    # [ doc = "auto-reload register" ]
    pub mod arr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArrR {
            bits: u16,
        }
        impl ArrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&self) -> ArrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&mut self) -> _ArrW {
                _ArrW { w: self }
            }
        }
    }
    # [ doc = "repetition counter register" ]
    pub struct Rcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "repetition counter register" ]
    pub mod rcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Rcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RepR {
            bits: u8,
        }
        impl RepR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RepW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RepW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Repetition counter value" ]
            # [ inline ( always ) ]
            pub fn rep(&self) -> RepR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RepR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Repetition counter value" ]
            # [ inline ( always ) ]
            pub fn rep(&mut self) -> _RepW {
                _RepW { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 1" ]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 1" ]
    pub mod ccr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr1R {
            bits: u16,
        }
        impl Ccr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
            # [ inline ( always ) ]
            pub fn ccr1(&self) -> Ccr1R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
            # [ inline ( always ) ]
            pub fn ccr1(&mut self) -> _Ccr1W {
                _Ccr1W { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 2" ]
    pub struct Ccr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 2" ]
    pub mod ccr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr2R {
            bits: u16,
        }
        impl Ccr2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare 2 value" ]
            # [ inline ( always ) ]
            pub fn ccr2(&self) -> Ccr2R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr2R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare 2 value" ]
            # [ inline ( always ) ]
            pub fn ccr2(&mut self) -> _Ccr2W {
                _Ccr2W { w: self }
            }
        }
    }
    # [ doc = "break and dead-time register" ]
    pub struct Bdtr {
        register: VolatileCell<u32>,
    }
    # [ doc = "break and dead-time register" ]
    pub mod bdtr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bdtr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MoeR {
            bits: u8,
        }
        impl MoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AoeR {
            bits: u8,
        }
        impl AoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BkpR {
            bits: u8,
        }
        impl BkpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BkeR {
            bits: u8,
        }
        impl BkeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OssrR {
            bits: u8,
        }
        impl OssrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OssiR {
            bits: u8,
        }
        impl OssiR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LockR {
            bits: u8,
        }
        impl LockR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DtgR {
            bits: u8,
        }
        impl DtgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BkpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BkeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OssrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OssrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OssiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OssiW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LockW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DtgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DtgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - Main output enable" ]
            # [ inline ( always ) ]
            pub fn moe(&self) -> MoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MoeR { bits }
            }
            # [ doc = "Bit 14 - Automatic output enable" ]
            # [ inline ( always ) ]
            pub fn aoe(&self) -> AoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AoeR { bits }
            }
            # [ doc = "Bit 13 - Break polarity" ]
            # [ inline ( always ) ]
            pub fn bkp(&self) -> BkpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkpR { bits }
            }
            # [ doc = "Bit 12 - Break enable" ]
            # [ inline ( always ) ]
            pub fn bke(&self) -> BkeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkeR { bits }
            }
            # [ doc = "Bit 11 - Off-state selection for Run mode" ]
            # [ inline ( always ) ]
            pub fn ossr(&self) -> OssrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OssrR { bits }
            }
            # [ doc = "Bit 10 - Off-state selection for Idle mode" ]
            # [ inline ( always ) ]
            pub fn ossi(&self) -> OssiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OssiR { bits }
            }
            # [ doc = "Bits 8:9 - Lock configuration" ]
            # [ inline ( always ) ]
            pub fn lock(&self) -> LockR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LockR { bits }
            }
            # [ doc = "Bits 0:7 - Dead-time generator setup" ]
            # [ inline ( always ) ]
            pub fn dtg(&self) -> DtgR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DtgR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - Main output enable" ]
            # [ inline ( always ) ]
            pub fn moe(&mut self) -> _MoeW {
                _MoeW { w: self }
            }
            # [ doc = "Bit 14 - Automatic output enable" ]
            # [ inline ( always ) ]
            pub fn aoe(&mut self) -> _AoeW {
                _AoeW { w: self }
            }
            # [ doc = "Bit 13 - Break polarity" ]
            # [ inline ( always ) ]
            pub fn bkp(&mut self) -> _BkpW {
                _BkpW { w: self }
            }
            # [ doc = "Bit 12 - Break enable" ]
            # [ inline ( always ) ]
            pub fn bke(&mut self) -> _BkeW {
                _BkeW { w: self }
            }
            # [ doc = "Bit 11 - Off-state selection for Run mode" ]
            # [ inline ( always ) ]
            pub fn ossr(&mut self) -> _OssrW {
                _OssrW { w: self }
            }
            # [ doc = "Bit 10 - Off-state selection for Idle mode" ]
            # [ inline ( always ) ]
            pub fn ossi(&mut self) -> _OssiW {
                _OssiW { w: self }
            }
            # [ doc = "Bits 8:9 - Lock configuration" ]
            # [ inline ( always ) ]
            pub fn lock(&mut self) -> _LockW {
                _LockW { w: self }
            }
            # [ doc = "Bits 0:7 - Dead-time generator setup" ]
            # [ inline ( always ) ]
            pub fn dtg(&mut self) -> _DtgW {
                _DtgW { w: self }
            }
        }
    }
    # [ doc = "DMA control register" ]
    pub struct Dcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA control register" ]
    pub mod dcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DblR {
            bits: u8,
        }
        impl DblR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbaR {
            bits: u8,
        }
        impl DbaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DblW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DblW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 8:12 - DMA burst length" ]
            # [ inline ( always ) ]
            pub fn dbl(&self) -> DblR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DblR { bits }
            }
            # [ doc = "Bits 0:4 - DMA base address" ]
            # [ inline ( always ) ]
            pub fn dba(&self) -> DbaR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 8:12 - DMA burst length" ]
            # [ inline ( always ) ]
            pub fn dbl(&mut self) -> _DblW {
                _DblW { w: self }
            }
            # [ doc = "Bits 0:4 - DMA base address" ]
            # [ inline ( always ) ]
            pub fn dba(&mut self) -> _DbaW {
                _DbaW { w: self }
            }
        }
    }
    # [ doc = "DMA address for full transfer" ]
    pub struct Dmar {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA address for full transfer" ]
    pub mod dmar {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dmar {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmabR {
            bits: u16,
        }
        impl DmabR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmabW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmabW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - DMA register for burst accesses" ]
            # [ inline ( always ) ]
            pub fn dmab(&self) -> DmabR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DmabR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - DMA register for burst accesses" ]
            # [ inline ( always ) ]
            pub fn dmab(&mut self) -> _DmabW {
                _DmabW { w: self }
            }
        }
    }
}
# [ doc = "General purpose timers" ]
pub struct Tim15 {
    register_block: tim15::RegisterBlock,
}
impl Deref for Tim15 {
    type Target = tim15::RegisterBlock;
    fn deref(&self) -> &tim15::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "General-purpose-timers" ]
pub const TIM16: Peripheral<Tim16> = unsafe { Peripheral::new(1073824768) };
# [ doc = "General-purpose-timers" ]
pub mod tim16 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - control register 1" ]
        pub cr1: Cr1,
        # [ doc = "0x04 - control register 2" ]
        pub cr2: Cr2,
        _reserved0: [u8; 4usize],
        # [ doc = "0x0c - DMA/Interrupt enable register" ]
        pub dier: Dier,
        # [ doc = "0x10 - status register" ]
        pub sr: Sr,
        # [ doc = "0x14 - event generation register" ]
        pub egr: Egr,
        # [ doc = "0x18 - capture/compare mode register (output mode)" ]
        pub ccmr1_output: Ccmr1Output,
        _reserved1: [u8; 4usize],
        # [ doc = "0x20 - capture/compare enable register" ]
        pub ccer: Ccer,
        # [ doc = "0x24 - counter" ]
        pub cnt: Cnt,
        # [ doc = "0x28 - prescaler" ]
        pub psc: Psc,
        # [ doc = "0x2c - auto-reload register" ]
        pub arr: Arr,
        # [ doc = "0x30 - repetition counter register" ]
        pub rcr: Rcr,
        # [ doc = "0x34 - capture/compare register 1" ]
        pub ccr1: Ccr1,
        _reserved2: [u8; 12usize],
        # [ doc = "0x44 - break and dead-time register" ]
        pub bdtr: Bdtr,
        # [ doc = "0x48 - DMA control register" ]
        pub dcr: Dcr,
        # [ doc = "0x4c - DMA address for full transfer" ]
        pub dmar: Dmar,
    }
    # [ doc = "control register 1" ]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 1" ]
    pub mod cr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CkdR {
            bits: u8,
        }
        impl CkdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OpmR {
            bits: u8,
        }
        impl OpmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CenR {
            bits: u8,
        }
        impl CenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CkdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CkdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OpmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 8:9 - Clock division" ]
            # [ inline ( always ) ]
            pub fn ckd(&self) -> CkdR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CkdR { bits }
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            # [ doc = "Bit 3 - One-pulse mode" ]
            # [ inline ( always ) ]
            pub fn opm(&self) -> OpmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpmR { bits }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&self) -> CenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 8:9 - Clock division" ]
            # [ inline ( always ) ]
            pub fn ckd(&mut self) -> _CkdW {
                _CkdW { w: self }
            }
            # [ doc = "Bit 7 - Auto-reload preload enable" ]
            # [ inline ( always ) ]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            # [ doc = "Bit 3 - One-pulse mode" ]
            # [ inline ( always ) ]
            pub fn opm(&mut self) -> _OpmW {
                _OpmW { w: self }
            }
            # [ doc = "Bit 2 - Update request source" ]
            # [ inline ( always ) ]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            # [ doc = "Bit 1 - Update disable" ]
            # [ inline ( always ) ]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            # [ doc = "Bit 0 - Counter enable" ]
            # [ inline ( always ) ]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    # [ doc = "control register 2" ]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    # [ doc = "control register 2" ]
    pub mod cr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ois1nR {
            bits: u8,
        }
        impl Ois1nR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ois1R {
            bits: u8,
        }
        impl Ois1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcdsR {
            bits: u8,
        }
        impl CcdsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcusR {
            bits: u8,
        }
        impl CcusR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcpcR {
            bits: u8,
        }
        impl CcpcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ois1nW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois1nW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ois1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcdsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcdsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcusW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcusW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcpcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcpcW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 9 - Output Idle state 1" ]
            # [ inline ( always ) ]
            pub fn ois1n(&self) -> Ois1nR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois1nR { bits }
            }
            # [ doc = "Bit 8 - Output Idle state 1" ]
            # [ inline ( always ) ]
            pub fn ois1(&self) -> Ois1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois1R { bits }
            }
            # [ doc = "Bit 3 - Capture/compare DMA selection" ]
            # [ inline ( always ) ]
            pub fn ccds(&self) -> CcdsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcdsR { bits }
            }
            # [ doc = "Bit 2 - Capture/compare control update selection" ]
            # [ inline ( always ) ]
            pub fn ccus(&self) -> CcusR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcusR { bits }
            }
            # [ doc = "Bit 0 - Capture/compare preloaded control" ]
            # [ inline ( always ) ]
            pub fn ccpc(&self) -> CcpcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcpcR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 9 - Output Idle state 1" ]
            # [ inline ( always ) ]
            pub fn ois1n(&mut self) -> _Ois1nW {
                _Ois1nW { w: self }
            }
            # [ doc = "Bit 8 - Output Idle state 1" ]
            # [ inline ( always ) ]
            pub fn ois1(&mut self) -> _Ois1W {
                _Ois1W { w: self }
            }
            # [ doc = "Bit 3 - Capture/compare DMA selection" ]
            # [ inline ( always ) ]
            pub fn ccds(&mut self) -> _CcdsW {
                _CcdsW { w: self }
            }
            # [ doc = "Bit 2 - Capture/compare control update selection" ]
            # [ inline ( always ) ]
            pub fn ccus(&mut self) -> _CcusW {
                _CcusW { w: self }
            }
            # [ doc = "Bit 0 - Capture/compare preloaded control" ]
            # [ inline ( always ) ]
            pub fn ccpc(&mut self) -> _CcpcW {
                _CcpcW { w: self }
            }
        }
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA/Interrupt enable register" ]
    pub mod dier {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TdeR {
            bits: u8,
        }
        impl TdeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1deR {
            bits: u8,
        }
        impl Cc1deR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UdeR {
            bits: u8,
        }
        impl UdeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BieR {
            bits: u8,
        }
        impl BieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TieR {
            bits: u8,
        }
        impl TieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ComieR {
            bits: u8,
        }
        impl ComieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ieR {
            bits: u8,
        }
        impl Cc1ieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TdeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1deW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ComieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 14 - Trigger DMA request enable" ]
            # [ inline ( always ) ]
            pub fn tde(&self) -> TdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TdeR { bits }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc1de(&self) -> Cc1deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1deR { bits }
            }
            # [ doc = "Bit 8 - Update DMA request enable" ]
            # [ inline ( always ) ]
            pub fn ude(&self) -> UdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdeR { bits }
            }
            # [ doc = "Bit 7 - Break interrupt enable" ]
            # [ inline ( always ) ]
            pub fn bie(&self) -> BieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BieR { bits }
            }
            # [ doc = "Bit 6 - Trigger interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tie(&self) -> TieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TieR { bits }
            }
            # [ doc = "Bit 5 - COM interrupt enable" ]
            # [ inline ( always ) ]
            pub fn comie(&self) -> ComieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComieR { bits }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc1ie(&self) -> Cc1ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ieR { bits }
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 14 - Trigger DMA request enable" ]
            # [ inline ( always ) ]
            pub fn tde(&mut self) -> _TdeW {
                _TdeW { w: self }
            }
            # [ doc = "Bit 9 - Capture/Compare 1 DMA request enable" ]
            # [ inline ( always ) ]
            pub fn cc1de(&mut self) -> _Cc1deW {
                _Cc1deW { w: self }
            }
            # [ doc = "Bit 8 - Update DMA request enable" ]
            # [ inline ( always ) ]
            pub fn ude(&mut self) -> _UdeW {
                _UdeW { w: self }
            }
            # [ doc = "Bit 7 - Break interrupt enable" ]
            # [ inline ( always ) ]
            pub fn bie(&mut self) -> _BieW {
                _BieW { w: self }
            }
            # [ doc = "Bit 6 - Trigger interrupt enable" ]
            # [ inline ( always ) ]
            pub fn tie(&mut self) -> _TieW {
                _TieW { w: self }
            }
            # [ doc = "Bit 5 - COM interrupt enable" ]
            # [ inline ( always ) ]
            pub fn comie(&mut self) -> _ComieW {
                _ComieW { w: self }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 interrupt enable" ]
            # [ inline ( always ) ]
            pub fn cc1ie(&mut self) -> _Cc1ieW {
                _Cc1ieW { w: self }
            }
            # [ doc = "Bit 0 - Update interrupt enable" ]
            # [ inline ( always ) ]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
        }
    }
    # [ doc = "status register" ]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    # [ doc = "status register" ]
    pub mod sr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ofR {
            bits: u8,
        }
        impl Cc1ofR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BifR {
            bits: u8,
        }
        impl BifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TifR {
            bits: u8,
        }
        impl TifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ComifR {
            bits: u8,
        }
        impl ComifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1ifR {
            bits: u8,
        }
        impl Cc1ifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UifR {
            bits: u8,
        }
        impl UifR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ofW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ComifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc1of(&self) -> Cc1ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ofR { bits }
            }
            # [ doc = "Bit 7 - Break interrupt flag" ]
            # [ inline ( always ) ]
            pub fn bif(&self) -> BifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BifR { bits }
            }
            # [ doc = "Bit 6 - Trigger interrupt flag" ]
            # [ inline ( always ) ]
            pub fn tif(&self) -> TifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TifR { bits }
            }
            # [ doc = "Bit 5 - COM interrupt flag" ]
            # [ inline ( always ) ]
            pub fn comif(&self) -> ComifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComifR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc1if(&self) -> Cc1ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ifR { bits }
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&self) -> UifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UifR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 9 - Capture/Compare 1 overcapture flag" ]
            # [ inline ( always ) ]
            pub fn cc1of(&mut self) -> _Cc1ofW {
                _Cc1ofW { w: self }
            }
            # [ doc = "Bit 7 - Break interrupt flag" ]
            # [ inline ( always ) ]
            pub fn bif(&mut self) -> _BifW {
                _BifW { w: self }
            }
            # [ doc = "Bit 6 - Trigger interrupt flag" ]
            # [ inline ( always ) ]
            pub fn tif(&mut self) -> _TifW {
                _TifW { w: self }
            }
            # [ doc = "Bit 5 - COM interrupt flag" ]
            # [ inline ( always ) ]
            pub fn comif(&mut self) -> _ComifW {
                _ComifW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare 1 interrupt flag" ]
            # [ inline ( always ) ]
            pub fn cc1if(&mut self) -> _Cc1ifW {
                _Cc1ifW { w: self }
            }
            # [ doc = "Bit 0 - Update interrupt flag" ]
            # [ inline ( always ) ]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    # [ doc = "event generation register" ]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    # [ doc = "event generation register" ]
    pub mod egr {
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ComgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1gW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 7 - Break generation" ]
            # [ inline ( always ) ]
            pub fn bg(&mut self) -> _BgW {
                _BgW { w: self }
            }
            # [ doc = "Bit 6 - Trigger generation" ]
            # [ inline ( always ) ]
            pub fn tg(&mut self) -> _TgW {
                _TgW { w: self }
            }
            # [ doc = "Bit 5 - Capture/Compare control update generation" ]
            # [ inline ( always ) ]
            pub fn comg(&mut self) -> _ComgW {
                _ComgW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare 1 generation" ]
            # [ inline ( always ) ]
            pub fn cc1g(&mut self) -> _Cc1gW {
                _Cc1gW { w: self }
            }
            # [ doc = "Bit 0 - Update generation" ]
            # [ inline ( always ) ]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register (output mode)" ]
    pub struct Ccmr1Output {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register (output mode)" ]
    pub mod ccmr1_output {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Output {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1mR {
            bits: u8,
        }
        impl Oc1mR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1peR {
            bits: u8,
        }
        impl Oc1peR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Oc1feR {
            bits: u8,
        }
        impl Oc1feR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1mW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1peW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Oc1feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1feW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 4:6 - Output Compare 1 mode" ]
            # [ inline ( always ) ]
            pub fn oc1m(&self) -> Oc1mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1mR { bits }
            }
            # [ doc = "Bit 3 - Output Compare 1 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc1pe(&self) -> Oc1peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1peR { bits }
            }
            # [ doc = "Bit 2 - Output Compare 1 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc1fe(&self) -> Oc1feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1feR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 4:6 - Output Compare 1 mode" ]
            # [ inline ( always ) ]
            pub fn oc1m(&mut self) -> _Oc1mW {
                _Oc1mW { w: self }
            }
            # [ doc = "Bit 3 - Output Compare 1 preload enable" ]
            # [ inline ( always ) ]
            pub fn oc1pe(&mut self) -> _Oc1peW {
                _Oc1peW { w: self }
            }
            # [ doc = "Bit 2 - Output Compare 1 fast enable" ]
            # [ inline ( always ) ]
            pub fn oc1fe(&mut self) -> _Oc1feW {
                _Oc1feW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare mode register 1 (input mode)" ]
    pub struct Ccmr1Input {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare mode register 1 (input mode)" ]
    pub mod ccmr1_input {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Input {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic1fR {
            bits: u8,
        }
        impl Ic1fR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ic1pscR {
            bits: u8,
        }
        impl Ic1pscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic1fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1fW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ic1pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1pscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 4:7 - Input capture 1 filter" ]
            # [ inline ( always ) ]
            pub fn ic1f(&self) -> Ic1fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1fR { bits }
            }
            # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic1psc(&self) -> Ic1pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1pscR { bits }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 4:7 - Input capture 1 filter" ]
            # [ inline ( always ) ]
            pub fn ic1f(&mut self) -> _Ic1fW {
                _Ic1fW { w: self }
            }
            # [ doc = "Bits 2:3 - Input capture 1 prescaler" ]
            # [ inline ( always ) ]
            pub fn ic1psc(&mut self) -> _Ic1pscW {
                _Ic1pscW { w: self }
            }
            # [ doc = "Bits 0:1 - Capture/Compare 1 selection" ]
            # [ inline ( always ) ]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    # [ doc = "capture/compare enable register" ]
    pub struct Ccer {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare enable register" ]
    pub mod ccer {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccer {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1npR {
            bits: u8,
        }
        impl Cc1npR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1neR {
            bits: u8,
        }
        impl Cc1neR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1pR {
            bits: u8,
        }
        impl Cc1pR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cc1eR {
            bits: u8,
        }
        impl Cc1eR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1npW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1neW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1neW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1pW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cc1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1eW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 3 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1np(&self) -> Cc1npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1npR { bits }
            }
            # [ doc = "Bit 2 - Capture/Compare 1 complementary output enable" ]
            # [ inline ( always ) ]
            pub fn cc1ne(&self) -> Cc1neR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1neR { bits }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1p(&self) -> Cc1pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1pR { bits }
            }
            # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
            # [ inline ( always ) ]
            pub fn cc1e(&self) -> Cc1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1eR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 3 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1np(&mut self) -> _Cc1npW {
                _Cc1npW { w: self }
            }
            # [ doc = "Bit 2 - Capture/Compare 1 complementary output enable" ]
            # [ inline ( always ) ]
            pub fn cc1ne(&mut self) -> _Cc1neW {
                _Cc1neW { w: self }
            }
            # [ doc = "Bit 1 - Capture/Compare 1 output Polarity" ]
            # [ inline ( always ) ]
            pub fn cc1p(&mut self) -> _Cc1pW {
                _Cc1pW { w: self }
            }
            # [ doc = "Bit 0 - Capture/Compare 1 output enable" ]
            # [ inline ( always ) ]
            pub fn cc1e(&mut self) -> _Cc1eW {
                _Cc1eW { w: self }
            }
        }
    }
    # [ doc = "counter" ]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    # [ doc = "counter" ]
    pub mod cnt {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - counter value" ]
            # [ inline ( always ) ]
            pub fn cnt(&mut self) -> _CntW {
                _CntW { w: self }
            }
        }
    }
    # [ doc = "prescaler" ]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    # [ doc = "prescaler" ]
    pub mod psc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Prescaler value" ]
            # [ inline ( always ) ]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    # [ doc = "auto-reload register" ]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    # [ doc = "auto-reload register" ]
    pub mod arr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ArrR {
            bits: u16,
        }
        impl ArrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ArrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&self) -> ArrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Auto-reload value" ]
            # [ inline ( always ) ]
            pub fn arr(&mut self) -> _ArrW {
                _ArrW { w: self }
            }
        }
    }
    # [ doc = "repetition counter register" ]
    pub struct Rcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "repetition counter register" ]
    pub mod rcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Rcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RepR {
            bits: u8,
        }
        impl RepR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RepW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RepW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Repetition counter value" ]
            # [ inline ( always ) ]
            pub fn rep(&self) -> RepR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RepR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Repetition counter value" ]
            # [ inline ( always ) ]
            pub fn rep(&mut self) -> _RepW {
                _RepW { w: self }
            }
        }
    }
    # [ doc = "capture/compare register 1" ]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    # [ doc = "capture/compare register 1" ]
    pub mod ccr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ccr1R {
            bits: u16,
        }
        impl Ccr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ccr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
            # [ inline ( always ) ]
            pub fn ccr1(&self) -> Ccr1R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - Capture/Compare 1 value" ]
            # [ inline ( always ) ]
            pub fn ccr1(&mut self) -> _Ccr1W {
                _Ccr1W { w: self }
            }
        }
    }
    # [ doc = "break and dead-time register" ]
    pub struct Bdtr {
        register: VolatileCell<u32>,
    }
    # [ doc = "break and dead-time register" ]
    pub mod bdtr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Bdtr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MoeR {
            bits: u8,
        }
        impl MoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AoeR {
            bits: u8,
        }
        impl AoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BkpR {
            bits: u8,
        }
        impl BkpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BkeR {
            bits: u8,
        }
        impl BkeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OssrR {
            bits: u8,
        }
        impl OssrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OssiR {
            bits: u8,
        }
        impl OssiR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LockR {
            bits: u8,
        }
        impl LockR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DtgR {
            bits: u8,
        }
        impl DtgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BkpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BkeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OssrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OssrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OssiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OssiW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LockW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DtgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DtgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 15 - Main output enable" ]
            # [ inline ( always ) ]
            pub fn moe(&self) -> MoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MoeR { bits }
            }
            # [ doc = "Bit 14 - Automatic output enable" ]
            # [ inline ( always ) ]
            pub fn aoe(&self) -> AoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AoeR { bits }
            }
            # [ doc = "Bit 13 - Break polarity" ]
            # [ inline ( always ) ]
            pub fn bkp(&self) -> BkpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkpR { bits }
            }
            # [ doc = "Bit 12 - Break enable" ]
            # [ inline ( always ) ]
            pub fn bke(&self) -> BkeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkeR { bits }
            }
            # [ doc = "Bit 11 - Off-state selection for Run mode" ]
            # [ inline ( always ) ]
            pub fn ossr(&self) -> OssrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OssrR { bits }
            }
            # [ doc = "Bit 10 - Off-state selection for Idle mode" ]
            # [ inline ( always ) ]
            pub fn ossi(&self) -> OssiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OssiR { bits }
            }
            # [ doc = "Bits 8:9 - Lock configuration" ]
            # [ inline ( always ) ]
            pub fn lock(&self) -> LockR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LockR { bits }
            }
            # [ doc = "Bits 0:7 - Dead-time generator setup" ]
            # [ inline ( always ) ]
            pub fn dtg(&self) -> DtgR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DtgR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 15 - Main output enable" ]
            # [ inline ( always ) ]
            pub fn moe(&mut self) -> _MoeW {
                _MoeW { w: self }
            }
            # [ doc = "Bit 14 - Automatic output enable" ]
            # [ inline ( always ) ]
            pub fn aoe(&mut self) -> _AoeW {
                _AoeW { w: self }
            }
            # [ doc = "Bit 13 - Break polarity" ]
            # [ inline ( always ) ]
            pub fn bkp(&mut self) -> _BkpW {
                _BkpW { w: self }
            }
            # [ doc = "Bit 12 - Break enable" ]
            # [ inline ( always ) ]
            pub fn bke(&mut self) -> _BkeW {
                _BkeW { w: self }
            }
            # [ doc = "Bit 11 - Off-state selection for Run mode" ]
            # [ inline ( always ) ]
            pub fn ossr(&mut self) -> _OssrW {
                _OssrW { w: self }
            }
            # [ doc = "Bit 10 - Off-state selection for Idle mode" ]
            # [ inline ( always ) ]
            pub fn ossi(&mut self) -> _OssiW {
                _OssiW { w: self }
            }
            # [ doc = "Bits 8:9 - Lock configuration" ]
            # [ inline ( always ) ]
            pub fn lock(&mut self) -> _LockW {
                _LockW { w: self }
            }
            # [ doc = "Bits 0:7 - Dead-time generator setup" ]
            # [ inline ( always ) ]
            pub fn dtg(&mut self) -> _DtgW {
                _DtgW { w: self }
            }
        }
    }
    # [ doc = "DMA control register" ]
    pub struct Dcr {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA control register" ]
    pub mod dcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DblR {
            bits: u8,
        }
        impl DblR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DbaR {
            bits: u8,
        }
        impl DbaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DblW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DblW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DbaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 8:12 - DMA burst length" ]
            # [ inline ( always ) ]
            pub fn dbl(&self) -> DblR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DblR { bits }
            }
            # [ doc = "Bits 0:4 - DMA base address" ]
            # [ inline ( always ) ]
            pub fn dba(&self) -> DbaR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 8:12 - DMA burst length" ]
            # [ inline ( always ) ]
            pub fn dbl(&mut self) -> _DblW {
                _DblW { w: self }
            }
            # [ doc = "Bits 0:4 - DMA base address" ]
            # [ inline ( always ) ]
            pub fn dba(&mut self) -> _DbaW {
                _DbaW { w: self }
            }
        }
    }
    # [ doc = "DMA address for full transfer" ]
    pub struct Dmar {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA address for full transfer" ]
    pub mod dmar {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dmar {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmabR {
            bits: u16,
        }
        impl DmabR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmabW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmabW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:15 - DMA register for burst accesses" ]
            # [ inline ( always ) ]
            pub fn dmab(&self) -> DmabR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DmabR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:15 - DMA register for burst accesses" ]
            # [ inline ( always ) ]
            pub fn dmab(&mut self) -> _DmabW {
                _DmabW { w: self }
            }
        }
    }
}
# [ doc = "General-purpose-timers" ]
pub struct Tim16 {
    register_block: tim16::RegisterBlock,
}
impl Deref for Tim16 {
    type Target = tim16::RegisterBlock;
    fn deref(&self) -> &tim16::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "TIM17" ]
pub const TIM17: Peripheral<Tim17> = unsafe { Peripheral::new(1073825792) };
# [ doc = r" Register block" ]
pub struct Tim17 {
    register_block: tim16::RegisterBlock,
}
impl Deref for Tim17 {
    type Target = tim16::RegisterBlock;
    fn deref(&self) -> &tim16::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "HDMI-CEC controller" ]
pub const CEC: Peripheral<Cec> = unsafe { Peripheral::new(1073772544) };
# [ doc = "HDMI-CEC controller" ]
pub mod cec {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        # [ doc = "0x00 - configuration register" ]
        pub cfgr: Cfgr,
        # [ doc = "0x04 - CEC own address register" ]
        pub oar: Oar,
        # [ doc = "0x08 - Rx Data Register" ]
        pub pres: Pres,
        # [ doc = "0x0c - CEC error status register" ]
        pub esr: Esr,
        # [ doc = "0x10 - CEC control and status register" ]
        pub csr: Csr,
        # [ doc = "0x14 - CEC Tx data register" ]
        pub txd: Txd,
        # [ doc = "0x18 - CEC Rx data register" ]
        pub rxd: Rxd,
    }
    # [ doc = "configuration register" ]
    pub struct Cfgr {
        register: VolatileCell<u32>,
    }
    # [ doc = "configuration register" ]
    pub mod cfgr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Cfgr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PeR {
            bits: u8,
        }
        impl PeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct IeR {
            bits: u8,
        }
        impl IeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BtemR {
            bits: u8,
        }
        impl BtemR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BpemR {
            bits: u8,
        }
        impl BpemR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BtemW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BtemW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BpemW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BpemW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Peripheral enable" ]
            # [ inline ( always ) ]
            pub fn pe(&self) -> PeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PeR { bits }
            }
            # [ doc = "Bit 1 - Interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ie(&self) -> IeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IeR { bits }
            }
            # [ doc = "Bit 2 - Bit timing error mode" ]
            # [ inline ( always ) ]
            pub fn btem(&self) -> BtemR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BtemR { bits }
            }
            # [ doc = "Bit 3 - Bit period error mode" ]
            # [ inline ( always ) ]
            pub fn bpem(&self) -> BpemR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BpemR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Peripheral enable" ]
            # [ inline ( always ) ]
            pub fn pe(&mut self) -> _PeW {
                _PeW { w: self }
            }
            # [ doc = "Bit 1 - Interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ie(&mut self) -> _IeW {
                _IeW { w: self }
            }
            # [ doc = "Bit 2 - Bit timing error mode" ]
            # [ inline ( always ) ]
            pub fn btem(&mut self) -> _BtemW {
                _BtemW { w: self }
            }
            # [ doc = "Bit 3 - Bit period error mode" ]
            # [ inline ( always ) ]
            pub fn bpem(&mut self) -> _BpemW {
                _BpemW { w: self }
            }
        }
    }
    # [ doc = "CEC own address register" ]
    pub struct Oar {
        register: VolatileCell<u32>,
    }
    # [ doc = "CEC own address register" ]
    pub mod oar {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Oar {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OaR {
            bits: u8,
        }
        impl OaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:3 - Own address" ]
            # [ inline ( always ) ]
            pub fn oa(&self) -> OaR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:3 - Own address" ]
            # [ inline ( always ) ]
            pub fn oa(&mut self) -> _OaW {
                _OaW { w: self }
            }
        }
    }
    # [ doc = "Rx Data Register" ]
    pub struct Pres {
        register: VolatileCell<u32>,
    }
    # [ doc = "Rx Data Register" ]
    pub mod pres {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Pres {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PrescR {
            bits: u16,
        }
        impl PrescR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PrescW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PrescW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 16383;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:13 - CEC Rx Data Register" ]
            # [ inline ( always ) ]
            pub fn presc(&self) -> PrescR {
                let bits = {
                    const MASK: u16 = 16383;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PrescR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:13 - CEC Rx Data Register" ]
            # [ inline ( always ) ]
            pub fn presc(&mut self) -> _PrescW {
                _PrescW { w: self }
            }
        }
    }
    # [ doc = "CEC error status register" ]
    pub struct Esr {
        register: VolatileCell<u32>,
    }
    # [ doc = "CEC error status register" ]
    pub mod esr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Esr {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BteR {
            bits: u8,
        }
        impl BteR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BpeR {
            bits: u8,
        }
        impl BpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RbtfeR {
            bits: u8,
        }
        impl RbtfeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SbeR {
            bits: u8,
        }
        impl SbeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AckeR {
            bits: u8,
        }
        impl AckeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LineR {
            bits: u8,
        }
        impl LineR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TbtfeR {
            bits: u8,
        }
        impl TbtfeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Bit timing error" ]
            # [ inline ( always ) ]
            pub fn bte(&self) -> BteR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BteR { bits }
            }
            # [ doc = "Bit 1 - Bit period error" ]
            # [ inline ( always ) ]
            pub fn bpe(&self) -> BpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BpeR { bits }
            }
            # [ doc = "Bit 2 - Rx block transfer finished error" ]
            # [ inline ( always ) ]
            pub fn rbtfe(&self) -> RbtfeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RbtfeR { bits }
            }
            # [ doc = "Bit 3 - Start bit error" ]
            # [ inline ( always ) ]
            pub fn sbe(&self) -> SbeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SbeR { bits }
            }
            # [ doc = "Bit 4 - Block acknowledge error" ]
            # [ inline ( always ) ]
            pub fn acke(&self) -> AckeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AckeR { bits }
            }
            # [ doc = "Bit 5 - Line error" ]
            # [ inline ( always ) ]
            pub fn line(&self) -> LineR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LineR { bits }
            }
            # [ doc = "Bit 6 - Tx block transfer finished error" ]
            # [ inline ( always ) ]
            pub fn tbtfe(&self) -> TbtfeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TbtfeR { bits }
            }
        }
    }
    # [ doc = "CEC control and status register" ]
    pub struct Csr {
        register: VolatileCell<u32>,
    }
    # [ doc = "CEC control and status register" ]
    pub mod csr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Csr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TsomR {
            bits: u8,
        }
        impl TsomR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TeomR {
            bits: u8,
        }
        impl TeomR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TerrR {
            bits: u8,
        }
        impl TerrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TbtrfR {
            bits: u8,
        }
        impl TbtrfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RsomR {
            bits: u8,
        }
        impl RsomR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ReomR {
            bits: u8,
        }
        impl ReomR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RerrR {
            bits: u8,
        }
        impl RerrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RbtfR {
            bits: u8,
        }
        impl RbtfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TsomW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsomW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TeomW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeomW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TerrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TerrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TbtrfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TbtrfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RsomW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RsomW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReomW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReomW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RerrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RerrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RbtfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RbtfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bit 0 - Tx start of message" ]
            # [ inline ( always ) ]
            pub fn tsom(&self) -> TsomR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsomR { bits }
            }
            # [ doc = "Bit 1 - Tx end of message" ]
            # [ inline ( always ) ]
            pub fn teom(&self) -> TeomR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeomR { bits }
            }
            # [ doc = "Bit 2 - Tx error" ]
            # [ inline ( always ) ]
            pub fn terr(&self) -> TerrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TerrR { bits }
            }
            # [ doc = "Bit 3 - Tx byte transfer request or block transfer finished" ]
            # [ inline ( always ) ]
            pub fn tbtrf(&self) -> TbtrfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TbtrfR { bits }
            }
            # [ doc = "Bit 4 - Rx start of message" ]
            # [ inline ( always ) ]
            pub fn rsom(&self) -> RsomR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RsomR { bits }
            }
            # [ doc = "Bit 5 - Rx end of message" ]
            # [ inline ( always ) ]
            pub fn reom(&self) -> ReomR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ReomR { bits }
            }
            # [ doc = "Bit 6 - Rx error" ]
            # [ inline ( always ) ]
            pub fn rerr(&self) -> RerrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RerrR { bits }
            }
            # [ doc = "Bit 7 - Rx byte/block transfer finished" ]
            # [ inline ( always ) ]
            pub fn rbtf(&self) -> RbtfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RbtfR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Tx start of message" ]
            # [ inline ( always ) ]
            pub fn tsom(&mut self) -> _TsomW {
                _TsomW { w: self }
            }
            # [ doc = "Bit 1 - Tx end of message" ]
            # [ inline ( always ) ]
            pub fn teom(&mut self) -> _TeomW {
                _TeomW { w: self }
            }
            # [ doc = "Bit 2 - Tx error" ]
            # [ inline ( always ) ]
            pub fn terr(&mut self) -> _TerrW {
                _TerrW { w: self }
            }
            # [ doc = "Bit 3 - Tx byte transfer request or block transfer finished" ]
            # [ inline ( always ) ]
            pub fn tbtrf(&mut self) -> _TbtrfW {
                _TbtrfW { w: self }
            }
            # [ doc = "Bit 4 - Rx start of message" ]
            # [ inline ( always ) ]
            pub fn rsom(&mut self) -> _RsomW {
                _RsomW { w: self }
            }
            # [ doc = "Bit 5 - Rx end of message" ]
            # [ inline ( always ) ]
            pub fn reom(&mut self) -> _ReomW {
                _ReomW { w: self }
            }
            # [ doc = "Bit 6 - Rx error" ]
            # [ inline ( always ) ]
            pub fn rerr(&mut self) -> _RerrW {
                _RerrW { w: self }
            }
            # [ doc = "Bit 7 - Rx byte/block transfer finished" ]
            # [ inline ( always ) ]
            pub fn rbtf(&mut self) -> _RbtfW {
                _RbtfW { w: self }
            }
        }
    }
    # [ doc = "CEC Tx data register" ]
    pub struct Txd {
        register: VolatileCell<u32>,
    }
    # [ doc = "CEC Tx data register" ]
    pub mod txd {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Txd {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TxdR {
            bits: u8,
        }
        impl TxdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TxdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Tx Data register" ]
            # [ inline ( always ) ]
            pub fn txd(&self) -> TxdR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxdR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 0:7 - Tx Data register" ]
            # [ inline ( always ) ]
            pub fn txd(&mut self) -> _TxdW {
                _TxdW { w: self }
            }
        }
    }
    # [ doc = "CEC Rx data register" ]
    pub struct Rxd {
        register: VolatileCell<u32>,
    }
    # [ doc = "CEC Rx data register" ]
    pub mod rxd {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        impl super::Rxd {
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RxdR {
            bits: u8,
        }
        impl RxdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            # [ doc = "Bits 0:7 - Rx data" ]
            # [ inline ( always ) ]
            pub fn rxd(&self) -> RxdR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxdR { bits }
            }
        }
    }
}
# [ doc = "HDMI-CEC controller" ]
pub struct Cec {
    register_block: cec::RegisterBlock,
}
impl Deref for Cec {
    type Target = cec::RegisterBlock;
    fn deref(&self) -> &cec::RegisterBlock {
        &self.register_block
    }
}
